<!-- BEGIN HEADER -->
<!DOCTYPE html>
<html>
    <head>
        <title>Web-palvelinohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/chartist.min.css"/>
        <link rel="stylesheet" href="css/wepa.css"/>

        <link rel="stylesheet" href="css/wepa-mooc.css"/>

    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <a href="http://www.mooc.fi" class="hidden-in-hy">&#171; mooc.fi</a>

            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="index.html">Yleistä</a>
                    </li>
                    <li>
                        <a href="osa1.html">Osa 1</a>
                    </li>
                    <li>
                        <a href="osa2.html">Osa 2</a>
                    </li>
                    <li>
                        <a href="osa3.html">Osa 3</a>
                    </li>
                    <li>
                        <a href="osa4.html">Osa 4</a>
                    </li>
                    <li>
                        <a href="osa5.html">Osa 5</a>
                    </li>
                    <li>
                        <a href="osa6.html">Osa 6</a>
                    </li>
                    <li>
                        <a href="osa7.html">Osa 7</a>
                    </li>
                </ul>

		<div style="direction: rtl;">
		  <button id="logout" class="btn btn-warning">Kirjaudu ulos</button>
		</div>
            </nav>

        </header>
        <!-- // END NAV -->
        <article>


          <div class="modal fade" id="tmcAuthModal" data-backdrop="static" data-keyboard="false"  tabindex="-1" role="dialog" aria-labelledby="tmcAuthModalLabel" aria-hidden="true">
            <div class="modal-dialog">
              <form class="form-inline"  id="TmcLoginForm" role="form">
		<div class="modal-content">
                  <div class="modal-header">
                    <h4 class="modal-title" id="tmcAuthModalLabel">Kirjoita TMC-tunnuksesi</h4>
                  </div>
                  <div class="modal-body">
                    <p>Pyydämme sinua kirjautumaan TMC-tunnuksillasi materiaaliin. Kirjautumistietoja käytetään oppimateriaalin käytön tutkimukseen.</p>
                    <div id="tmc-account-wrong-alert" class="hidden alert alert-danger">Tarkista TMC-tunnuksesi</div>
                    <div class="form-group">
                      <label class="sr-only" for="exampleInputPassword2">TMC-tunnus</label>
                      <input type="text" name="tmcAccountName" class="form-control" id="inputTmcAccount" placeholder="TMC-tunnus">
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" id="tmcAccountNOACCOUNT" class="btn btn-default" data-dismiss="modal">En halua tai en tiedä TMC-tunnustani</button>
                    <button type="submit" name="tmcLoginButton" id="tmcAccountOK" class="btn btn-primary">OK</button>
                  </div>
		</div><!-- /.modal-content -->
              </form>
            </div><!-- /.modal-dialog -->
          </div><!-- /.modal -->

	  <!-- END HEADER -->
	  

          <!-- BEGIN INDEX -->
          <section id="intro" class="no-toc weeklimit" data-week-id="0">

            <header>
	      
              <div class="intro-header-img"></div>
	      
              <h1>Web-palvelinohjelmointi</h1>
	      
              <p>Voinko oppia tekemään Facebookin, Flickrin tai Twitterin?</p>
	      
              <a class="call-to-action" href="#start" role="button">No todellakin!</a>
	      
            </header>
	    
            <h1 id="start">Sisältö, aikataulu ja arvostelu</h1>
	    
            <p>
	      Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla vain pieni paino. Kurssin opetuskieli on suomi ja ohjelmointikieli Java.
	    </p>
	    
            <p><a class="jump" href="#teemat" role="button">Teemat ja oppimistavoitteet &raquo;</a></p>
	    
            <h2>Opettajille ja opiskelijoille</h2>
	    
            <p>Kurssi vastaa <a href="http://www.cs.helsinki.fi/home/" target="_blank">Helsingin yliopiston tietojenkäsittelytieteen laitoksen</a> kurssia <a href="http://www.cs.helsinki.fi/en/courses/582353" target="_blank">Web-palvelinohjelmointi</a> (5 opintopistettä). Kurssia ja sen materiaalia saa käyttää ja muokata vapaasti, kunhan noudattaa materiaalin alalaidassa olevaa <a href="#license">lisenssiä</a>.</p>
	    
            <p>Saat opettajana käyttää kurssia vapaasti omassa oppilaitoksessasi, kunhan et pyydä kurssista maksua opiskelijoilta.</p>
	    
            <p>
	      Kurssi tarjotaan kesällä 2017 itseopiskelukurssina. Kesän 2017 kurssi käyttää vuoden 2016 materiaalia. Syksyllä 2017 tarjolle tulee hieman päivitetty versio kurssista. 
	    </p>

	    <h2>Arvostelu</h2>
	    

	    <h3>Kesä 2017, TKTL</h3>

            <p>Kurssin arvostelu perustuu harjoitustehtäviin, harjoitustyöhön sekä tenttiin. Kurssin pisteytys on seuraava:</p>
	    
	    <ul>
	      <li>Harjoitustehtävät. Kurssilla on seitsemän osiota. Osion tehtävistä saa 100 pistettä kun tekee kaikki tehtävät, 50 pistettä jos tekee puolet tehtävistä jne. Seuraavaan osaan siirtyminen vaatii aina vähintään puolet edellisen osan pisteistä. </li>
	      <li>Harjoitustyöstä voi saada 300 pistettä. </li>
	      <li>Tentistä voi saada 200 pistettä.</li>
	    </ul>
	    
	    <p>Kurssista voi saada yhteensä 1200 pistettä. Kurssin arvosanarajat ovat seuraavat:</p>
	    
	    <ul>
	      <li>700 -> 1</li>
	      <li>800 -> 2</li>
	      <li>900 -> 3</li>
	      <li>1000 -> 4</li>
	      <li>1100 -> 5</li>
	    </ul>
	    
	    <p>
	      Tentin ja harjoitustyön pisteistä tulee saada vähintään puolet kurssin läpäisemiseksi. Kurssilla ei ole erillistenttimahdollisuutta; kaikissa tenteissä otetaan huomioon kurssipisteet ja tehtäväpisteet.
	    </p>

	    <p>
	      Harjoitustyön ohjeet: <a href="https://docs.google.com/document/d/1RAA0fTPp__2kzpc4glv1pvPercJ-Vzm9wvmvyc8zmmQ/edit" target="_blank">https://docs.google.com/document/d/1RAA0fTPp__2kzpc4glv1pvPercJ-Vzm9wvmvyc8zmmQ/edit</a>.
	    </p>

	    <p>
	      Kurssin tentti järjestetään joko yksin tai ryhmässä tapahtuvana suullisena kuulusteluna. Tenttejä järjestetään elokuun loppupuolella, ja tenttiin ilmoittaudutaan sähköpostitse.
	    </p>
	    
            <h1>Esitietovaatimukset ja kurssin suorittaminen</h1>
	    
            <p>
	      Kurssilla oletetaan Java-ohjelmointikielen tuntemus kurssien ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi laajuudessa (vastaa <a href="http://mooc.fi/" target="_blank">mooc.fi</a>-osoitteessa olevaa kurssia Ohjelmoinnin MOOC. Tämän lisäksi oletetaan, että osallistuja tuntee Helsingin yliopistolla järjestettävien kurssien <a href="http://tietokantojen-perusteet.github.io/" target="_blank">Tietokantojen perusteet</a> ja <a href="https://github.com/mluukkai/OTM2015/wiki/Ohjelmistotekniikan-menetelmat" target="_blank">Ohjelmistotekniikan menetelmät</a> sisällöt oleellisilta osin -- tai, että osaajalla on muuta kautta tarvittava osaaminen. Myös kurssin <a href="http://web-selainohjelmointi.github.io" target="_blank">Web-selainohjelmointi</a> tuntemuksesta on hyötyä.
	    </p>
	    
	    <p>
	      Omatoiminen tiedon hakeminen on erittäin tärkeää tällä kurssilla menestymiseen.
	    </p>
	    
	    
	    <h2>Tehtävien tekeminen ja palauttaminen</h2>
	    
	    
	    <p>Kurssin tehtävien tekemisessä hyödynnetään Helsingin yliopiston tietojenkäsittelytieteen laitoksellä kehitettyä <a href="http://testmycode.github.io/" target="_blank">Test My Code</a>-palvelua, joka mm. tarjoaa ohjelmointiympäristöön liitettävän TMC-liitännäisen. Kurssitehtävät noudetaan paikalliselle koneelle TMC-liitännäisen avulla. TMC mahdollistaa myös tehtävien suoraviivaisen palauttamisen tehtäväpalvelimelle. Osa kurssin tehtävistä tarkastetaan automaattisesti TMC-palvelun avulla -- muiden tehtävien toiminta tulee taas tarkastaa itse erilaisten tukimateriaalien kuten kuvien avulla.</p>

	    <p>Helsingin yliopiston kurssilla käytettävä TMC-palvelin löytyy osoitteessa <a href="https://tmc.mooc.fi/org/hy" target="_blank">https://tmc.mooc.fi/org/hy</a>, kurssin nimenä on <code>kesa2017-wepa</code>. Alkutoimet kurssilla käytettävien työvälineiden asentamiseen löytyy osoitteesta <a href="http://mooc.fi/courses/general/ohjelmointi/" target="_blank">http://mooc.fi/courses/general/ohjelmointi/</a>.</p>
	    
            <h2>Kurssin tukimuodot</h2>

	    <p>
	      Kesällä 2017 kurssi on täysin itseopiskelukurssi.
	    </p>
	    
	    <p>Muita kurssilaisia saattaa olla <code>#mooc.fi</code>-kanavalla. Muiden auttaminen kanavalla on vapaaehtoista, mutta luonnollisesti suositeltavaa. Auttamisesta hyötyy apua tarvitsevan lisäksi myös auttaja.</p>
	    
	    <p>Ohjeet IRC:n käyttöön löytyvät <a href="http://mooc.fi/courses/general/ohjelmointi/tukikanavat/irc/ohjeet/" target="_blank">tämän linkin takaa</a>.</p>
	    
	    
            <h1 id="teemat">Teemat ja oppimistavoitteet</h1>
<!--
	    <p>Kurssin teemat ja oppimistavoitteet täydentyvät kurssin edetessä. Alustava julkaisuaikataulu: 11.7.2016 (osa1), 18.7.2016 (osa2), 25.7.2016 (osa3), 1.8.2016 (osa4), 8.8.2016 (osa5), 15.8.2016 (osa6), 22.8.2016 (osa7).</p>
-->
	    <p>
	    
	    <table class="table">
	      <thead>
		<tr>
		  <th class="col-md-1">Osa</th>
		  <th class="col-md-4">Teemat</th>
		  <th class="col-md-12">Oppimistavoitteet</th>
		</tr>
	      </thead>
	      <tbody>
		<tr>
		  <td>-</td>
		  <td>Esitiedot</td>
		  <td>Olio-ohjelmointi ja ohjelmointiympäristön käyttö (Ohjelmoinnin MOOC), Yksikkötestaus (Ohjelmistotekniikan menetelmät), Versionhallinta (Ohjelmistotekniikan menetelmät), Relaatiotietokantojen toiminta (Tietokantojen perusteet)</td>
		</tr>
		<tr>
		  <td><a href="osa1.html">1</a></td>
		  <td>Johdanto web-sovellusten toimintaan. Yhtä tietokantataulua käyttävä web-sovellus.</td>
		  <td>Osaa toteuttaa yhtä tietokantataulua käyttävän web-sovelluksen.</td>
		</tr>
		<tr>
		  <td><a href="osa2.html">2</a></td>
		  <td>Internetin perusosat. Kerrosarkkitehtuuri ja MVC-malli. Pyynnön kulku web-sovelluksessa. Tietokannat ja tietokanta-abstraktiot. </td>
		  <td>Ymmärtää asiakas-palvelin -mallin. Tietää ensisijaiset kerrosarkkitehtuurin ja MVC-mallin edut. Ymmärtää miten käyttäjän tekemään pyyntöön muodostuu vastaus palvelimella. Osaa luoda web-sovelluksen, joka käyttää useampaa tietokantataulua. Ymmärtää tietokantatransaktioiden käytön ja osaa käyttää niitä web-sovelluksessa.</td>
		</tr>
		<tr>
		  <td><a href="osa3.html">3</a></td>
		  <td>HTTP-protokolla ja käyttäjän tilan ylläpito. Konfiguraatioprofiilit. Web-sovellusten testaaminen.</td>
		  <td>Ymmärtää HTTP-protokollan hyödyt ja rajoitteet. Ymmärtää mitä evästeet ovat, miten ne toimivat, sekä tietää niihin liittyvät uhkat ja lakitekniset rajoitteet. Osaa luoda kirjautuneen käyttäjän muistavan web-sovelluksen. Osaa kirjoittaa automaattisia yksikkötestejä web-sovellukselle. Ymmärtää paikallisen kehitys- ja testausympäristön hyödyt.</td>
		</tr>
		<tr>
		  <td><a href="osa4.html">4</a></td>
		  <td>Web-sovelluskehitykseen liittyvä ohjelmistokehitysprosessi. Tietokantamigraatiot. REST-arkkitehtuurimalli. </td>
		  <td>Ymmärtää tarpeen web-sovellusten kehitysprosessin automatisoinnille sekä web-sovellusten jatkuvalle inkrementaaliselle kehitykselle. Ymmärtää versionhallintapalvelun (esim. Github), sovelluksen testejä suorittavan integraatiopalvelun (esim. Travis CI) sekä testi- ja tuotantoympäristön (esim. Heroku) yhteistyön. Hyödyntää valmiita työvälineitä tietokantaskeeman päivittämiseen ohjelmistokehityksen yhteydessä. Ymmärtää REST-arkkitehtuurimallin perusperiaatteet. </td>
		</tr>
		<tr>
		  <td><a href="osa5.html">5</a></td>
		  <td>Javascript-pohjaisten selainohjelmistojen ja palvelinohjelmistojen yhteistyö. Web-sovellusten tietoturva.</td>
		  <td>Osaa tehdä selainohjelmistosta Javascript-pyynnön palvelimelle. Päivittää näkymän Javascript-pyynnön vastauksen perusteella. Tietää web-sovellusten tyypillisimmät haavoittuvuudet sekä niihin vaikuttavat tekijät (OWASP). Välttää tyypillisimmät haavoittuvuudet omassa ohjelmistossaan. Osaa etsiä haavoittuvuuksia muiden ohjelmistoista sekä ehdottaa niihin korjauksia.</td>
		</tr>
		<tr>
		  <td><a href="osa6.html">6</a></td>
		  <td>Web-sovellusten skaalaaminen isoille käyttäjäjoukoille. Asynkroniset metodikutsut. Palveluperustaiset arkkitehtuurit ja mikroarkkitehtuurit.</td>
		  <td>Ymmärtää sovelluksen vasteajan ja käyttäjäkokemuksen yhteyden. Ymmärtää web-sovellusten pullonkaulat ja osaa ehdottaa tapoja pullonkaulojen kiertämiseen. Ymmärtää vertikaaliseen ja horisontaaliseen skaalautumiseen liittyvät hyödyt ja haasteet.  Ymmärtää palveluperustaisten arkkitehtuurien ja mikroarkkitehtuurien perusperiaatteet. Osaa tehdä web-sovelluksen, joka käyttää ja kerää tietoa useammasta erillisestä web-sovelluksesta.</td>
		</tr>
		<tr>
		  <td><a href="osa7.html">7</a></td>
		  <td>Reaktiivinen ohjelmointi. Kertaus.</td>
		  <td>Ymmärtää reaktiivisen ohjelmoinnin perusteet ja osaa tehdä yksinkertaisen palvelinohjelmiston reaktiivisella ohjelmointiparadigmalla. </td>
		</tr>	      	      
	      </tbody>
	    </table>

<!--
            <ul id="week-toc">
              <li><a href="#osa1">Osa 1</a> Johdanto web-sovellusten tekemiseen.</li>
              <li><a href="#osa2">Osa 2</a> HTTP-protokolla, sessiot, relaatiotietokannan käyttö.</li>
	    </ul>
	    
	    <p>Teemalistausta täydennetään kurssin edetessä.</p>
-->
	    
	    
          </section>
          <!-- END INDEX -->
	  
	  <!-- BEGIN CONTENT -->
	  <section class="no-toc weeklimit" data-week-id="0">
            <h1>Sisällysluettelo</h1>
	    
            <ul class="nav" id="material-toc"></ul>
	    
            <h1>Tehtävät</h1>
	    
            <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>
	    
	  </section>
	  <!-- END CONTENT -->

          <!-- BEGIN OSA1 -->
          <section class="weeklimit" data-week-id="1">
	    
            <header>
              <h1 id="osa1">Osa 1</h1>
            </header>
	    
            <h1>Web-sovellusten alkeet</h1>
	    
            <p>Web-sovellukset koostuvat selain- ja palvelinpuolesta. Käyttäjän koneella toimii selainohjelmisto (esim. <a href="http://chrome.google.com" target="_blank">Google Chrome</a>), jonka kautta käyttäjä tekee pyyntöjä verkossa sijaitsevalle palvelimelle. Kun palvelin vastaanottaa pyynnön, se käsittelee pyynnön ja rakentaa vastauksen. Vastaus voi sisältää esimerkiksi web-sivun HTML-koodia tai jossain muussa muodossa olevaa tietoa.</p>
	    
            <div class="image">
              <img src="img/pyynto.png"/>
              <div>Web-sovellusten käyttäminen: (1) käyttäjä klikkaa linkkiä, (2) selain tekee pyynnön palvelimelle, (3) palvelin käsittelee pyynnön ja rakentaa vastauksen, (4) selaimen tekemään pyyntöön palautetaan vastaus, (5) vastauksen näyttäminen käyttäjälle -- ei tässä kuvassa.</div>
            </div>
	    
            <p>Selainohjelmointiin ja käyttöliittymäpuoleen keskityttäessä painotetaan rakenteen, ulkoasun ja toiminnallisuuden erottamista toisistaan. Karkeasti voidaan sanoa, että selaimessa näkyvän sivun rakenne määritellään <a href="http://en.wikipedia.org/wiki/HTML" target="_blank">HTML</a>-tiedostoilla, ulkoasu <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>-tiedostoilla ja toiminnallisuus <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>-tiedostoilla.</p>
	    
            <p>Palvelinpuolen toiminnallisuutta toteutettaessa keskitytään tyypillisesti selainohjelmiston tarvitsevan "APIn" suunnitteluun ja toteutukseen, sivujen muodostamiseen selainohjelmistoa varten, datan tallentamiseen ja käsittelyyn, sekä sellaisten laskentaoperaatioiden toteuttamiseen, joita selainohjelmistossa ei kannata tai voida tehdä.</p>
	    
	    
	    <h2>Ensimmäinen palvelinohjelmisto</h2>
	    
	    <p>Käytämme kurssilla <a href="https://spring.io/" target="_blank">Spring</a> -sovellusperheen <a href="http://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a> -projektia web-sovellusten tekemiseen. Merkittävä osa web-sovellusten rakentamisesta perustuu valmiiden kirjastometodien käyttöön. Niiden avulla määritellään (1) mihin osoitteeseen tulevat pyynnöt käsitellään ja (2) mitä pyynnölle tulee tehdä.</p>
	    
	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Maven</h1>
	      
	      <p>Käytämme tällä kurssilla <a href="https://maven.apache.org/" target="_blank">Maven</a>ia valmiiden kirjastojen noutamiseen sekä projektien hallintaan. Tämän takia projektimme on luotu Maven-projekteina -- uuden Maven-projektin luominen onnistuu NetBeansissa valitsemalla File -&gt; New Project -&gt; Maven -&gt; Java Application.</p>
	      
	      <p>Maven-projektin riippuvuudet määritellään projektiin liittyvässä (Project Files) <code>pom.xml</code>-tiedostossa olevassa <code>dependencies</code>-osiossa.</p>

	      <p>Spring-projektin käynnistäminen kannattaa tehdä komentoriviltä komennolla <code>mvn spring-boot:run</code>. Tällöin sovellus käynnistyy muutosten yhteydessä automaattisesti uudestaan (kun käytämme <code>spring-boot-devtools</code> liitännäistä sekä Spring-sovelluskehyksen maven-tukea) -- tämä nopeuttaa hieman ohjelmistokehitysprosessia. Lisää <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html" target="_blank">Spring Devtools</a>-projektista löytyy täältä.</p>
	      
	    </aside>
	    
	    <p>Spring -sovelluskehystä käyttävien web-sovellusten kehityksessä käytettävät osat saa käyttöön lisäämällä projektiin riippuvuuden Spring Boot -projektiin (<code>spring-boot-starter-parent</code>) sekä web-projektiin (<code>spring-boot-starter-web</code>).</p>

<pre class="sh_xml">
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>

	    <p>Kun riippuvuudet on lisätty projektiin ja projektista pääsee käsiksi Spring-sovelluskehyksen metodeihin ja luokkiin, voimme luoda ensimmäisen palvelinohjelmistomme.</p>

<pre class="sh_java">
package heimaailma;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@SpringBootApplication
@Controller
public class HeiMaailmaController {

    @RequestMapping("*")
    @ResponseBody
    public String home() {
        return "Hei Maailma!";
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HeiMaailmaController.class, args);
    }
}
</pre>

	    <p>Yllä olevassa esimerkissä luodaan pyyntöjä vastaanottava luokka. Pyyntöjä vastaanottavat luokat merkitään <code>@Controller</code>-annotaatiolla. Tämän perusteella Spring-sovelluskehys tietää, että luokan metodit saattavat käsitellä selaimesta tehtyjä pyyntöjä.</p>

	    <p>Luokalle on määritelty lisäksi metodi <code>home</code>, jolla on kaksi annotaatiota: <code>@RequestMapping</code> ja <code>@ResponseBody</code>. Annotaation <code>@RequestMapping</code> avulla määritellään kuunneltava osoite -- tässä kaikki <code>"*"</code>. Annotaatio <code>@ResponseBody</code> kertoo sovelluskehykselle, että metodin vastaus tulee näyttää vastauksena sellaisenaan.</p>

	    <p>Eriytämme pyyntöjä vastaanottavat luokat ja sovelluksen käynnistämiseen käytettävän luokan jatkossa toisistaan.</p>

<pre class="sh_java">
package heimaailma;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HeiMaailmaApplication {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HeiMaailmaApplication.class, args);
    }
}
</pre>

<pre class="sh_java">
package heimaailma;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HeiMaailmaController {

    @RequestMapping("*")
    @ResponseBody
    public String home() {
        return "Hei Maailma!";
    }
}
</pre>


	    <aside class="info">
	      <br/>
	      <h1>Tehtävien tekeminen</h1>
	      
              <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi.</p>
	      
	    </aside>
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-helloweb-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                      Hello World! (Klikkaa tästä niin tehtävä aukeaa)
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloweb" class="collapse">
		  
                  <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>
		  
                  <p>Toteuta tehtäväpohjan pakkauksessa <code>wad.helloworld</code> olevaan <code>HelloWorldController</code> luokkaan toiminnallisuus, joka kuuntelee kaikkia pyyntöjä. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>
		  
                  <p><img class="browser-img" src="img/2016-mooc/ex1.png"/></p>
		  
                  <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>HelloWorldApplication</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> ja näet selaimessasi tekstin "Hello World!".</p>
		  
                  <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                </div>
              </div>
	    </div>
	    
	    
	    <aside class="info">
	      <br/>
	      <h1>Apua! Palvelimeni ei suostu sammumaan!</h1>
	      
	      <p>Palvelimen sammuttaminen tapahtuu NetBeansissa punaista neliötä klikkaamalla, joka sammuttaa suoritettavan ohjelman. Joissakin käyttöjärjestelmissä tämä on kuitenkin bugista, jolloin palvelin tulee sammuttaa komentoriviltä.</p>
	      
	      <p>Saat portissa 8080 käynnissä olevan prosessin tunnuksen tietoon terminaalissa komennolla <code>lsof -i :8080</code>. Etsi komennon palauttamasta tulosteesta prosessin tunnus, jonka jälkeen voit sammuttaa prosessin komennolla <code>kill -9 prosessin-tunnus</code>.</p>
	      
	      <p>Esimerkiksi:</p>
		  
<pre>
> lsof -i :8080
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
>
</pre>

	      <p>Yllä prosessin tunnus (PID) on 9916. Tämän jälkeen prosessi sammutetaan komennolla <code>kill -9 9916</code>.</p>

<pre>
> lsof -i :8080
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
> kill -9 9916
</pre>

	    </aside>


	    <h2>Palvelinohjelmiston polut</h2>

	    <p>Opimme aiemmin, että voimme kuunnella kaikkia palvelinohjelmistoon tulevia pyyntöjä asettamalla <code>@RequestMapping</code>-annotaation parametriksi <code>"*"</code>. Käytännössä tämän parametrin avulla määritellään <em>polku</em>, johon palvelimelle tulevat pyynnöt voidaan ohjata. Tähdellä määritellään, että kaikki pyynnöt päätyvät samalle polulle. Muiden polkujen määrittely on luonnollisesti myös mahdollista.</p>
	    
	    <p>Antamalla poluksi merkkijonon <code>"/salaisuus"</code>, kaikki web-palvelimen osoitteeseen <code>/salaisuus</code> tehtävät pyynnöt ohjautuvat kyseiseen polkuun liitettyyn toiminnallisuuteen. Allaolevassa esimerkissä määritellään polku <code>/salaisuus</code> ja kerrotaan, että polkuun tehtävät pyynnöt palauttavat merkkijonon <code>"Kryptos"</code>.</p>
	    
<pre class="sh_java">
    @RequestMapping("/salaisuus")
    @ResponseBody
    public String home() {
        return "Kryptos";
    }
</pre>

	    <p>Yhteen ohjelmaan voi myös määritellä useampia polkuja sekä niihin liittyviä toiminnallisuuksia. Jokainen polku käsitellään omassa metodissaan. Alla olevassa esimerkissä pyyntöjä vastaanottavaan luokkaan on määritelty kolme erillistä polkua, joista jokainen palauttaa käyttäjälle merkkijonon.</p>

<pre class="sh_java">
package polut;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PolkuController {

    @RequestMapping("/path")
    @ResponseBody
    public String path() {
        return "Polku (path)";
    }

    @RequestMapping("/route")
    @ResponseBody
    public String route() {
        return "Polku (route)";
    }

    @RequestMapping("/trail")
    @ResponseBody
    public String trail() {
        return "Polku (trail)";
    }
}
</pre>
	    <p></p>

	    <div class="tehtavat">
	      
	      <div class="tehtava" id="t-hellopaths">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopaths">
                      Hello Paths
                    </a>
                  </h1>
                </header>
                <div id="t-hellopaths" class="collapse">
		  
                  <p>Toteuta pakkauksessa <code>wad.hellopaths</code> olevaan luokkaan <code>HelloPathsController</code> seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/hello</code> palauttaa käyttäjälle merkkijonon "Hello"</li>
		    <li>Pyyntö polkuun <code>/paths</code> palauttaa käyttäjälle merkkijonon "Paths"</li>
		  </ul>
		  
		  <p>Alla olevassa kuvassa on esimerkki tilanteesta, missä selaimella on tehty pyyntö polkuun <code>/hello</code></p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex2.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    <h2>Pyynnön parametrit</h2>
	    
	    <p>Pyynnöissä voi lähettää palvelimelle tietoa. Tutustutaan ensin tapaan, missä pyynnön parametrit lisätään osaksi haettavaa osoitetta. Esimerkiksi pyynnössä <code>http://localhost:8080/salaisuus?onko=nauris</code> on parametri nimeltä <code>onko</code>, jonka arvoksi on määritelty arvo <code>nauris</code>.</p>
	    
	    <p>Parametrien lisääminen pyyntöön tapahtuu lisäämällä osoitteen perään kysymysmerkki, jota seuraa parametrin nimi, yhtäsuuruusmerkki ja parametrille annettava arvo. Pyynnössä tuleviin parametreihin pääsee käsiksi <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html" target="_blank">@RequestParam</a></code>-annotaation avulla.</p>

	    <p>Allaolevassa esimerkissä on luotu palvelinohjelma, jonka tehtävänä on tervehtiä kaikkia pyynnön tekijöitä. Ohjelma käsittelee polkuun <code>/hei</code> tulevia pyyntöjä ja palauttaa niihin vastauksena tervehdyksen. Tervehdykseen liitetään pyynnössä tulevan <code>nimi</code>-nimisen parametrin arvo.</p>

<pre class="sh_java">
package parametrit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TervehtijaController {

    @RequestMapping("/hei")
    @ResponseBody
    public String tervehdi(@RequestParam String nimi) {
        return "Hei " + nimi + ", mitä kuuluu?";
    }
}
</pre>

	    <p>Nyt esimerkiksi osoitteeseen <code>http://localhost:8080/hei?nimi=Ada</code> tehtävä pyyntö saa vastaukseksi merkkijonon <code>Hei Ada, mitä kuuluu?</code>.</p>


	    <p>Jos parametreja on useampia, erotellaan ne toisistaan &amp;-merkillä. Seuraavassa esimerkissä pyynnössä on kolme parametria, <code>eka</code>, <code>toka</code> ja <code>kolmas</code>, joiden arvot ovat <code>1</code>, <code>2</code> ja <code>3</code> vastaavasti.</p>
	    
<pre>
http://localhost:8080/salaisuus?eka=1&amp;toka=2&amp;kolmas=3
</pre>

	    <p>Kaikki pyynnössä olevat parametrit saa pyyntöä käsittelevät metodin käyttöön samalla <code>@RequestParam</code>-annotaatiolla. Allaolevassa esimerkissä kaikki pyynnön parametrit asetetaan <code>Map</code>-tietorakenteeseen, jonka jälkeen kaikki pyynnön arvojen avaimet palautetaan kysyjälle.</p>

<pre class="sh_java">
package parametrit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PyyntoParametrienNimetController {

    @RequestMapping("/nimet")
    @ResponseBody
    public String nimet(@RequestParam Map&lt;String, String&gt; parametrit) {
        return parametrit.keySet().toString();
    }
}
</pre>


	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellorequestparams">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellorequestparams">
                      Hello Request Params
                    </a>
                  </h1>
                </header>
                <div id="t-hellorequestparams" class="collapse">
		  
                  <p>Toteuta pakkauksessa <code>wad.hellorequestparams</code> olevaan luokkaan <code>HelloRequestParamsController</code> seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/hello</code> palauttaa käyttäjälle merkkijonon "Hello ", johon on liitetty <code>param</code>-nimisen parametrin sisältämä arvo.</li>
		    <li>Pyyntö polkuun <code>/params</code> palauttaa käyttäjälle kaikkien pyynnön mukana tulevien parametrien nimet ja arvot.</li>
		  </ul>
		  
		  <p>Alla olevassa kuvassa on esimerkki tilanteesta, missä selaimella on tehty pyyntö polkuun <code>/params?hello=world&amp;it=works</code></p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex3.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-calculator">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-calculator">
                      Calculator
                    </a>
                  </h1>
                </header>
                <div id="t-calculator" class="collapse">
		  
		  <p>Toteuta tässä tehtävässä pakkauksessa <code>wad.calculator</code> sijaitsevaan <code>CalculatorController</code>-luokkaan seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/add</code> laskee parametrien <code>first</code> ja <code>second</code> arvot yhteen ja palauttaa vastauksen käyttäjälle. Huomaa että arvot ovat numeroita, ja ne tulee myös käsitellä numeroina.</li>
		    
		    <li>Pyyntö polkuun <code>/multiply</code> kertoo parametrien <code>first</code> ja <code>second</code> arvot ja palauttaa vastauksen käyttäjälle.</li>
		    
		    <li>Pyyntö polkuun <code>/sum</code> laskee <em>kaikkien</em> parametrien arvot yhteen ja palauttaa vastauksen käyttäjälle.</li>
		  </ul>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun pyyntö tehdään <code>/sum</code>-polkuun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex4.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
            <h2>Näkymät ja data</h2>
	    

            <p>Tähän asti luomamme sovellukset ovat vastaanottaneet tiettyyn polkuun tulevan pyynnön ja palauttaneet käyttäjälle merkkijonomuodossa olevaa tietoa. Tämä ei kuitenkaan ole ainoa palvelinohjelmistojen toimintatyyppi, vaan palvelin voi myös luoda käyttäjälle näkymän, jonka selain lopulta näyttää käyttäjälle. Näkymät luodaan tyypillisesti HTML-kielellä siten, että HTML-kielen sekaan on upotettu komentoja, joiden perusteella näkymään lisätään palvelimen tuottamaa tietoa.</p>
	    
            <p>Tällä kurssilla käyttämämme apuväline näkymän luomiseen on <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>, joka tarjoaa välineitä datan lisäämiseen HTML-sivuille. Käytännössä näkymiä luodessa luodaan ensin HTML-sivut, jonka jälkeen sivuille lisätään komentoja Thymeleafin käsiteltäväksi.</p>
	    
            <p>Thymeleaf-sivut ("templatet") sijaitsevat tällä kurssilla projektin kansiossa <code>src/main/resources/templates</code> tai sen alla olevissa kansioissa. NetBeansissa kansio löytyy kun klikataan "Other Sources"-kansiota.</p>

	    <aside class="info">
	      <br/>
	      
	      <h1>Thymeleafin käyttöönotto</h1>
	      
              <p>Thymeleafin käyttöönotto vaatii <code>pom.xml</code>-tiedostossa olevien riippuvuuksien muokkaamista. Web-sovellusten perustoiminnallisuus saatiin käyttöön lisäämällä <code>org.springframework.boot</code>-ryhmän komponentti <code>spring-boot-starter-web</code> pom.xml-tiedoston dependencies-osioon. Kun vaihdamme riippuvuuden muotoon <code>spring-boot-starter-thymeleaf</code>, pääsemme käyttämään Thymeleafia.</p>
	      
              <pre class="sh_xml">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>

	      <p>Jos edellämainittu riippuvuus ei ole aiemmin ladattuna koneelle, tulee se myös hakea. Tämä onnistuu joko kirjoittamalla komentorivillä projektin juuressa komento <code>mvn dependency:resolve</code> tai valitsemalle NetBeansissa projektiin liittyvä kansio <em>Dependencies</em> oikealla hiirennapilla ja painamalla <em>Download Declared Dependencies</em>.</p>
	      
	      <p>Thymeleaf vaatii myös, että jokaisen HTML-sivun <code>html</code>-elementin määrittelyssä tulee olla seuraavat määrittelyt.</p>

              <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;</pre>
	    </aside>

	    
	    <p>Allaolevassa esimerkissä luodaan juuripolkua <code>/</code> kuunteleva sovellus. Kun sovellukseen tehdään pyyntö, palautetaan HTML-sivu, jonka Thymeleaf käsittelee. Thymeleaf päättelee palautettavan sivun metodin palauttaman merkkijonon perusteella. Alla metodi palauttaa merkkijonon <code>"index"</code>, jolloin Thymeleaf etsii kansiosta <code>src/main/resources/templates/</code> sivua <code>index.html</code>. Kun sivu löytyy, Thymeleaf käsittelee sen ja palauttaa sen käyttäjälle. Palaamme tarkemmin tähän käsittelyyn myöhemmin.</p>


<pre class="sh_java">
package thymeleaf;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ThymeleafController {

    @RequestMapping("/")
    public String home() {
        return "index";
    }
}
</pre>

	    <p>Huomaa, että pyyntöjä käsittelevällä metodilla ei enää ole annotaatiota <code>@ResponseBody</code>. Emme siis enää halua, että metodin palauttama arvo näytetään suoraan käyttäjälle, vaan haluamme, että käyttäjälle näytetään merkkijonon ilmaisema näkymä. Näkymä luodaan Thymeleafin avulla.</p>


	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellothymeleaf">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellothymeleaf">
                      Hello Thymeleaf
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellothymeleaf" class="collapse">
		  
		  <p>Toteuta tässä tehtävässä pakkauksessa <code>wad.hellothymeleaf</code> sijaitsevaan <code>HelloThymeleafController</code>-luokkaan seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö juuripolkuun <code>/</code> palauttaa käyttäjälle Thymeleafin avulla kansiossa <code>src/main/resources/templates/</code> olevan <code>index.html</code>-tiedoston.</li>
		    
		    <li>Pyyntö polkuun <code>/video</code> palauttaa käyttäjälle Thymeleafin avulla kansiossa <code>src/main/resources/templates/</code> olevan <code>video.html</code>-tiedoston.</li>
		    
		  </ul>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun selaimella on tehty pyyntö sovelluksen juuripolkuun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex5.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>


	    <aside class="info">
	      <br/>
	      <h1>HTML</h1>

	      <p>Jos mietit mistä ihmeestä tuossa HTML-lyhenteessä on kyse tai haluat verestää HTML-osaamistasi, nyt on hyvä hetki käydä lukemassa osoitteessa <a href="http://www.w3schools.com/html/default.asp" target="_blank">http://www.w3schools.com/html/default.asp</a> oleva HTML-opas.</p>

	    </aside>
	    
<!--	    
	    <p>Tarkastellaan edellä toteutettua sivun palauttamista vielä tarkemmin.</p>

<pre class="sh_java">
get("/", (req, res) -> {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    return new ModelAndView(map, "sivu");
}, new ThymeleafTemplateEngine());
</pre>

            <p>Ensimmäisellä rivillä kerromme, että juuripolkuun tulevat pyynnöt tulee käsitellä seuraavasti. Tätä seuraa pyynnön käsittelyyn liittyvä lohko, josta palautetaan olio, joka sisältää <code>HashMap</code>-olion sekä tiedon näytettävästä html-sivusta. Tämän jälkeen pyynnön käsittelyyn lisätään vielä erillinen olio, <code>ThymeleafTemplateEngine</code>, joka käsittelee html-sivun ennen sen palautusta.</p>
-->

            <h3>Datan lisääminen näkymään</h3>

	    <p>Palvelinohjelmistossa luodun tai haetun datan lisääminen näkymään tapahtuu <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/ui/Model.html" target="_blank">Model</a>-tyyppisen olion avulla. Kun lisäämme Model-olion pyyntöjä käsittelevän metodin parametriksi, lisää Spring-sovelluskehys sen automaattisesti käyttöömme. </p>


<pre class="sh_java">
package thymeleafdata;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

public class ThymeleafJaDataController {

    @RequestMapping("/")
    public String home(Model model) {
        return "index";
    }
}
</pre>
      
	    <p>Model on Spring-sovelluskehyksen käyttämä Map-rajapinnan toimintaa muistuttava lokerikko, missä jokaisella lokerolla on nimi, mihin arvon voi asettaa. Alla olevassa esimerkissä määrittelemme pyyntöjä käsittelevälle metodille Model-olion, jonka jälkeen lisäämme lokeroon nimeltä <code>teksti</code> arvon <code>"Hei mualima!"</code>.</p>


<pre class="sh_java">
package thymeleafdata;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ThymeleafJaDataController {

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("teksti", "Hei mualima!");
        return "index";
    }
}
</pre>

	    <p>Kun käyttäjä tekee pyynnön, joka ohjautuu ylläolevaan metodiin, ohjautuu pyyntö <code>return</code>-komennon jälkeen Thymeleafille, joka saa käyttöönsä myös Model-olion ja siihen lisätyt arvot.</p>

	    <h3>Sivun käsittely Thymeleafissa</h3>
	    
	    <p>Oletetaan, että käytössämme olevan <code>index.html</code>-sivun lähdekoodi on seuraavanlainen:</p>
	    
<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p>Kun Thymeleaf käsittelee HTML-sivun, se etsii sieltä elementtejä, joilla on <code>th:</code>-alkuisia attribuutteja. Ylläolevasta sivusta Thymeleaf löytää <code>h2</code>-elementin, jolla on attribuutti <code>th:text</code> -- <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>. Attribuutti <code>th:text</code> kertoo Thymeleafille, että elementin tekstiarvo (testi) tulee korvata attribuutin arvon ilmaisemalla muuttujalla. Attribuutin <code>th:text</code> arvona on <code>${teksti}</code>, jolloin Thymeleaf etsii <code>model</code>-oliosta avaimella <code>"teksti"</code> arvoa.</p>
	    
	    <p>Käytännössä Thymeleaf etsii siis Model-oliosta lokeron nimeltä <code>teksti</code> ja asettaa siinä olevan arvon <code>h2</code>-elementin tekstiarvoksi. Tässä tapauksessa teksti <code>testi</code> korvataan Model-olion lokerosta teksti löytyvällä arvolla, eli tekstillä <code>Hei mualima!</code>.</p>
	    
	    <p></p>
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellomodel">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellomodel">
                      Hello Model
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellomodel" class="collapse">
		  
		  <p>Tehtäväpohjan mukana tulevaan HTML-tiedostoon on toteutettu tarina, joka tarvitsee otsikon ja päähenkilön. Toteuta pakkauksessa <code>wad.hellomodel</code> sijaitsevaan <code>HelloModelController</code>-luokkaan toiminnallisuus, joka käsittelee juuripolkuun tulevia pyyntöjä ja käyttää pyynnössä tulevia parametreja tarinan täydentämiseen. Voit olettaa, että pyynnön mukana tulevien parametrien nimet ovat <code>title</code> ja <code>person</code>.</p>
		  
		  <p>Lisää pyynnön mukana tulevien parametrien arvot Thymeleafille annettavaan HashMappiin. Otsikon avaimen tulee olla <code>"title"</code> ja henkilön avaimen tulee olla <code>"person"</code>. Palautettava sivu on <code>index.html</code>.</p>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun juuripolkuun tehdyssä pyynnössä on annettuna otsikoksi <code>Mökkielämää</code> ja henkilöksi <code>Leena</code>.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex6.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    <h2>Tiedon lähettäminen palvelimelle</h2>
	    
	    
            <p>HTML-sivuille voi määritellä lomakkeita (<a href="http://www.w3schools.com/html/html_forms.asp" target="_blank">form</a>), joiden avulla käyttäjä voi lähettää tietoa palvelimelle. Lomakkeen määrittely tapahtuu <code>form</code>-elementin avulla, jolle kerrotaan polku, mihin lomake lähetetään (action), sekä pyynnön tyyppi (method). Pidämme pyynnön tyypin toistaiseksi GET-tyyppisenä.</p>
	    
	    <p>Lomakkeeseen voidaan määritellä mm. tekstikenttiä (<code>&lt;input type="text"...</code>) sekä painike, jolla lomake lähetetään (<code>&lt;input type="submit"...</code>). Alla tekstikentän <code>name</code>-attribuutin arvoksi on asetettu <code>nimi</code>. Tämä tarkoittaa sitä, että kun lomakkeen tiedot lähetetään palvelimelle, tulee pyynnössä <code>nimi</code>-niminen parametri, jonka arvona on tekstikenttään kirjoitettu teksti.</p>

<pre class="sh_xml">
&lt;form th:action="@{/}" method="GET"&gt;
    &lt;input type="text" name="nimi"/&gt;
    &lt;input type="submit"/&gt;
&lt;/form&gt;</pre>

	    <aside class="info">
	      <br/>
	      <h1>Wut, th:action?</h1>

	      <p>Jos HTML-lomakkeet ovat sinulle tuttuja, saatoit huomata, että ylläolevassa lomakkeessa polku on määritelty attribuutin <code>th:action</code> avulla. Polku on lisäksi <code>@{<em>polku</em>}</code> <code>@</code>-merkin sekä aaltosulkujen sisällä -- <code>@{<em>polku</em>}</code>.</p>

	      <p>Tämän avulla varaudumme tilanteeseen, missä palvelimella voi olla useampia sovelluksia samaan aikaan. Tällöin ohjelmoimamme sovellus voi sijaita esimerkiksi polussa <code>http://osoite.com/sovellus1/</code> ja sovelluskehyksemme päättelee polun automaattisesti.</p>
	    </aside>

	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloform">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloform">
                      Hello Form
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloform" class="collapse">
		  
		  <p>Tehtäväpohjassa on toiminnallisuus, jonka avulla sivulla voi näyttää tietoa, ja jonka avulla sivulta lähetetty tieto voidaan myös käsitellä. Tiedon lähettämiseen tarvitaan sivulle kuitenkin lomake.</p>
		  
		  <p>Toteuta tehtäväpohjan kansiossa <code>src/main/resources/templates</code> olevaan <code>index.html</code>-tiedostoon lomake. Lomakkeessa tulee olla tekstikenttä, jonka nimen tulee olla <code>content</code>. Tämän lisäksi, lomakkeessa tulee olla myös nappi, jolla lomakkeen voi lähettää. Lomakkeen tiedot tulee lähettää juuriosoitteeseen GET-tyyppisellä pyynnöllä.</p>
		  
		  <p>Kun sovellus toimii oikein, voit vaihtaa sivulla näkyvää otsikkoa lomakkeen avulla.</p>
		  
                </div>
              </div>
            </div>

	    <aside class="info">
	      <br/>
	      <h1>Pyynnön parametrit</h1>

	      <p>Annotaatiolle <code>RequestParam</code> voi asettaa myös attribuutteja, joiden perusteella voidaan määritellä pyynnön parametrien pakollisuutta tai oletusarvoja. Katso edellisen tehtävän kontrolleriluokasta esimerkkiä.</p>
	    </aside>
	    

	    <h2>Listojen käsittely</h2>


	    <p>Thymeleafille annettavalle Model-oliolle voi asettaa tekstin lisäksi myös arvokokoelmia. Alla luomme "pääohjelmassa" listan, joka asetetaan Thymeleafin käsiteltäväksi menevään Model-olioon jokaisen juuripolkuun tehtävän pyynnön yhteydessä. Jos juuripolkuun lähetetään parametri nimeltä <code>"content"</code>, lisätään se myös listaan -- alla parametri on määritelty ei-pakolliseksi annotaation <code>@RequestParam</code> attribuutilla <code>required = false</code>.</p>

<pre class="sh_java">
package thymeleafdata;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class ListaController {
    private List&lt;String&gt; lista;

    public ListaController() {
        this.lista = new ArrayList&lt;&gt;();
        this.lista.add("Hello world!");
    }

    @RequestMapping(value = "/")
    public String home(Model model, 
            @RequestParam(required = false) String content) {
        if(content != null && !content.trim().isEmpty()) {
            this.lista.add(content);
        }

        model.addAttribute("list", lista);
        return "index";
    }
}
</pre>

	    <p>Listan läpikäynti Thymeleafissa tapahtuu attribuutin <code>th:each</code> avulla. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on seuraavanlainen.</p>

<pre class="sh_xml">
&lt;pre&gt;
    &lt;p th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/p&gt;
&lt;/pre&gt;</pre>

            <p>Yllä käytämme attribuuttia nimeltä <code>lista</code> ja tulostamme yksitellen sen sisältämät alkiot. Attribuutin <code>th:each</code> voi asettaa käytännössä mille tahansa toistettavalle elementille. Esimerkiksi HTML-listan voisi tehdä seuraavalla tavalla.</p>

            <pre class="sh_xml">
&lt;ul&gt;
    &lt;li th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre>


            <p><em>Huom! Eräs klassinen virhe on määritellä iteroitava joukko merkkijonona <code>th:each="alkio : lista"</code>. Tämä ei luonnollisesti toimi.</em></p>

	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellolist">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellolist">
                      Hello List
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellolist" class="collapse">
		  
		  <p>Tehtäväpohjassa on palvelinpuolen toiminnallisuus, jossa käsitellään juuripolkuun tuleva pyyntö, sekä lisätään lista Thymeleafille sivun käsittelyyn. Tehtäväpohjaan liittyvä HTML-sivu ei kuitenkaan sisällä juurikaan toiminnallisuutta.</p>
		  
		  <p>Lisää HTML-sivulle (1) listalla olevien arvojen tulostaminen <code>th:each</code>-komennon avulla ja (2) lomake, jonka avulla palvelimelle voidaan lähettää uusia arvoja.</p>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun sivulle on lisätty muutama rivi lomakkeen avulla. Viimeisimpänä on juuri lisätty teksti "Hello?".</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex8.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    

	    <div class="tehtavat">
	      <div class="tehtava" id="t-notebook">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-notebook">
                      Notebook
                    </a>
                  </h1>
                </header>
		
                <div id="t-notebook" class="collapse">
		  
		  <p>Toteuta tehtäväpohjan pakkauksessa <code>wad.notebook</code> olevaan <code>NotebookController</code>-luokkaan muistio-ohjelma, jolle voi lisätä muistiinpanoja. Tee ohjelmastasi sellainen, että jos muistiinpanoja on yli 10, se muistaa ja näyttää niistä vain viimeisimmät 10.</p>
		  
		  <p>Alla on esimerkki muistiosta, kun siihen on lisätty 3 viestiä.</p>
		  
		  <p><img class="browser-img" src="img/mooc/ex9.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    
	    
	    
	    <h2>Pyynnön uudelleenohjaus ja POST</h2>
	    
	    <p>Olemme tähän mennessä toteuttaneet palvelinohjelmistoihimme vain kyvyn käsitellä GET-tyyppisiä pyyntöjä. GET-tyyppisiä pyyntöjä käytetään ensisijaisesti tiedon hakemiseen, eikä niitä oikeastaan pitäisi käyttää laisinkaan tiedon muuttamiseen. Toinen tapa lähettää tietoa palvelimelle on <code>POST</code>-tyyppiset pyynnöt, joita käytettäessä pyynnön parametrit kulkevat pyynnön <em>rungossa</em> -- palaamme pyynnön erilaisiin muotoihin myöhemmin kurssilla.</p>
	    
            <p>Oikeastaan kaikki pyynnöt, joissa lähetetään tietoa palvelimelle, ovat ongelmallisia jos pyynnön vastauksena palautetaan näytettävä sivu. Tällöin käyttäjä voi sivun uudelleenlatauksen (esim. painamalla F5) yhteydessä lähettää aiemmin lähettämänsä datan vahingossa uudelleen. Kokeile tätä jossain aiemmassa tehtävässä kun olet lähettänyt lomakkeella tietoa!</p>
	    
            <p>On tyylikkäämpää toteuttaa lomakkeen dataa vastaanottava toiminnallisuus siten, että lähetetyn tiedon käsittelyn jälkeen käyttäjälle palautetaan vastauksena uudelleenohjauspyyntö. Tämän jälkeen käyttäjän selain tekee uuden pyynnön uudelleenohjauspyynnön mukana annettuun osoitteeseen. Tätä toteutustapaa kutsutaan <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank">Post/Redirect/Get</a>-suunnittelumalliksi ja sillä mm. estetään lomakkeiden uudelleenlähetys, jonka lisäksi vähennetään toiminnallisuuden toisteisuutta.</p>

	    <h3>POST-pyynnön kuuntelu ja uudelleenohjaus</h3>
	    
	    <p>Alla on toteutettu POST-tyyppistä pyyntöä kuunteleva polku sekä siihen liittyvä toiminnallisuus. Pyynnön tyyppi määritellään annotaation @RequestMapping attribuutiksi (method-attribuutti). Tällöin kuunneltava polku tulee määritellä myös tarkemmin (value-attribuutti). Palauttamalla pyyntöä käsittelevästä metodista merkkijono <code>redirect:/</code> kerrotaan, että pyynnölle tulee lähettää vastauksena uudelleenohjauspyyntö polkuun <code>"/"</code>. Kun selain vastaanottaa uudelleenohjauspyynnön, tekee se GET-tyyppisen pyynnön uudelleenohjauspyynnössä annettuun osoitteeseen.</p>

<pre class="sh_java">
package uudelleenohjaus;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class ListaController {
    private List&lt;String&gt; lista;

    public ListaController() {
        this.lista = new ArrayList&lt;&gt;();
        this.lista.add("Hello world!");
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", lista);
        return "index";
    }

    @RequestMapping(value = "/", method = RequestMethod.POST)
    public String post(@RequestParam String content) {
        if(!content.trim().isEmpty()) {
            this.lista.add(content);
        }

        return "redirect:/";
    }
}
</pre>
	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellopostredirectget">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopostredirectget">
                      Hello POST/Redirect/GET
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellopostredirectget" class="collapse">
		  
		  <p>Tehtäväpohjassa on sekä muistilappujen listaamistoiminnallisuus, että lomake, jonka avulla voidaan lähettää POST-tyyppisiä pyyntöjä palvelimelle. Toteuta sovellukseen toiminnallisuus, missä palvelin kuuntelee POST-tyyppisiä pyyntöjä, lisää pyynnön yhteydessä tulevan tiedon sovelluksessa olevaan listaan ja uudelleenohjaa käyttäjän tekemään GET-tyyppisen pyynnön juuriosoitteeseen.</p>
		  
                </div>
              </div>
            </div>
	    

	    <h2>Olioita kaikkialla!</h2>
	    
	    <p>Thymeleafille annettavaan Modeliin voi hyvin lisätä myös olioita. Oletetaan, että käytössämme on henkilöä kuvaava luokka.</p>
	    
<pre class="sh_java">
public class Henkilo {
    private String nimi;

    public Henkilo(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}
</pre>

	    <p>Henkilo-olion lisääminen on suoraviivaista:</p>

<pre class="sh_java">
    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("henkilo", new Henkilo("Le Pigeon"));
        return "index";
    }
</pre>

	    <p>Kun sivua luodaan, henkilöön päästään käsiksi modeliin asetetun avaimen perusteella. Edellä luotu "Le Pigeon"-henkilö on tallessa avaimella "henkilo". Kuten aiemminkin, avaimella pääsee olioon käsiksi.</p>
	    
	    
<pre class="sh_xml">
&lt;h2 th:text="${henkilo}"&gt;Henkilön nimi&lt;/h2&gt;</pre>

	    <p>Ylläolevaa henkilön tulostusta kokeillessamme saamme näkyville (esim.) merkkijonon <code>Henkilo@29453f44</code> -- ei ihan mitä toivoimme. Käytännössä Thymeleaf kutsuu edellisessä tapauksessa olioon liittyvää <code>toString</code>-metodia, jota emme ole määritelleet. Pääsemme oliomuuttujiin käsiksi olemassaolevien <code>get<em>Muuttuja</em></code>-metodien kautta. Jos haluamme tulostaa Henkilo-olioon liittyvän nimen, kutsumme metodia <code>getNimi</code>. Thymeleafin käyttämässä notaatiossa kutsu muuntuu muotoon <code>henkilo.nimi</code>. Saamme siis halutun tulostuksen seuraavalla tavalla:</p>

<pre class="sh_xml">
&lt;h2 th:text="${henkilo.nimi}"&gt;Henkilön nimi&lt;/h2&gt;</pre>

	    <p></p>

	    <h3>Olioita listalla</h3>
	    
	    <p>Listan läpikäynti Thymeleafissa tapahtuu attribuutin <code>th:each</code> avulla. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on jo tullut aiemmin tutuksi.</p>
	    
<pre class="sh_xml">
&lt;pre&gt;
    &lt;p th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/p&gt;
&lt;/pre&gt;</pre>

            <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi aivan samalla tavalla kuin muiden olioiden ominaisuuksiin. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi henkilöä, lista lisätään pyyntöön ja lopulta luodaan näkymä Thymeleafin avulla.</p>

<pre class="sh_java">
package henkilot;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HenkiloController {
    private List&lt;Henkilo&gt; henkilot;

    public ListaController() {
        this.henkilot = new ArrayList&lt;&gt;();
        this.henkilot.add(new Henkilo("James Gosling"));
        this.henkilot.add(new Henkilo("Martin Odersky"));
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", henkilot);
        return "index";
    }
}
</pre>

                <pre class="sh_xml">
&lt;p&gt;Ja huomenna puheet pitävät:&lt;/p&gt;
&lt;ol&gt;
    &lt;li th:each="henkilo : ${list}"&gt;
        &lt;span th:text="${henkilo.nimi}"&gt;Esimerkkihenkilö&lt;/span&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</pre>

            <p>Käyttäjälle lähetettävä sivu näyttää palvelimella tapahtuneen prosessoinnin jälkeen seuraavalta.</p>

<pre class="sh_xml">
&lt;p&gt;Ja huomenna puheet pitävät:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;span&gt;James Gosling&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;Martin Odersky&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</pre>

	    <p></p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloobjects">

		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloobjects">
                      Hello Objects
                    </a>
                      </h1>
                </header>

                <div id="t-helloobjects" class="collapse">

		  <p>Tehtäväpohjassa on sovellus, jossa käsitellään <code>Item</code>-tyyppisiä olioita. Tehtävänäsi on lisätä sovellukseen lisätoiminnallisuutta:</p>
		  
		  <ul>
		    <li>Kun käyttäjä avaa selaimella sovelluksen juuripolun, tulee hänen lomakkeen lisäksi nähdä lista esineistä. Jokaisesta esineestä tulee tulla ilmi sen nimi (name) ja tyyppi (type).</li>
		    <li>Kun käyttäjä lähettää lomakkeella uuden esineen palvelimelle, tulee palvelimen säilöä esine listalle seuraavaa näyttämistä varten. Huomaa, että lomake lähettää tiedot POST-pyynnöllä sovelluksen juureen. Kun esine on säilötty, uudelleenohjaa käyttäjän pyyntö siten, että käyttäjän selain tekee GET-tyyppisen pyynnön sovelluksen juuripolkuun.</li>
		  </ul>
		  
		  <p>Allaolevassa esimerkissä sovellukseen on lisätty olemassaolevan taikurin hatun lisäksi <a href="https://en.wikipedia.org/wiki/Party_hat" target="_blank">Party hat</a>, eli bilehattu.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex11.png"/></p>

                </div>
              </div>
            </div>


	    <h2>Polkumuuttujat</h2>

	    <p>Polkuja käytetään erilaisten resurssien tunnistamiseen ja yksilöintiin. Usein kuitenkin vastaan tulee tilanne, missä luodut resurssit ovat uniikkeja, emmekä niiden tietoja ennen sovelluksen käynnistymistä. Jos haluaisimme näyttää tietyn resurssin tiedot, voisimme lisätä pyyntöön parametrin -- esim <code>esineet?tunnus=3</code>, minkä arvo olisi haetun resurssin tunnus.</p>

	    <p>Toinen vaihtoehto on ajatella polkua haettavan resurssin tunnistajana. Annotaatiolle <code>@RequestMapping</code> määriteltävään polkuun voidaan määritellä polkumuuttuja aaltosulkujen avulla. Esimerkiksi polku <code>"/{arvo}"</code> ottaisi vastaan minkä tahansa juuripolun alle tulevan kyselyn ja tallentaisi arvon myöhempää käyttöä varten. Tällöin jos käyttäjä tekee pyynnön esimerkiksi osoitteeseen <code>http://localhost:8080/kirja</code>, tallentuu arvo "kirja" myöhempää käyttöä varten. Polkumuuttujiin pääsee käsiksi pyyntöä käsittelevälle metodille määriteltävän annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html" target="_blank">@PathVariable</a> avulla.</p>

	    <p>Yksittäisen henkilön näyttäminen onnistuisi esimerkiksi seuravavasti:</p>

<pre class="sh_java">
package henkilot;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HenkiloController {
    private List&lt;Henkilo&gt; henkilot;

    public ListaController() {
        this.henkilot = new ArrayList&lt;&gt;();
        this.henkilot.add(new Henkilo("James Gosling"));
        this.henkilot.add(new Henkilo("Martin Odersky"));
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", henkilot);
        return "index";
    }

    @RequestMapping("/{id}")
    public String getOne(Model model, @PathVariable Integer id) {
        if(id &lt; 0 || id &gt;= this.henkilot.size()) {
            return home(model);
        }

        model.addAttribute("henkilo", henkilot.get(id));
        return "henkilo";
    }
}
</pre>

	    <p></p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellopathvariables">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopathvariables">
                      Hello Path Variables
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellopathvariables" class="collapse">

		  <p>Tehtäväpohjassa on sovellus, jossa käsitellään taas edellisestä tehtävästä tuttuja <code>Item</code>-tyyppisiä olioita. Tällä kertaa esineet kuitenkin kuvastavat hattuja. Kun sovelluksen juureen tehdään pyyntö, käyttäjälle näytetään oletushattu ("default"). Lisää sovellukseen toiminnallisuus, minkä avulla tiettyyn polkuun tehtävä kysely palauttaa sivun, jossa näkyy tietyn hatun tiedot -- huomaa, että voit asettaa polkumuuttujan tyypiksi myös Stringin.</p>
		  
		  <p>Sovelluksen juuripolkuun tehtävä pyyntö näyttää seuraavanlaisen sivun:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex12-default.png"/></p>

		  <p>Muihin osoitteisiin tehtävät pyynnöt taas palauttavat tehtäväpohjassa olevasta <code>items</code>-hajautustaulusta polkuun sopivan hatun. Esimerkiksi pyyntö polkuun <code>/ascot</code> näyttää seuraavanlaisen sivun:</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex12-ascot.png"/></p>

                </div>
              </div>
            </div>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloindividualpages">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloindividualpages">
                      Hello Individual Pages
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloindividualpages" class="collapse">
		  
		  <p>Edellisessä tehtävässä käytössämme oli vain yksi sivu. Olisi kuitenkin hienoa, jos jokaiselle hatulle olisi oma sivu -- ainakin sovelluksen käyttäjän näkökulmasta.</p>
		  
		  <p>Tehtäväpohjassa on valmiina sovellus, joka listaa olemassaolevat hatut ja näyttää ne käyttäjälle. Jokaisen hatun yhteydessä on linkki, jota klikkaamalla pitäisi päästä hatun omalle sivulle.</p>
		  
		  <p>Toteuta sekä html-sivu (<code>single.html</code>), että sopiva metodi, joka ohjaa pyynnön sivulle.</p>
		  

		  <p>Pyyntö sovelluksen juureen luo seuraavanlaisen sivun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex13-list.png"/></p>
		  
		  <p>Jos sivulta klikkaa hattua, pääsee tietyn hatun tiedot sisältävälle sivulle. Alla olevassa esimerkissä on klikattu taikurin hattuun liittyvää linkkiä.</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex13-single.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-todoapplication">

		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-todoapplication">
                      Todo Application
                    </a>
                  </h1>
                </header>
		
                <div id="t-todoapplication" class="collapse">
		  
		  <p>Tässä tehtävässä tulee rakentaa tehtävien hallintaan tarkoitettu sovellus. Sovelluksen käyttämät sivut ovat valmiina näkyvissä, itse sovelluksen pääset toteuttamaan itse.</p>
		  
		  <p>Sovelluksen tulee sisältää seuraavat toiminnallisuudet:</p>
		  
		  <ul>
		    <li>Kaikkien tehtävien listaaminen. Kun käyttäjä tekee pyynnön sovelluksen juuripolkuun, tulee hänelle näyttää sivu, missä tehtävät on listattuna. Sivulla on myös lomake tehtävien lisäämiseen. </li>
		    <li>Yksittäisen tehtävän lisääminen. Kun käyttäjä täyttää lomakkeen sivulla ja lähettää tiedot palvelimelle, tulee sovelluksen lisätä tehtävä näytettävään listaan.</li>
		    <li>Yksittäisen tehtävän poistaminen. Kun käyttäjä painaa tehtävään liittyvää <code>Done!</code>-nappia, tulee tehtävä poistaa listalta. Toteuta tämä niin, että metodin tyyppi on <code>DELETE</code>:
<pre class="sh_java">
@RequestMapping(value = "/{item}", method = RequestMethod.DELETE)</pre></li>
		    <li>Yksittäisen tehtävän näyttäminen. Kun käyttäjä klikkaa tehtävään liittyvää linkkiä, tulee käyttäjälle näyttää tehtäväsivu. Huom! Tehtävään liittyvien tarkistusten määrä tulee kasvaa aina yhdellä kun sivulla vieraillaan.</li>
		  </ul>
		  
		  <p>Alla kuva tehtävien listauksesta:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-list.png"/></p>
		  
		  <p>Kun tehtävää klikkaa, näytetään erillinen tehtäväsivu:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-item-1.png"/></p>
		  
		  <p>Kun sivu avataan toisen kerran, kasvaa tehtävien tarkistukseen liittyvä laskuri:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-item-2.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    

	    <h2>Tiedon tallentaminen</h2>

	    <p>Sovelluksemme -- vaikka huikeita ovatkin -- ovat melko alkeellisia, sillä sovelluksissa käsiteltävää tietoa ei tallenneta mihinkään. Esimerkiksi lomakkeen avulla sovellukselle lähetettävä data katoaa kun sovellus käynnistetään uudestaan. Tämä ei ole kivaa.</p>

	    <p>Tietokannat ovat palvelinohjelmistosta erillisiä sovelluksia, joiden ensisijainen tehtävä on varmistaa, että käytettävä tieto ei katoa. Otetaan ensiaskeleet tietokannan käyttöön web-palvelinohjelmistoissa -- tutustumme tietokantoihin tarkemmin myöhemmin kurssilla. Käytämme tietokantatoiminnallisuuden toteuttamisessa <a href="http://projects.spring.io/spring-data-jpa/" target="_blank">Spring Data JPA</a>-komponenttia, johon löytyy myös aloituspaketti käyttämästämme Spring Bootista.</p>

	    <aside class="info">

	      <br/>

	      <h1>Spring Data JPA:n käyttöönotto</h1>
		  
	      <p>Saadaksemme Spring Data JPA:n käyttöömme, tulee meidän lisätä se <code>pom.xml</code>-tiedostoon. Spring Bootin kautta löytyy näppärä paketti <code>spring-boot-starter-data-jpa</code>, joka vähentää yksittäisten riippuvuuksien lisäämistä. Tämän lisäksi tarvitsemme testikäyttöön sopivan tietokannan -- valitaan <a href="http://www.h2database.com/" target="_blank">H2 Database</a>, jonka voi ladata muistiin sovelluksen käynnistyessä.</p>

	      <p>Lisätään projektiin seuraavat riippuvuudet:</p>

	      <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

	      <p>Kun projektin riippuvuudet noudetaan Mavenin avulla, on tietokanta valmis testikäyttöön.</p>

	    </aside>


	    <h3>Tietokantaan tallennettavat oliot eli entiteetit</h3>

            <p>Käytämme ORM-kirjastoa (object relational mapping), jonka tehtävänä on muuntaa oliot tietokantaan tallennettavaan muotoon. Karkeasti ajatellen luokka vastaa tietokantataulua ja oliomuuttujat vastaavat tietokannan sarakkeita. Jokainen taulun rivi vastaa yhtä luokasta tehtyä oliota.</p>

	    <p>Luokat, joista tehdyt oliot voidaan tallentaa tietokantaan, tulee annotoida <code>@Entity</code>-annotaatiolla. Tämän lisäksi luokille tulee määritellä tunnuskenttä, jonka avulla niihin liittyvät oliot voidaan yksilöidä. Voimme käyttää tunnuskentän luomiseen valmista <code>AbstractPersistable</code>-yliluokkaa, jota perittäessä kerromme uniikin tunnuksen tyypin. Esimerkiksi <code>Henkilo</code>-luokasta voidaan tehdä tietokantaan tallennettava seuraavilla muutoksilla.</p>

                <pre class="sh_java">
package wad.domain;

import javax.persistence.Entity;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}</pre>

            <p>Kun käytössämme on tietokantaan tallennettava luokka, voimme luoda tietokannan käsittelyyn käytettävän <em>rajapinnan</em>. Kutsutaan tätä rajapintaoliota nimellä <code>HenkiloRepository</code>.</p>

                <pre class="sh_java">
// pakkaus

import wad.domain.Henkilo;
import org.springframework.data.jpa.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {

}</pre>

            <p>Rajapinta perii Spring Data-projektin <code>JpaRepository</code>-rajapinnan; samalla kerromme, että tallennettava olio on tyyppiä <code>Henkilo</code> ja että tallennettavan olion tunnus on <code>Long</code>-tyyppiä. Tämä tyyppi on sama kuin aiemmin <code>AbstractPersistable</code>-luokan perinnässä parametriksi asetettu tyyppi. Spring osaa käynnistyessään etsiä mm. JpaRepository-rajapintaluokan periviä luokkia. Jos niitä löytyy, se luo niiden pohjalta tietokannan käsittelyyn sopivan olion sekä asettaa olion ohjelmoijan haluamiin muuttujiin.</p>

	    <p>Nämä muuttujat tulee määritellä <code>@Autowired</code>-annotaatiolla -- jokaiselle muuttujalle tulee oma annotaatio -- palaamme myöhemmin kurssilla tarkemmin tähän ns. olioiden automaattiseen asettamiseen.</p>

            <p>Kun olemme luoneet rajapinnan <code>HenkiloRepository</code>, voimme lisätä sen käyttöömme esimerkiksi kontrolleriluokkaan. Tämä tapahtuu seuraavasti.</p>

                <pre class="sh_java">
// ...

@Controller
public class HenkiloController {

    @Autowired
    private HenkiloRepository henkiloRepository;

    // ...
}</pre>

            <p>Nyt tietokantaan pääsee käsiksi <code>HenkiloRepository</code>-olion kautta. Osoitteessa <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html</a> on JpaRepository-rajapinnan API-kuvaus, mistä löytyy rajapinnan tarjoamien metodien kuvauksia. Voimme esimerkiksi toteuttaa tietokannassa olevien olioiden listauksen sekä yksittäisen olion haun seuraavasti:</p>

            <pre class="sh_java">
// ...

@Controller
public class HenkiloController {

    @Autowired
    private HenkiloRepository henkiloRepository;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("list", henkiloRepository.findAll());
        return "henkilot"; // erillinen henkilot.html
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable Long id) {
        model.addAttribute("henkilo", henkiloRepository.findOne(id));
        return "henkilo"; // erillinen henkilo.html
    }
}</pre>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellodatabase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodatabase">
                      Hello Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodatabase" class="collapse">
		  
		  <p>Tässä tehtävässä on valmiiksi toteutettuna tietokantatoiminnallisuus sekä esineiden noutaminen tietokannasta. Lisää sovellukseen toiminnallisuus, jonka avulla esineiden tallentaminen tietokantaan onnistuu valmiiksi määritellyllä lomakkeella.</p>
		  
		  <p>Alla esimerkki sovelluksesta kun tietokantaan on lisätty muutama rivi:</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex15.png"/></p>
		  
                </div>
              </div>
            </div>		
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-tododatabase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-tododatabase">
                      Todo Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-tododatabase" class="collapse">
		  
		  <p>Luo tässä TodoApplication-tehtävässä nähty tehtävien hallintaan tarkoitettu toiminnallisuus mutta siten, että tehtävät tallennetaan tietokantaan. Tässä tehtävässä entiteettiluokan nimen tulee olla <code>Item</code> ja avaimen tyypin tulee olla <code>Long</code>: <pre class="sh_java">
@Entity
public class Item extends AbstractPersistable&lt;Long&gt; {
...</pre></p>
		  <p>Noudata lisäksi HTML-sivujen rakennetta ja toiminnallisuutta.</p>
		  
                </div>
              </div>
            </div>
	    

	  </section>
	  <!-- END OSA1 -->

          <!-- BEGIN OSA2 -->
          <section class="weeklimit" data-week-id="2">
	    
            <header>
              <h1 id="osa2">Osa 2</h1>
            </header>

	    <p>Aloitamme toisen osan edellisen viikon kertauksella, jonka jälkeen syvennymme internetin perusosiin. Tätä seuraa tarkempi tutustuminen tietokantojen käyttöön sekä web-sovellusten rakenteeseen.</p>

	    <aside class="info">
	      <br/>
	      <h1>Muutosten automaattinen päivittäminen sivulle</h1>

	      <p>Muutamat ovat kysyneet miten ohjelmakoodissa tehdyt muutokset saa automaattisesti päivittymään selaimeen. Javalla toimivat ohjelmat käynnistetään tavukoodiksi, ja nämä tavukoodit suoritetaan ohjelmaa käynnistettäessä, joten automaattinen siirto ei ole täysin suoraviivaista.</p>

	      <p>Tähän löytyy kuitenkin asian osittain ratkaiseva projekti, <code>spring-boot-devtools</code>, joka tarjoaa välineitä ohjelmistokehitysprosessin nopeuttamiseksi.</p>

	      <p>Projektin lisääminen Maveniin tapahtuu seuraavan riippuvuuden avulla:</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</pre>

	      <p>Kun ylläoleva riippuvuus on lisätty projektiin, käynnistetään ohjelman käynnistyksen yhteydessä myös <a href="http://livereload.com/" target="_blank">LiveReload</a>-palvelin. Kun selaimeen asentaa LiveReload-liitännäisen (Chromelle osoitteesta <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank">https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei</a>) ja kytkee liitännäisen päälle, LiveReload-liitännäinen ja palvelin keskustelevat toistensa kanssa ja päivittävät näkymää tarvittaessa.</p>

	      <p>Devtools-projektin lisääminen sovellukseen johtaa myös siihen, että sovellus ladataan uudestaan aina kun sen lähdekoodi muuttuu. Tämän lisäksi osoitteessa <code>http://localhost:8080/h2-console</code> on tietokantakonsoli, jonka avulla voi käydä tarkastelemassa tietokannan tilaa -- tietokannan JDBC URL on oletuksena <code>jdbc:h2:mem:testdb</code>. Huom! Tämä toimii vain, jos käytössä on H2-tietokantamoottori.</p>

	    </aside>
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa1-kertaus-ex" data-count="17">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa1-kertaus">
                      Osa 1, kertaus: Jobs
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa1-kertaus" class="collapse">
		  
		  <p>Jokainen uusi osio alkaa edellisen viikon teemoja sisältävällä kertaustehtävällä. Uusi osio tulee näkyville kun teet vähintään 50% edellisen osion tehtävistä. </p>
		  
		  <p>Ensimmäisessä kertaustehtävässä tehtävänäsi on toteuttaa sovellus työlistan hallintaan. Työlistalla näkyy ne työt, jotka eivät ole vielä tehtynä. Työn voi merkitä tehdyksi "Done!" -nappia painamalla.</p>
		  
		  <img src="img/2016-mooc/ex17-jobs.png" class="browser-img"/>
		  
		  <p>Kun työ merkitään tehdyksi, siirretään se erilliseen aiempia töitä listaavaan tauluun.</p>
		  
		  <img src="img/2016-mooc/ex17-jobs-done.png" class="browser-img"/>
		  
		  <p>Tehtäväpohjassa on annettu valmiina käyttöliittymän HTML-koodi, mistä voi tarkastella myös haluttua toiminnallisuutta.</p>
		  
                </div>
              </div>
	    </div>
	    
	    
            <h1 data-count="2">Internetin perusosat</h1>

	    <p>Internetin peruskomponentit ovat (1) palveluiden, palvelinohjelmistojen ja resurssien yksilöintiin käytetyt merkkijonomuotoiset osoitteet (<em>URI, Uniform Resource Identifier</em>) sekä näiden merkkijonomuotoisten verkko-osoitteiksi käytettävä palvelu (<em>DNS, Domain Name Services</em>), (2) selainten ja palvelinten välisessä viestittelyssä käytettävä viestimuoto (protokolla) (<em>HTTP, HyperText Transfer Protocol</em>), sekä (3) yhteinen dokumenttien esityskieli (<em>HTML, HyperText Markup Language</em>).</p>
		
            <h2>URI ja DNS: Osoitteet ja niiden tulkinta</h2>

            <p>Verkossa sijaitseva resurssi tunnistetaan osoitteen perusteella. Osoite (URI eli Uniform Resource Identifier, myös terminä käyttöön jäänyt URL <em>Uniform Resource Locator</em>) koostuu resurssin nimestä ja sijainnista, joiden perusteella haluttu resurssi ja palvelin (sijainti) voidaan löytää verkossa olevien koneiden massasta.</p>

            <p>Käytännössä URI-osoitteet näyttävät seuraavilta:</p>
	    
<pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti[.paate]][?parametri=arvo&amp;toinen=arvo][#ankkuri]
</pre>

            <p>
              <ul>
                <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi HTTP, FTP tai SSH.</li>
                <li>isäntäkone: kone tai palvelin johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus (esim www.cs.helsinki.fi).</li>
                <li>portti: portti isäntäkoneella johon yhteys luodaan. Selaimet olettavat, että palvelinohjelmisto kuuntelee pyyntöjä portissa 80.  Web-sovellluksilla HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen. Portti käytännössä määrittelee prosessin eli sovelluksen, johon yritetään ottaa yhteyttä.</li>
                <li>polku: periaatteessa polku resurssiin palvelimella. Käytännössä (nykyään) myös palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
                <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
		<li>.paate: resurssiin liittyvä tiedostotyyppi, ei pakollinen. Esimerkiksi .html</li>
                <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
                <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
              </ul>
            </p>
	    
            <aside class="pohdi">
              <h1>Osoitteen osat</h1>
	      
              <p>Tutki osoitetta <a href="https://fi.wikipedia.org/wiki/OSI-malli" target="_blank">https://fi.wikipedia.org/wiki/OSI-malli</a>. Mitkä tai mikä ovat/on osoitteen:</p>
	      
              <ul>
                <li>protokolla</li>
                <li>isäntäkone</li>
                <li>portti</li>
                <li>polku</li>
                <li>kohdedokumentti</li>
                <li>kyselyparametrit</li>
                <li>ankkuri</li>
              </ul>
	      
              <p>Mitkä näistä puuttuvat?</p>
            </aside>


            <p>Kun käyttäjä kirjoittaa web-selaimen osoitekenttään osoitteen ja painaa enteriä, web-selain tekee kyselyn annettuun osoitteeseen. Koska tekstimuotoiset osoitteet ovat käytännössä vain ihmisiä varten, kääntää selain ensiksi halutun osoitteen IP-osoitteeksi. Jos IP-osoite on jo tietokoneen tiedossa esimerkiksi aiemmin osoitteeseen tehdyn kyselyjen takia, selain voi ottaa yhteyden IP-osoitteeseen. Jos IP-osoite taas ei ole tiedossa, tekee selain ensin kyselyn <a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>-palvelimelle (<em>Domain Name System</em>), jonka tehtävänä on muuntaa tekstuaaliset osoitteet IP-osoitteiksi (esim. Tietojenkäsittelytieteen laitoksen kotisivu <code>http://www.cs.helsinki.fi</code> on IP-osoitteessa <code>128.214.166.78</code>).</p>

            <p>IP-osoitteet yksilöivät tietokoneet ja mahdollistavat koneiden löytämisen verkon yli. Käytännössä yhteys IP-osoitteen määrittelemään koneeseen avataan <a href="https://fi.wikipedia.org/wiki/OSI-malli" target="_blank">sovelluskerroksen</a> <a href="https://fi.wikipedia.org/wiki/HTTP" target="_blank">HTTP-protokollan</a> avulla kuljetuskerroksen <a href="https://fi.wikipedia.org/wiki/TCP" target="_blank">TCP-protokollan</a> yli. TCP-protokollan tehtävänä on varmistaa, että viestit pääsevät perille. Selain ei ota "suoraan" yhteyttä palvelinohjelmistoon, vaan välissä on tyypillisesti useita viestinvälityspalvelimia, jotka auttavat viestin perillepääsemisessä -- lisää tietoa konkreettisesta tietoliikenteestä löytyy kurssilla <a href="http://www.cs.helsinki.fi/courses/582202" target="_blank">Tietoliikenteen perusteet</a>.</p>


            <h2>HTTP: Selainten ja palvelinten välinen kommunikaatioprotokolla</h2>
	    
            <p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla, jota web-palvelimet ja selaimet käyttävät kommunikointiin. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Tämä tarkoittaa sitä, että jokainen pyyntö käsitellään erillisenä kokonaisuutena, eikä saman käyttäjän kahta peräkkäistä pyyntöä yhdistetä automaattisesti toisiinsa.</p>

	    <p>Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen. Tällä hetkellä eniten käytetty HTTP-protokollan versio on 1.1, joka on määritelty <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">RFC 2616</a>-spesifikaatiossa.</p>

            <h3>Asiakas-palvelin malli</h3>

            <p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että selain ja palvelin sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelin tarjoaa yhden tai useamman palvelun, joita käyttäjä käyttää selaimen kautta.</p>

            <p>Käytännössä selain näyttää käyttöliittymän ohjelmiston käyttäjälle. Selaimen käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon selain pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot ja verkossa liikkuvan tiedon määrä pidetään vähäisenä.</p>
	    
            <p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: selainta käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelimen sijaitessa tietyssä paikassa.</p>

		
            <aside class="pohdi">
              <h1>Client&#8211;server model</h1>
		  
              <p>Mene osoitteeseen <a href="https://en.wikipedia.org" target="_blank">https://en.wikipedia.org</a>. Kirjoita sivuston oikeassa ylälaidassa olevaan kenttään "client server model" ja paina Enter-näppäintä. Mitkä seuraavista askeleista tapahtuivat selaimessa, mitkä palvelimella, mitkä muualla?</p>
		  
              <ol>
                <li>Näppäimistön avulla kirjoittamasi osoitetekstin näyttäminen.</li>
                <li>Osoitetta https://en.wikipedia.org vastaavan IP-osoitteen etsiminen.</li>
                <li>Sivun https://en.wikipedia.org näyttäminen.</li>
                <li>https://en.wikipedia.org/wiki/Client&#8211;server_model -sivun näyttäminen</li>
              </ol>
		  
	      <p>Tekstikentästä lähetetään viesti osoitteeseen <a href="https://en.wikipedia.org/w/index.php?search=client+server+model&title=Special%3ASearch&go=Go" target="_blank">https://en.wikipedia.org/w/index.php?search=client+server+model&title=Special%3ASearch&go=Go</a>, mutta päädyt sivulle <a href="https://en.wikipedia.org/wiki/Client&#8211;server_model" target="_blank">https://en.wikipedia.org/wiki/Client&#8211;server_model</a>. Miksi näin tapahtuu?</p>
            </aside>
		
            <p>Haasteena perinteisessä asiakas-palvelin mallissa on se, että palvelin sijaitsee yleensä tietyssä keskitetyssä sijainnissa. Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muun muassa palvelimen fyysinen kapasiteetti (muisti, prosessorin teho, ..), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi. Esimerkiksi pyynnöt, jotka johtavat tiedon tallentamiseen, vievät tyypillisesti enemmän resursseja kuin pyynnöt, jotka tarvitsevat vain staattista sisältöä.</p>

		
	    
            <div class="tehtavat">
		  
              <div class="tehtava" id="t-knockknock-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-knockknock">
                      Knock Knock
                    </a>
                  </h1>
                </header>
		
                <div id="t-knockknock" class="collapse">
		  
		  <p>Lähes kaikki sovellusten verkkoliikenne sovellustason protokollasta riippumatta käyttää TCP-yhteyksiä ja -portteja kommunikointiin. TCP-yhteyksiä käytetään Javassa <a href="https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html" target="_blank">Socket</a>- ja <a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html" target="_blank">ServerSocket</a>-luokkien avulla. Lisää aiheesta löytyy <a href="https://docs.oracle.com/javase/tutorial/networking/sockets/" target="_blank">tästä oppaasta</a>.</p>
		  
		  <p>Eräs suosittu viestiprotokolla (eli säännöstö, joka kertoo kuinka kommunikoinnin tulee kulkea) alkaa sanoilla <code>Knock knock!</code>. Toinen osapuoli vastaa tähän <code>Who's there?</code>. Ensimmäinen osapuoli vastaa jotain, esim. <code>Moustache</code>, jonka jälkeen toisen osapuolen tulee vastata <code>Moustache who?</code>. Tähän ensimmäinen osapuoli vastaa viestillä joka päättyy "Bye.".</p>

<pre>
Server: Knock knock!
Client: Who's there?
Server: Moustache
Client: Moustache who?
Server: I Moustache you a question, but I'm shaving it for later! Bye.
</pre>

		  <p>Tehtäväpohjan mukana tulee projekti, on toteutettu valmiiksi palvelinpuolen toiminnallisuus luokassa KnockKnockServer. Palvelinohjelmisto kuuntelee pyyntöä portissa 12345.</p>
		  
		  <p>Tehtävänäsi on toteuttaa valmiiksi toteutettua palvelinkomponenttia varten asiakaspuolen toiminnallisuus, eli sovellus, joka tekee kyselyjä palvelimelle. Asiakaspuolen toiminnallisuutta varten on jo olemassa allaoleva runko, joka tulee tehtäväpohjan pakkauksessa <code>wad.knockknock.client</code> olevassa luokassa <code>KnockKnockClient</code>.</p>

		  <p>Täydennä asiakasohjelmisto annettujen askelten mukaan siten, että sitä voi käyttää kommunikointiin viestiprotokollapalvelimen kanssa.</p>

<pre class="sh_java">
// Luodaan yhteys palvelimelle
Socket socket = new Socket("localhost", port);

Scanner serverMessageScanner = new Scanner(socket.getInputStream());
PrintWriter clientMessageWriter = new PrintWriter(
        socket.getOutputStream(), true);

Scanner userInputScanner = new Scanner(System.in);

// Luetaan viestejä palvelimelta
while (serverMessageScanner.hasNextLine()) {
    // 1. lue viesti palvelimelta
    // 2. tulosta palvelimen viesti standarditulostusvirtaan näkyville

    // 3. jos palvelimen viesti loppuu merkkijonon "Bye.", poistu toistolausekkeesta

    // 4. pyydä käyttäjältä palvelimelle lähetettävää viestiä
    // 5. kirjoita lähetettävä viesti palvelimelle. Huom! Käytä println-metodia.
}
</pre>


		  <p>Kirjoita asiakasohjelmiston lähdekoodi KnockKnockClient-luokan start-metodiin. Kun olet saanut ohjelmiston valmiiksi, suorita ohjelma, jotta voit kokeilla sitä. Tehtäväpohjan mukana on ohjelman käynnistävä main-metodin sisältävä luokka valmiina. Tulostuksen pitäisi olla esimerkiksi seuraavanlainen (käyttäjän syöttämät tekstit on merkitty punaisella):</p>

<pre>
Server: Knock knock!
Type a message to be sent to the server: <font color="red">Who's there?</font>
Server: Lettuce
Type a message to be sent to the server: <font color="red">Lettuce who?</font>
Server: Lettuce in! it's cold out here! Bye.
</pre>

		  <p>Jos asiakasohjelmisto lähettää virheellisiä viestejä, reagoi palvelin siihen seuraavasti:</p>

<pre>
Server: Knock knock!
Type a message to be sent to the server: <font color="red">What?</font>
Server: You are supposed to ask: "Who's there?"
Type a message to be sent to the server: <font color="red">Who's there?</font>
Server: Lettuce
Type a message to be sent to the server: <font color="red">huh</font>
Server: You are supposed to ask: "Lettuce who?"
Type a message to be sent to the server: <font color="red">Lettuce who?</font>
Server: Lettuce in! it's cold out here! Bye.
</pre>

		  <p>Kun olet saanut asiakaspuolen toiminnallisuuden toimimaan, palauta tehtävä TMC:lle.</p>
		  
                </div>
              </div>
	    </div>
	    
	    <p>Edellisessä tehtävässä toteutettu ohjelma voisi aivan yhtä hyvin tehdä kyselyitä web-palvelimelle, mutta tällöin käytettynä viestiprotokollana pitäisi olla HTTP-protokolla. Tutustutaan seuraavaksi tarkemmin HTTP-protokollaan, eli selainten ja palvelinten väliseen kommunikaatioon käytettyyn kommunikaatiotyyliin.</p>


            <h3>HTTP-viestin rakenne: palvelimelle lähetettävä kysely</h3>

            <p>HTTP-protokollan yli lähetettävät viestit ovat tekstimuotoisia. Viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa -- joskus palautetaan esimerkiksi vain uudelleenohjauskomento. Viestin loppuminen ilmoitetaan kahdella peräkkäisellä rivinvaihdolla.</p>

            <p>Palvelimelle lähetettävän viestin, eli kyselyn, ensimmäisellä rivillä on pyyntötapa, halutun resurssin polku ja HTTP-protokollan versionumero.</p>

<pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko</pre>

            <p>Pyyntötapa ilmaisee HTTP-protokollassa käytettävän pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.0</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että yhteys palvelimeen on jo muodostettu, eli palvelimen osoitetta ei merkitä erikseen.</p>

<pre>
GET /index.html HTTP/1.0

</pre>
	    
            <p>Yksittäisen tietokoneen käyttäminen yhteen web-palvelinohjelmistoon saapuviin pyyntöihin jättää helposti huomattavan osan tietokoneen kapasiteetista käyttämättä. Yleisesti käytössä oleva HTTP/1.1 -protokolla mahdollistaa useamman palvelimen pitämisen samassa IP-osoitteessa virtuaalipalvelintekniikan avulla. Tällöin yksittäiset palvelinkoneet voivat sisältää useita palvelimia. Käytännössä IP-osoitetta kuunteleva kone voi joko itsessään sisältää useita ohjelmistoilla emuloituja palvelimia, tai se voi toimia reitittimenä ja ohjata pyynnön tietylle esimerkiksi yrityksen sisäverkossa sijaitsevalle koneelle.</p>

	    <p>Koska yksittäinen IP-osoite voi sisältää useampia palvelimia, pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen: resurssi voisi olla millä tahansa koneeseen liittyvällä virtuaalipalvelimella. HTTP/1.1 -protokollassa on pyynnöissä pakko olla mukana käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

<pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net

</pre>


	    <h3>Yhteyden muodostaminen palvelimelle Java-maailmassa</h3>
		
	    <p>Java-maailmassa yhteys toiselle koneelle muodostetaan <a href="https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html" target="_blank">Socket</a>-luokan avulla. Kun yhteys on muodostettu, toiselle koneelle lähetettävä viesti kirjoitetaan socketin tarjoamaan <a href="https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html" target="_blank">OutputStream</a>-rajapintaan. Tämän jälkeen luetaan vastaus socketin tarjoaman <a href="https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html" target="_blank">InputStream</a>-rajapinnan kautta.</p>

<pre class="sh_java">
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        // Connect to the Web server at an address
        String address = "www.helsinki.fi";
        // InetAddress.getByName retrieves an IP for the address
        Socket socket = new Socket(InetAddress.getByName(address), 80);

        // Send a HTTP-request to the server that we are connected to 
        PrintWriter writer = new PrintWriter(socket.getOutputStream());
        writer.println("GET / HTTP/1.1");
        writer.println("Host: " + address);
        writer.println();
        writer.flush();

        // Read the response
        Scanner reader = new Scanner(socket.getInputStream());
        while (reader.hasNextLine()) {
            System.out.println(reader.nextLine());
        }
    }
}
</pre>

	    <p>Yllä oleva ohjelma ottaa yhteyden etsii www.helsinki.fi -osoitteeseen liittyvän palvelimen, ottaa yhteyden palvelimen porttiin 80, ja lähettää palvelimelle seuraavan viestin:</p>

<pre>
GET / HTTP/1.1
Host: www.helsinki.fi

</pre>

	    <p>Tämän jälkeen ohjelma tulostaa palvelimelta saatavan vastauksen.</p>

	    <div class="tehtavat">
              <div class="tehtava" id="t-browser-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-browser">
                      Hello Browser!
                    </a>
                  </h1>
                </header>
		
                <div id="t-browser" class="collapse">
		  
		  <p>Vaikkei kyseessä olekaan selainohjelmointikurssi, on jokaisen hyvä toteuttaa selainohjelmiston ensimmäiset askeleet. Toteuta tehtäväpohjassa olevan <code>HelloBrowser</code>-luokan main-metodiin ohjelma, joka kysyy käyttäjältä sivun osoitetta, tekee syötetyn sivun juureen ("/") pyynnön, ja tulostaa käyttäjälle vastauksen.</p>
		  
		  <p>Alla on esimerkkituloste, missä käyttäjän syöte on annettu punaisella.</p>

<pre>
================
 THE INTERNETS!
================
Where to? <font color="red">www.google.com</font>

==========
 RESPONSE
==========
HTTP/1.1 302 Found
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Location: http://www.google.fi/?gfe_rd=cr&ei=Q5dgVu7zDqOr8wer_4OoCA
Content-Length: 256
Server: GFE/2.0

&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
&lt;H1&gt;302 Moved&lt;/H1&gt;
The document has moved
&lt;A HREF="http://www.google.fi/?gfe_rd=cr&amp;ei=Q5dgVu7zDqOr8wer_4OoCA"&gt;here&lt;/A&gt;.
&lt;/BODY&gt;&lt;/HTML&gt;
</pre>

		  <p>Kokeile myös tehdä pyyntö osoitteeseen, jota ei ole olemassa. Minkälaisen virheviestin ohjelmisto tarjoaa?</p>

                </div>
              </div>
	    </div>
	    

            <h3>HTTP-viestin rakenne: palvelimelta saapuva vastaus</h3>

            <p>Palvelimelle tehtyyn pyyntöön saadaan aina jonkinlainen vastaus. Jos tekstimuotoiseen osoitteeseen ei ole liitetty IP-osoitetta DNS-palvelimilla, selain ilmoittaa ettei palvelinta löydy. Jos palvelin löytyy, ja pyyntö saadaan tehtyä palvelimelle asti, tulee palvelimen myös vastata jollain tavalla.</p>

            <p>Palvelimelta saatavan vastauksen sisältö on seuraavanlainen. Ensimmäisellä rivillä HTTP-protokollan versio, viestiin liittyvä statuskoodi, sekä statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

<pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
</pre>

            <p>Esimerkiksi:</p>

<pre>
HTTP/1.1 200 OK
Date: Mon, 01 Sep 2014 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..</pre>

            <p>Kun palvelin vastaanottaa tiettyyn resurssiin liittyvän pyynnön, tekee se resurssiin liittyviä toimintoja ja palauttaa lopulta vastauksen. Kun selain saa vastauksen, tarkistaa se vastaukseen liittyvän <a href="https://http.cat/" target="_blank">statuskoodin</a> ja siihen liittyvät tiedot -- tyypillinen statuskoodi on <code>200</code> (OK). Tämän jälkeen selain päättelee, mitä vastauksella tehdään, ja esimerkiksi tuottaa vastaukseen liittyvän web-sivun käyttäjälle.</p>

	    <aside class="info">
	      <br/>
	      
	      <h1>HTTP-statuskoodit</h1>

              <p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

              <ul>
		<li>1**: informaatioviestit (esim 100 "Continue")</li>
		<li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
		<li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently" tai 304 "Not Modified" eli hae välimuistista)</li>
		<li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
		<li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
              </ul>
	    </aside>

            <h3>Palvelimen toiminta Java-maailmassa</h3>
		
	    <p>Palvelimen toiminta muistuttaa huomattavasti aiemmin nähtyä yhteyden muodostamista. Toisin kuin yhteyttä toiseen koneeseen muodostaessa, palvelinta toteutettaessa luodaan <a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html" target="_blank">ServerSocket</a>-olio, joka kuuntelee tiettyä koneessa olevaa porttia. Kun toinen kone ottaa yhteyden palvelimeen, saadaan käyttöön Socket-olio, joka tarjoaa mahdollisuuden lukemiseen ja kirjoittamiseen.</p>

	    <p>Web-palvelin lukee tyypillisesti ensin pyynnön, jonka jälkeen pyyntöön kirjoitetaan vastaus. Alla on esimerkki yksinkertaisen palvelimen toiminnasta -- palvelin on toiminnassa vain yhden pyynnön ajan.</p>

<pre class="sh_java">
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        // Create a Server Socket that listens to requests on port 8080
        ServerSocket server = new ServerSocket(8080);

        // Wait for a request from a machine, once it apprears, accept it
        Socket socket = server.accept();

        // Read the request
        Scanner requestReader = new Scanner(socket.getInputStream());

        // Write the response
        PrintWriter responseWriter = new PrintWriter(socket.getOutputStream());

        // Close the streams and the socket
        requestReader.close();
        responseWriter.close();
        socket.close();

        // Close the server
        server.close();
    }
}
</pre>

	    <p>Kokeile ylläolevaa ohjelmaa omalla koneellasi. Kuten aiemmissa web-sovelluksissa, voit tässäkin tehdä HTTP-pyynnön porttiin 8080 kirjoittamalla  selaimella osoitteeksi <code>http://localhost:8080</code>. Jos sovelluksen käynnistäminen ei onnistu, tarkista että portti ei ole varattu (et ole sammuttanut jotain aiemmin tekemääsi web-sovellusta).</p>


	    
	    <aside class="info">
	      <br/>
	      <h1>Web-palvelin odottaa pyyntöä selaimelta</h1>
	      
	      <p>ServerSocket-olion accept-metodi on <em>blokkaava</em>. Tämä tarkoittaa sitä, että accept-metodia kutsuttaessa ohjelman suoritus jää odottamaan kunnes palvelimeen otetaan yhteys. Kun yhteys on muodostettu, accept-metodi palauttaa Socket-olion, jota käytetään palvelimen ja yhteyden ottaneen koneen väliseen kommunikointiin.</p>

	      <p>Ohjelmoijan näkökulmasta Socket-oliota -- ja porttia yleisemminkin -- voi ajatella tiedostona. Tiedostoon voi kirjoittaa ja siellä olevaa tietoa voi lukea. Kirjoitettava ja luettava tieto ei kuitenkaan tule tiedostosta, vaan yhteyden toisessa päässä toimivasta ohjelmasta.</p>

	    </aside>
	    
	    <p>Tyypillisesti palvelin halutaan toteuttaa niin, että se kuuntelee ja käsittelee pyyntöjä jatkuvasti. Tämä onnistuu toistolauseen avulla.</p>

<pre class="sh_java">
// Create a Server Socket that listens to requests on port 8080
ServerSocket server = new ServerSocket(8080);

while (true) {
    // Wait for a request from a machine, once it apprears, accept it
    Socket socket = server.accept();

    // Read the request
    Scanner requestReader = new Scanner(socket.getInputStream());

    // Write the response
    PrintWriter responseWriter = new PrintWriter(socket.getOutputStream());

    // Close the streams and the socket
    requestReader.close();
    responseWriter.close();
    socket.close();
}
</pre>

	    <p>Web-palvelimet käsittelevät useampia pyyntöjä lähes samanaikaisesti, sillä palvelinohjelmistot ovat säikeistettyjä. Käytännössä jokainen pyyntö käsitellään erillisessä säikeessä, joka luo pyyntöön vastauksen ja palauttaa sen käyttäjille. Javassa säikeille löytyy oma <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" target="_blank">Thread</a>-luokka. Emme kuitenkaan tällä kurssilla perehdy säikeiden käyttöön sen tarkemmin -- tätä varten löytyy kurssi <a href="https://www.cs.helsinki.fi/courses/582219" target="_blank">Käyttöjärjestelmät</a>.</p>


	    <aside class="info">
	      <br/>
	      <h1>Tietokoneen portit</h1>

	      <p>Jos kokeilet käynnistää palvelimen koneellasi portissa 80, saatat törmätä virheviestiin. Tähän on useita mahdollisia syitä: (1) koneellasi oleva palomuuri- tai tietoturvaohjelmisto ei salli portin avaamista, (2) portti on jo käytössä (koneellasi oleva ohjelma -- esimerkiksi palvelin -- käyttää porttia 80), tai käyttäjätunnuksellasi ei ole oikeuksia portin avaamiseen.</p>

	      <p>Tietokoneella on käytössä portit 0-65535, joista "normaali" käyttäjä saa tyypillisesti avata vain suurempia kuin 1024 olevia. Lue lisää porteista <a href="https://fi.wikipedia.org/wiki/Portti_(tietoliikenne)" target="_blank">Wikipediasta</a>.</p>
	    </aside>


	    

            <div class="tehtavat">
	      
              <div class="tehtava" id="t-server-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-server">
                      Hello Server!
                    </a>
                  </h1>
                </header>
		
                <div id="t-server" class="collapse">
		  
		  <p>Toteuta web-palvelin, joka kuuntelee pyyntöjä porttiin 8080.</p>
		  
		  <p>Jos pyydetty polku on <code>/quit</code>, tulee palvelin sammuttaa.</p>
		  
		  <p>Muulloin, minkä tahansa pyynnön vastaukseen kirjoitetaan resurssin siirtymisestä kertova (302-alkuinen) HTTP-statuskoodi sekä palvelimen osoite, eli <code>http://localhost:8080</code>.</p>

		  <p>Ota samalla selvää kuinka monta pyyntöä selaimesi tekee palvelimelle, ennen kuin se ymmärtää että jotain on vialla.</p>

		  <img src="img/mooc/ex20-redirectloop.png"/>
		  
                </div>
              </div>
	    </div>
	    

            <aside class="info">
	      
              <p><strong>Google Dev Tools</strong></p>
		  
              <p>Google Chromen DevTools-apuvälineet löytää Tools-valikosta tai painamalla F12 (Linux). Apuvälineillä voi esimerkiksi tarkastella verkkoliikennettä ja lähetettyjä ja vastaanotettuja paketteja. Valitsemalla työvälineistä Network-välilehden, ja lataamalla sivun uudestaan, näet kaikki sivua varten ladattavat osat sekä kunkin osan lataamiseen kuluneen ajan.</p>

	      <p>Yksittäistä sivua avattaessa tehdään jokaista resurssia (kuva, tyylitiedosto, skripti) varten erillinen pyyntö. Esimerkiksi <a href="http://www.hs.fi" target="_blank">Helsingin sanomien</a> verkkosivua avattaessa tehdään yli 270 erillistä pyyntöä.</p>

	      <img src="img/google-devtools-hs-fi.png"/>

	      
            </aside>
	    
	    
            <h3>HTTP-liikenteen testaaminen telnet-työvälineellä</h3>
	    
            <p>Linux-ympäristöissä on käytössä telnet-työkalu, jota voi käyttää yksinkertaisena asiakasohjelmistona pyyntöjen simulointiin. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla <code>telnet isäntäkone portti</code>. Esimerkiksi Helsingin sanomien www-palvelimelle saa yhteyden seuraavasti:</p>

<pre>
$ telnet www.hs.fi 80
</pre>

            <p>Tätä seuraa telnetin infoa yhteyden muodostamisesta, jonka jälkeen pääsee kirjoittamaan pyynnön.</p>

<pre>
Trying 158.127.30.40...
Connected to www.hs.fi.
Escape character is '^]'.

</pre>

            <p>Yritetään pyytää HTTP/1.1 -protokollalla juuridokumenttia. Huom! HTTP/1.1 -protokollassa tulee pyyntöön lisätä aina Host-otsake. Jos yhteys katkaistaan ennen kuin olet saanut kirjoitettua viestisi loppuun, ota apuusi tekstieditori ja copy-paste. Muistathan myös että viesti lopetetaan aina kahdella rivinvaihdolla.</p>

<pre>
GET / HTTP/1.1
Host: www.hs.fi

</pre>

            <p>Palvelin palauttaa vastauksen, jossa on statuskoodi ja otsakkeita sekä dokumentin runko.</p>

<pre>
HTTP/1.1 200 OK
X-UA-Compatible: IE=Edge,chrome=1
X-PageCache: true
Content-Type: text/html;charset=UTF-8
Content-Language: en
Content-Length: 485452
Set-Cookie: HSSESSIONID=0E325634FOOH806AC32F62E33F3CF624F3.fe04; Path=/; HttpOnly
Vary: Accept-Encoding
Connection: close

&lt;!DOCTYPE html&gt;
...
</pre>

            <p>Juuripolkua palvelimelta <code>www.hs.fi</code> haettaessa palvelin vastaa "OK" ja palauttaa dokumentin.</p>


	    <p>Jos käytössäsi ei ole Linux-konetta, voit käyttää Telnetiä esimerkiksi <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank">PuTTY</a>-ohjelmiston avulla. Voit myös tehdä selailua käsin aiemmin toteutetun Java-ohjelman avulla.</p>

	    
            <aside class="pohdi">
              <h1>Kuinka monta hyppyä?</h1>
		  
              <p>Tee telnetillä pyyntö osoitteeseen <code>hs.fi</code> (portti 80) ja selvitä kuinka monta hyppyä tarvitaan siihen, että päästään Helsingin sanomien osoitteessa <code>http://www.hs.fi</code> olevalle etusivulle. Kuinka monta uudelleenohjausta palvelin palauttaa ennenkuin palvelin lopulta kertoo oikean etusivun osoitteen?</p>
	      
              <p>Huom! Jos et ehdi kirjoittamaan komentoa telnet-ikkunaan, voit ensin kirjoittaa sen esimerkiksi tekstieditoriin, ja kopioida sen sieltä telnet-ikkunaan.</p>
		  
<pre>
GET / HTTP/1.1
Host: hs.fi

</pre>

            </aside>


            <h3>HTTP-protokollan pyyntötavat</h3>

            <p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (Request method), joista eniten käytettyjä ovat <code>GET</code> ja <code>POST</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

            <p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>

            <p>Suomeksi yksinkertaistaen: GET-pyynnöt ovat tarkoitettu tiedon hakamiseen. Palvelinpuolen toiminnallisuutta suunniteltaessa tulee siis pyrkiä tilanteeseen, missä <code>GET</code>-tyyppisillä pyynnöillä ei muuteta palvelimella olevaa dataa.</p>

            <h4>Tiedon hakeminen: GET</h4>

            <p>GET-pyyntötapaa käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

<pre>
GET /sivu.html?porkkana=1 HTTP/1.1
Host: palvelimen-osoite.net

</pre>

	    <p>Spring-sovelluksissa kontrollerimetodi kuuntelee GET-tyyppistä pyyntöä jos <code>@RequestMapping</code>-annotaatiolle on määritelty metodiksi <code>GET</code>: <code>@RequestMapping(value = "polku", method = RequestMethod.GET)</code>.</p>

            <h4>Tiedon lähettäminen: POST</h4>

            <p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

<pre>
POST /sivu.html HTTP/1.1
Host: palvelimen-osoite.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
</pre>
	    <p>Spring-sovelluksissa kontrollerimetodi kuuntelee POST-tyyppistä pyyntöä jos <code>@RequestMapping</code>-annotaatiolle on määritelty metodiksi <code>POST</code>: <code>@RequestMapping(value = "polku", method = RequestMethod.POST)</code>.</p>


            <h4>Muita pyyntötyyppejä</h4>

	    <p>Selaimen ja palvelimen välisessä kommunikoinnissa GET- ja POST-tyyppiset pyynnöt ovat eniten käytettyjä. Sivun tai siihen liittyvän osan kuten kuvan hakeminen tapahtuu käytännössä aina GET-tyyppisellä pyynnöllä, ja tiedon lähettäminen esimerkiksi lomakkeen kautta POST-tyyppisellä pyynnöllä. HTTP-protokolla määrittelee muitakin pyyntötyyppejä, joita käytetään palvelinohjelmistojen toteuttamisessa. Oleellisimpia ovat:</p>

	    <ul>
	      <li><em>OPTIONS</em> pyytää tietoja resurssiin liittyvistä vaihtoehdoista (esimerkiksi voidaanko resurssi poistaa, ...)</li>
	      <li><em>DELETE</em> pyytää resurssin poistamista</li>
	      <li><em>HEAD</em> haluaa resurssiin liittyvät otsaketiedot, mutta ei resurssia</li>
	    </ul>


	    <aside class="info">
		  
	      <br/>
	      <h1>HTTP/2</h1>

	      <p>Nykyaikaiset web-sivustot ja palvelinohjelmistot sisältävät tyypillisesti useita erilaisia asioita: kuvia, tyylitiedostoja, musiikkia, videokuvaa ja niin edelleen. Jokainen sivuun liittyvä resurssi tulee hakea erikseen.</p>

	      <p>HTTP-protokollasta julkaistiin toukokuussa 2015 versio <a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank">HTTP/2</a> (<a href="https://tools.ietf.org/html/rfc7540" target="_blank">RFC 7540</a>). Eräs uudistus protokollassa on palvelimelle jätetty mahdollisuus lähettää pyyntöön vastauksena useampia resursseja osana samaa vastausta. Tällöin yhteyden avaamiseen ja sulkemiseen käytetty aika vähenee ja web-sivustojen lataaminen mahdollisesti nopeutuu. HTTP/2 -protokolla sisältää muitakin parannuksia nykytilanteeseen -- suurin osa toiminnallisuudesta toteutetaan kuitenkin palvelinohjelmistoa pyörittävässä palvelimessa, eikä itse palvelinohjelmistossa.</p>
	    </aside>

	    
            <h2>HTML: Yhteinen dokumenttien esityskieli</h2>

            <p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt;) loppuvalla merkkijonolla (&lt;elementin_nimi&gt;), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt;).</p>

            <p>HTML-dokumentin rakennetta voi ajatella myös puuna. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

            <p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja eli tekstiä, voi elementin yleensä avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p>

            <p>HTML:stä on useita erilaisia standardeja, joista viimeisin julkaistu versio on <a href="http://www.w3.org/TR/html5/" target="_blank">HTML5</a>. Versiota <a href="http://www.w3.org/TR/html51/" target="_blank">5.1</a> työstetään tällä hetkellä (viimeisin päivitys 21.6.2016).</p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

            <p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

            <p>Elementit voivat sisältää attribuutteja ja attribuuteille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään UTF-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

            <p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme juurikaan syvenny selainpuolen toiminnallisuuteen.</p>

	    <aside class="info">

	      <br/>
	      
	      <h1>Thymeleaf ja HTML</h1>
		  
	      <p>Käytämme kurssilla Thymeleaf-komponenttia dynaamisen sisällön lisäämiseen sivuille. Thymeleaf on erittäin tarkka HTML-dokumentin muodosta, ja pienikin poikkeama voi johtaa virhetilanteeseen. Kannattaakin aina edetä pienin askelein, ja aina muokata ja testata vain yhtä paikkaa kerrallaan. Tällöin virhetilanteessa tyypillisesti tietää mistä kohdasta kannattaa lähteä etsimään virhettä. </p>
	      
	    </aside>


	    <h1>Sovelluksen rakenne ja pyynnön kulku sovelluksessa</h1>

	    <p>Web-sovellusten suunnittelussa noudatetaan useita arkkitehtuurimalleja. Tyypillisimpiä näistä ovat MVC-arkkitehtuuri sekä kerrosarkkitehtuuri, joissa kummassakin perusperiaatteena on vastuiden jako selkeisiin osakokonaisuuksiin.</p>

	    
	    <h2>MVC-arkkitehtuuri</h2>


	    <p>MVC-arkkitehtuurin tavoitteena on käyttöliittymän erottaminen sovelluksen toiminnasta siten, että käyttöliittymät eivät sisällä sovelluksen toiminnan kannalta tärkeää sovelluslogiikkaa. MVC-arkkitehtuurissa ohjelmisto jaetaan kolmeen osaan: malliin (<em>model</em>, tiedon tallennus- ja hakutoiminnallisuus), näkymään (<em>view</em>, käyttöliittymän ulkoasu ja tiedon esitystapa) ja käsittelijään (<em>controller</em>, käyttäjältä saatujen käskyjen käsittely sekä sovelluslogiikka).</p>

	    <p>MVC-mallia on perinteisesti käytetty työpöytäsovelluksiin, missä käsittelijä on voinut olla jatkuvassa yhteydessä näkymään ja malliin. Tällöin käyttäjän yksittäinen toiminta käyttöliittymässä -- esimerkiksi tekstikentän tiedon päivitys -- liittyy tapahtumankäsittelijään, joka ohjaa tiedon malliin liittyvälle ohjelmakoodille, jonka tehtävänä on päivittää sovellukseen liittyvää tietoa tarvittaessa. Tapahtumankäsittelijä mahdollisesti sisältää myös ohjelmakoodia, joka pyytää muunnosta käyttöliittymässä.</p>

	    <p>Web-maailmassa käsittelijän ohjelmakoodia suoritetaan vain kun selain lähettää palvelimelle pyynnön. Ohjelmakoodissa haetaan esimerkiksi tietokannasta tietoa, joka ohjataan näkymän luontiin tarkoitetulle sovelluksen osalle. Kun näkymä on luotu, palautetaan se pyynnön tehneelle selaimelle. Spring-sovelluksissa kontrollereissa näkyvä <code>Model</code> viittaa tietoon, jota käytetään näkymän luomisessa -- se ei kuitenkaan vastaa MVC-mallin model -termiä, joka liittyy kattavammin koko tietokantatoiminnallisuuteen.</p>

	    <div class="image">
              <img src="img/mvc.png"/>
              <div>MVC-mallissa käyttäjän pyyntö ohjautuu kontrollerille, joka sisältää sovelluslogiikkaa. Kontrolleri kutsuu pyynnöstä riippuen mallin toiminnallisuuksia ja hakee sieltä esimerkiksi tietoa. Tämän jälkeen pyyntö ohjataan näkymän luomisesta vastuulle olevalle komponentilla ja näkymä luodaan. Lopulta näkymä palautetaan vastauksena käyttäjän tekemälle pyynnölle.</div>
            </div>
	    
	    <p>MVC-mallista on useita hyötyjä. Käyttöliittymien (näkymien) suunnittelu ja toteutus voidaan eriyttää sovelluslogiikan toteuttamisesta, ja niitä voidaan työstää rinnakkain. Samalla ohjelmakoodi selkenee, sillä eri komponenttien vastuut ovat eriteltyjä -- näkymät eivät sisällä sovelluslogiikkaa, kontrollerin tehtävänä on käsitellä pyynnöt ja ohjata niitä eteenpäin, ja mallin vastuulla on tietoon liittyvät operaatiot. Tämän lisäksi sovellukseen voidaan luoda useampia käyttöliittymiä, joista jokainen käyttää samaa sovelluslogiikkaa, ja pyynnön kulku sovelluksessa selkiytyy.</p>


	    <h2>Kerrosarkkitehtuuri</h2>


	    <p>Kun sovellus jaetaan selkeisiin vastuualueisiin, selkeytyy myös pyynnön kulku sovelluksessa. Kerrosarkkitehtuuria noudattamalla pyritään tilanteeseen, missä sovellus on jaettu itsenäisiin kerroksiin, jotka toimivat vuorovaikutuksessa muiden kerrosten kanssa. Käyttöliittymäkerros sisältää näkymät (esim. Thymeleafin html-sivut) sekä mahdollisen logiikan tiedon näyttämiseen (esim tägit html-sivuilla). Käyttöliittymä näkyy käyttäjän selaimessa, ja käyttäjän selain tekee palvelimelle pyyntöjä käyttöliittymässä tehtyjen klikkausten ja muiden toimintojen pohjalta. Palvelimella toimivan sovelluksen kontrollerikerros ottaa vastaan nämä pyynnöt, ja ohjaa ne eteenpäin sovelluksen sisällä. Tällä kurssilla kerrosarkkitehtuurilla tarkoitetaan yleisesti ottaen seuraavaa jakoa:</p>

            <ul>
              <li>Käyttöliittymäkerros</li>
              <li>Kontrollerikerros</li>
              <li>Sovelluslogiikka ja palvelut</li>
              <li>Tallennuslogiikka (tietokanta-abstraktio ja tietokantapalvelut)</li>
            </ul>

            <p>Kerrosarkkitehtuuria noudattaessa ylempi kerros hyödyntää alemman kerroksen tarjoamia toiminnallisuuksia, mutta alempi kerros ei hyödynnä ylempien kerrosten tarjoamia palveluita. Puhtaassa kerrosarkkitehtuurissa kaikki kerrokset ovat olemassa, ja kutsut eivät ohita kerroksia ylhäältä alaspäin kulkiessaan. Tällä kurssilla noudatamme avointa kerrosarkkitehtuuria, missä kerrosten ohittaminen on sallittua.</p>


	    <div class="image">
              <img src="img/layers.png"/>
              <div>Kerrosarkkitehtuurissa sovelluksen vastuut jaetaan kerroksittain. Näkymäkerros sisältää käyttöliittymät, joista voidaan tehdä pyyntöjä kontrollerille. Kontrolleri käsittelee palveluita, jotka ovat yhteydessä tallennuslogiikkaan. Tiedon tallentamiseen käytettäviä entiteettejä sekä muita luokkia (esim "view objects") käytetään kaikilla kerroksilla.</div>
            </div>


            <h3>Kontrollerikerros</h3>

            <p>Kontrollerien ensisijaisena vastuuna on pyyntöjen kuuntelu, pyyntöjen ohjaaminen sopiville palveluille, sekä tuotetun tiedon ohjaaminen oikealle näkymälle tai näkymän generoivalle komponentille.</p>

            <p>Jotta palveluille ei ohjata epäoleellista dataa, esimerkiksi huonoja arvoja sisältäviä parametreja, on kontrolleritason vastuulla myös pyynnössä olevien parametrien validointi.</p>

	    <p>Kontrollerikerroksen luokissa käytetään annotaatiota <code>@Controller</code>, ja luokkien metodit, jotka vastaanottavat pyyntöjä annotoidaan <code>@RequestMapping</code>-annotaatiolla.</p>


            <h3>Palvelukerros</h3>

            <p>Palvelukerros tarjoaa kontrollerikerrokselle palveluita, joita kontrollerikerros voi käyttää. Palvelut voivat esimerkiksi abstrahoida kolmannen osapuolen tarjoamia komponentteja tai rajapintoja, tai sisältää toiminnallisuutta, jonka toteuttaminen kontrollerissa ei ole järkevää esimerkiksi sovelluksen ylläpidettävyyden kannalta.</p>

	    
            <p>Vaikka palvelukerroksella sijaitsevan toiminnallisuuden voisi sisällyttää kontrollerikerrokseen, kontrollerikerros ennen pitkää muuttuisi yhä epäselkeämmäksi.</p>

	    <p>Palvelukerroksen luokat merkitään annotaatiolla <code>@Service</code> tai <code>@Component</code>. Tämä annotaatio tarkoittaa käytännössä sitä, että sovelluksen käynnistyessä luokka ladataan muistiin ja sen ilmentymä asetetaan olioihin, jotka on merkitty <code>@Autowired</code>-annotaatiolla.</p>

	    <p>Alla olevassa esimerkissä luokka <code>PankkiService</code> tarjoaa pankkipalveluita, ja se on otettu automaattisesti luokan <code>PankkiController</code>-käyttöön.</p>

<pre class="sh_java">
// pakkaus ja importit

@Service
public class PankkiService {

    // käytetyt oliot

    public void siirraRahaa(Long tililta, Long tilille, Double maara) {
        // toteutus
    }
}</pre>

<pre class="sh_java">
// pakkaus ja importit

@Controller
public class PankkiController {

    @Autowired
    private PankkiService pankkiService;

    @RequestMapping(value = "/siirto", method = RequestMethod.POST)
    public String siirraRahaa(@RequestParam Long tililta, 
            @RequestParam Long tilille, @RequestParam Double maara) {
        this.pankkiService.siirraRahaa(tililta, tilille, maara);
        return "redirect:/nakyma";
    }

    // muut toiminnot
}</pre>

	    <p>Yllä <code>PankkiController</code>-luokan vastuut on eritelty selkeästi. Kontrollerin vastuulla on vain pyynnön vastaanotto sekä näkymän luomiseen liittyvä ohjeistus.</p>
	    
            <h3>Tallennuslogiikka</h3>

	    <p>Tallennuslogiikkakerros sisältää tietokannan käyttöön liittyvät oleelliset oliot. Pankki saattaisi tarvita esimerkiksi Tilitapahtumiin liittyvää tallennuslogiikkaa. Täällä olisi esimerkiksi <code>Repository</code>-rajapinnat, jotka perivät rajapinnan <code>JpaRepository</code>.</p>

	    

	    <h3>Tietoa sisältävät oliot</h3>

	    <p>Tiedon esittämiseen liittyvät oliot elävät kerrosarkkitehtuurissa kerrosten sivulla. Esimerkiksi entiteettejä voidaan käsitellä tallennuslogiikkakerroksella (tiedon tallennus), palvelukerroksella (tiedon käsittely), kontrollerikerroksella (tiedon lisääminen Model-olioon) sekä näkymäkerroksella (Model-olion käyttäminen näkymän luomiseen.</p>

	    <p>Sovellusten kehittämisessä näkee välillä myös jaon useampaan erilaiseen tietoa sisältävään oliotyyppiin. Entiteettejä käytetään tietokantatoiminnallisuudessa, mutta välillä näkymien käsittelyyn palautettavat oliot pidetään erillisinä entiteeteistä. Tähän ei ole oikeastaan yhtä oikeaa tapaa: lähestymistapa valitaan tyypillisesti ohjelmistokehitystiimin kesken.</p>



            <aside class="info">
              <h1>Dependency Injection ja Inversion of Control</h1>
	      
              <p>Jokaisella luokalla on oma selkeä vastuualueensa, ja vastuiden sekoittamista tulee välttää. Inversion of Control ja Dependency Injection ovat suunnitelumalleja, joilla pyritään vähentämään olioiden turhia riippuvuuksia.</p>

              <p>Perinteisissä ohjelmistoissa olioiden luominen on ohjelmoijan vastuulla, mutta ohjelmistokehykset tekevät osan tästä työstä puolestamme.</p>

	      <p>Spring luo käyttöömme luokkia joita tarvitsemme: Kontrollin käännöllä tarkoitetaan ohjelman toiminnan hallinnan vastuun siirtämistä sovelluskehykselle ja ohjelmaa suorittavalle palvelimelle (<em>inversion of control</em>).</p>

	      <p>Spring injektoi <code>@Autowired</code>-annotaatiolla merkittyihin oliomuuttujiin ilmentymät luokista, jotka se lataa käyttöönsä palvelinohjelmiston käynnistyessä (<em>dependency injection</em>). Luokat ladataan annotaatioiden perusteella: jos luokalla on @Controller, @Service, @Component tai @Repository -annotaatio, ladataan se ohjelman käyttöön alussa.</p>

              <p>Lue lisää aiheesta <a href="http://martinfowler.com/articles/injection.html" target="_blank">Martin Fowlerin</a> artikkelista.</p>
            </aside>


	    

            <h1>Tiedon tallentaminen ja hakeminen</h1>

	    <p>Hyvin harva web-sovellus toimii ilman tarvetta tiedon tallentamis- tai hakutoiminnallisuudelle. Tietoa voidaan tallentaa levylle tiedostoihin, tai sitä voidaan tallentaa erilaisiin tietokantaohjelmistoihin. Nämä tietokantaohjelmistot voivat sijaita erillisellä koneella web-sovelluksesta, tai ne voivat itsekin olla web-sovelluksia. Toteutusperiaatteista riippumatta näiden sovellusten ensisijainen tehtävä on varmistaa, ettei käytettävä tieto katoa.</p>
	    
	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Tietokannat, wut?</h1>
	      
	      <p>Jos tietokannat eivät käsitteenä ole tuttuja, ja/tai SQL-kyselyiden kirjoittaminen on ruosteessa, tutustu Helsingin yliopiston kurssin <a href="http://tietokantojen-perusteet.github.io/" target="_blank">tietokantojen perusteet</a> materiaaliin.</p>
	      
	    </aside>
	    

	    <h2>Tietokannan käyttäminen ohjelmallisesti</h2>
	    
	    <p>Käytämme tällä kurssilla <a href="http://www.h2database.com/html/main.html" target="_blank">H2-tietokantamoottoria</a>, joka tarjoaa rajapinan SQL-kyselyiden tekemiseen. H2-tietokantamoottorin saa käyttöön lisäämällä projektin <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>
	    
<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;version&gt;1.4.192&lt;/version&gt;
&lt;/dependency&gt;
</pre>

	    <p>Tietokantaa käyttävä ohjelma sisältää tyypillisesti tietokantayhteyden luomisen, tietokantakyselyn tekemisen tietokannalle, sekä tietokannan palauttamien vastausten läpikäynnin. Javalla edellämainittu näyttää esimerkiksi seuraavalta -- alla oletamme, että käytössä on tietokantataulu "Book", jossa on sarakkeet "id" ja "name".</p>

<pre class="sh_java">
// Open connection to database
Connection connection = DriverManager.getConnection("jdbc:h2:./database", "sa", "");

// Create query and retrieve result set
ResultSet resultSet = connection.createStatement().executeQuery("SELECT * FROM Book");

// Iterate through results
while (resultSet.next()) {
    String id = resultSet.getString("id");
    String name = resultSet.getString("name");

    System.out.println(id + "\\t" + name);
}

// Close the resultset and the connection
resultSet.close();
connection.close();
</pre>

	    <p>Oleellisin tässä on luokka <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html" target="_blank">ResultSet</a>, joka tarjoaa pääsyn rivikohtaisiin tuloksiin. Kurssin <a href="http://tietokantojen-perusteet.github.io/" target="_blank">tietokantojen perusteet</a> oppimateriaali sisältää myös hieman tietoa ohjelmallisista tietokantakyselyistä.</p>

	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Tietokantayhteyden luomisesta</h1>
		  
	      <p>Komento <code>DriverManager.getConnection("jdbc:h2:./database", "sa", "");</code> luo JDBC-yhteyden tietokantaan nimeltä "database". Käyttäjätunnuksena käytetään tunnusta "sa", jonka salasana on "". </p>
	      
	      <p>Jos "database"-nimistä tietokantaa ei ole, luodaan se levyjärjestelmään projektin juureen. Tässä tapauksessa luodaan tiedosto <code>database.mv.db</code> sekä mahdollisesti <code>database.trace.db</code>. Tietokantayhteyden voi luoda myös muistiin ladattavaan tietokantaan, jolloin tietokantaa ei luoda levyjärjestelmään -- tällöin tietokannassa oleva tieto kuitenkin katoaa ohjelman sammutuksen yhteydessä.</p>

	      <p>Tarkempi opas H2-tietokannan tarjoamiin toimintoihin löytyy osoitteesta <a href="http://www.h2database.com/html/tutorial.html" target="_blank">http://www.h2database.com/html/tutorial.html</a>.</p>

	    </aside>
	    
            <p></p>

	    <p>Tietokannalla on tyypillisesti skeema, joka määrittelee tietokantataulujen rakenteen. Rakenteen lisäksi tietokantatauluissa on dataa. Kun tietokantasovellus käynnistetään ensimmäistä kertaa, nämä tyypillisesti ladataan myös käyttöön. H2-tietokantamoottori tarjoaa tätä varten työvälineitä <a href="http://www.h2database.com/javadoc/org/h2/tools/RunScript.html" target="_blank">RunScript</a>-luokassa. Alla olevassa esimerkissä tietokantayhteyden avaamisen jälkeen yritetään lukea tekstitiedostoista <code>database-schema.sql</code> ja <code>database-import.sql</code> niiden sisältö tietokantaan.</p>
	    
	    <p>Tiedosto <code>database-schema.sql</code> sisältää tietokantataulujen määrittelyt, ja tiedosto <code>database-import.sql</code> tietokantaan lisättävää tietoa. Järjestys on oleellinen -- jos tietokantataulujen määrittelyiden syöttämisessä tapahtuu virhe, ovat tietokantataulut olemassa. Tällöin tietoa ei myöskään ladata tietokantaan.</p>


<pre class="sh_java">
// Open connection to database
Connection connection = DriverManager.getConnection("jdbc:h2:./database", "sa", "");

try {
    // If database has not yet been created, create it
    RunScript.execute(connection, new FileReader("database-schema.sql"));
    RunScript.execute(connection, new FileReader("database-import.sql"));
} catch (Throwable t) {
    System.out.println(t.getMessage());
}
// ...
</pre>


	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellodatabase-ex">
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodatabase">
                      Hello Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodatabase" class="collapse">
		  
		  <p>Käytössäsi on agenttien tietoja sisältävä tietokantataulu, joka on määritelty seuraavasti:</p>
		  
<pre class="sh_sql">
CREATE TABLE Agent (
    id varchar(9) PRIMARY KEY,
    name varchar(200)
);</pre>
		  
		  <p>Kirjoita ohjelma, joka tulostaa kaikki tietokannassa olevat agentit.</p>
		  
                </div>
              </div>
	      
              <div class="tehtava" id="t-helloinsert-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloinsert">
                      Hello Insert
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloinsert" class="collapse">
		  
		  <p>Käytössäsi on edellisessä tehtävässä käytetty agenttien tietoja sisältävä tietokantataulu. Toteuta tässä tehtävässä tietokantaan lisäämistoiminnallisuus. Ohjelman tulee toimia seuraavasti:</p>

<pre>
Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein

Add one:
What id? <font color="red">Riddle</font>
What name? <font color="red">Voldemort</font>

Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein
Riddle	Voldemort
</pre>

		  <p>Seuraavalla käynnistyskerralla agentti Voldemort on tietokannassa heti sovelluksen käynnistyessä.</p>

<pre>
Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein
Riddle	Voldemort

Add one:
What id? <font color="red">Feather</font>
What name? <font color="red">Major Tickle</font>

Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein
Riddle	Voldemort
Feather	Major Tickle
</pre>

                </div>
              </div>
	      
              <div class="tehtava" id="t-hellodao-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodao">
                      Hello Dao
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodao" class="collapse">
		  
		  <p>Edellisissä tietokantatehtävissä tietokantatoiminnallisuus toteutettiin suoraan main-metodiin. Tämä ei ohjelman koon kasvaessa ole toivottua -- toteutetaan tässä rajapinta tietokantatoiminnallisuuden abstrahointiin.</p>
		  
		  <p>Etsi tehtäväpohjasta luokka <code>AgentDao</code> ja toteuta siihen rajapinnan <code>Dao&lt;Agent, String&gt;</code> vaatimien metodien tietokantatoiminnallisuus. Kun ohjelma on toteutettu, luokan HelloDao main-metodi toimii kutakuinkin järkevästi.</p>
		  
                </div>
              </div>
            </div>
	    
	    <aside class="info">
	      <br/>

	      <h1>Web-palvelinohjelmointikurssi?</h1>
	      
	      <p>Edelliset tehtävät antavat vain pienen pintaraapaisun siihen teknologiaan, minkä päälle nykyaikaiset web-sovellukset rakentuvat. Vaikka web-sovelluksia voi toteuttaa ilman suurempaa tietämystä niihin liittyvistä taustateknologioista ja ratkaisuista, omatoiminen syventyminen teemaan kannattaa.</p>
	      
	    </aside>


	    <h2>Oliot ja relaatiotietokannat</h2>

	    <p>Relaatiotietokantojen ja olio-ohjelmoinnin välimaastossa sijaitsee tarve olion muuntamiseen tietokantataulun riviksi ja takaisin. Tähän tehtävään käytetään ORM (<em><a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">Object-relational mapping</a></em>) -ohjelmointitekniikkaa, jota varten löytyy merkittävä määrä valmiita työvälineitä sekä kirjastoja.</p>

	    <p>ORM-työvälineet tarjoavat ohjelmistokehittäjälle mm. toiminnallisuutta tietokantataulujen luomiseen määritellyistä luokista, jonka lisäksi ne helpottavat kyselyjen muodostamista ja hallinnoivat luokkien välisiä viittauksia. Tällöin ohjelmoijan vastuulle jää sovellukselle tarpeellisten kyselyiden toteuttaminen vain niiltä osin kun niitä ei tarjota valmiiksi.</p>

            <p>Relaatiotietokantojen käsittelyyn Javalla löytyy joukko ORM-sovelluksia. Oracle/Sun standardoi olioiden tallentamisen relaatiotietokantoihin <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a> (<em>Java Persistence API</em>) -standardilla. JPA:n toteuttavat kirjastot (esim. <a href="http://www.hibernate.org/" target="_blank">Hibernate</a>) abstrahoivat relaatiotietokannan ja helpottavat kyselyjen tekemistä suoraan ohjelmakoodista.</p>
	    <p>Koska huomattava osa tietokantatoiminnallisuudesta on hyvin samankaltaista ("tallenna", "lataa", "poista", ...), voidaan perustoiminnallisuus piilottaa käytännössä kokonaan ohjelmoijalta. Tällöin ohjelmoijalle jää tehtäväksi usein vain sopivan rajapintaluokan määrittely. Esimerkiksi aiemmin nähdyn <code>Henkilo</code>-luokan tallentamistoiminnallisuuteen tarvitaan seuraavanlainen rajapinta.</p>

<pre class="sh_java">
// pakkaus ja importit
public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
}</pre>

            <p>Kun rajapintaa käytetään, Spring osaa tuoda sopivan toteutuksen ohjelman käyttöön. Käytössä tulee olla Maven-riippuvuus Spring-projektin Data JPA -kirjastoon.</p>


<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>


            <h2>Luokan määrittely tallennettavaksi</h2>
	    
            <p>JPA-standardin mukaan luokka tulee määritellä <em>entiteetiksi</em>, jotta siitä tehtyjä olioita voi tallentaa JPA:n avulla tietokantaan.</p>

            <p>Jokaisella tietokantaan tallennettavalla luokalla tulee olla annotaatio <code>@Entity</code> sekä <code>@Id</code>-annotaatiolla merkattu attribuutti, joka toimii tietokantataulun ensisijaisena avaimena. JPA:ta käytettäessä <code>id</code>-attribuutti on usein numeerinen (<code>Long</code> tai <code>Integer</code>), mutta merkkijonojen käyttö on yleistymässä. Näiden lisäksi, luokan tulee toteuttaa <code>Serializable</code>-rajapinta.</p>

            <p>Numeeriselle avainattribuutille voidaan lisäksi määritellä annotaatio <code>@GeneratedValue(strategy = GenerationType.AUTO)</code>, joka antaa id-kentän arvojen luomisen vastuun tietokannalle. Tietokantatauluun tallennettava luokka näyttää seuraavalta:</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Henkilo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String nimi;

    // getterit ja setterit</pre>

            <p>Tietokantaan luotavien sarakkeiden ja tietokantataulun nimiä voi muokata annotaatioiden <code>@Column</code> ja <code>@Table</code> avulla.</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "Henkilo")
public class Henkilo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;
    @Column(name = "nimi")
    private String nimi;
    // getterit ja setterit</pre>

            <p>Ylläoleva konfiguraatio määrittelee luokasta <code>Henkilo</code> tietokantataulun nimeltä "Henkilo", jolla on sarakkeet "id" ja "nimi". Sarakkeiden tyypit päätellään muuttujien tyyppien perusteella.</p>

            <p>Spring Data JPA:n <a href="http://docs.spring.io/autorepo/docs/spring-data-jpa/current/api/org/springframework/data/jpa/domain/AbstractPersistable.html" target="_blank">AbstractPersistable</a>-luokkaa käytettäessä ylläolevan luokan määrittely kutistuu hieman. Yläluokka AbstractPersistable määrittelee pääavaimen, jonka lisäksi luokka toteuttaa myös rajapinnan Serializable. </p>

<pre class="sh_java">
// pakkaus ja importit

@Entity
@Table(name = "Henkilo")
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    @Column(name = "nimi")
    private String nimi;
    // getterit ja setterit</pre>

            <p>Jos tietokantataulun ja sarakkeiden annotaatioita ei eksplisiittisesti määritellä, niiden nimet päätellään luokan ja muuttujien nimistä.</p>

<pre class="sh_java">
// pakkaus ja importit

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    // getterit ja setterit</pre>


            <h2>Transaktioiden hallinta</h2>

	    <p>Transaktioiden avulla varmistetaan, että joko kaikki halutut operaatiot suoritetaan, tai yhtäkään niistä ei suoriteta.</p>

            <p>Tietokantatransaktiot määritellään metodi- tai luokkatasolla annotaation <code>@Transactional</code> avulla. Annotaatiolla <code>@Transactional</code> merkittyä metodia suoritettaessa metodin alussa aloitetaan tietokantatransaktio, jossa tehdyt muutokset viedään tietokantaan metodin lopussa. Jos annotaatio <code>@Transactional</code> määritellään luokkatasolla, se koskee jokaista luokan metodia.</p>

	    <p>Alla on kuvattuna tilisiirto, joka on ehkäpä klassisin transaktiota vaativa tietokantaesimerkki. Jos ohjelmakoodin suoritus epäonnistuu (esim. päätyy poikkeukseen) sen jälkeen kun toiselta tililtä on otettu rahaa, mutta toiselle sitä ei vielä ole lisätty, peruuntuu myös rahan ottaminen tililtä. Jos metodille ei olisi määritelty <code>@Transactional</code>-annotaatiota, rahat katoaisivat.</p>

<pre class="sh_java">
@Transactional
public void siirraRahaa(Long tililta, Long tilille, Double paljonko) {
    Tili mista = tiliRepository.findOne(tililta);
    Tili minne = tiliRepository.findOne(tilille);

    mista.setSaldo(mista.getSaldo() - paljonko);
    minne.setSaldo(minne.getSaldo() + paljonko);
}</pre>


            <p>Annotaatiolle <code>@Transactional</code> voidaan määritellä parametri <code>readOnly</code>, jonka avulla määritellään kirjoitetaanko muutokset tietokantaan. Jos parametrin <code>readOnly</code> arvo on <code>true</code>, metodiin liittyvä transaktio perutaan metodin lopussa (rollback). Tällöin metodi ei yksinkertaisesti voi muuttaa tietokannassa olevaa tietoa. </p>

            <p>Rajapinnalla <code>JpaRepository</code> on määriteltynä transaktiot luokkatasolle. Tämä tarkoittaa sitä, että yksittäiset tallennusoperaatiot toimivat myös ilman <code>@Transactional</code>-annotaatiota.</p>

	    <h3>Entiteettien hallinta</h3>

	    <p>Jos metodille on määritelty annotaatio <code>@Transactional</code>, pitää JPA kirjaa tietokannasta ladatuista entiteeteistä ja tarkastelee niihin tapahtuvia muutoksia. Muutokset viedään tietokantaan metodin suorituksen lopussa. Aiempi esimerkkimme siis tekee suorittaa tilisiirrot vaikka tilejä ei erikseen tallennettaisi.</p>

<pre class="sh_java">
@Transactional
public void siirraRahaa(Long tililta, Long tilille, Double paljonko) {
    Tili mista = tiliRepository.findOne(tililta);
    Tili minne = tiliRepository.findOne(tilille);

    mista.setSaldo(mista.getSaldo() - paljonko);
    minne.setSaldo(minne.getSaldo() + paljonko);
}</pre>

	    <p>Jos taas annotaatiota <code>@Transactional</code> ei olisi määritelty, tulisi tilit erikseen tallentaa, jotta niihin tapahtuneet muutokset vietäisiin tietokantaan.</p>


<pre class="sh_java">
public void siirraRahaa(Long tililta, Long tilille, Double paljonko) {
    Tili mista = tiliRepository.findOne(tililta);
    Tili minne = tiliRepository.findOne(tilille);

    mista.setSaldo(mista.getSaldo() - paljonko);
    minne.setSaldo(minne.getSaldo() + paljonko);

    tiliRepository.save(mista);
    tiliRepository.save(minne);
}</pre>



            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-banktransfer">
                      Bank Transfer
                    </a>
                  </h1>
                </header>
                <div id="t-banktransfer" class="collapse">
		  
                  <p>Sovelluksessa on valmiina yksinkertainen sovellus tilien hallintaan ja tilisiirtojen tekemiseen. Sovelluksen tilisiirtotoiminnallisuudessa on kuitenkin vielä jonkin verran viilattavaa.</p>

		  <p>Pohdi minkälaisia korjauksia tilisiirtotoiminnallisuus tarvitsee ja toteuta ne. Kerro myös tehtävän palautuksen yhteydessä tekemäsi korjaukset.</p>

                  <p>Kun olet valmis, lähetä sovellus TMC:lle.</p>
                </div>
              </div>
	    </div>





            <h2>Viitteet tietokantataulujen välillä</h2>

            <p>Luokkien -- tai tietokantataulujen -- väliset viittaukset tapahtuvat kuten normaalistikin, mutta ohjelmoijan tulee lisäksi määritellä osallistumisrajoitteet. Osallistumisrajoitteet -- yksi moneen (<em>one to many</em>), moni yhteen (<em>many to one</em>), moni moneen (<em>many to many</em>) lisätään annotaatioiden avulla. Luodaan esimerkiksi luokka <code>Henkilo</code>, joka voi omistaa joukon esineitä. Kukin esine on vain yhden henkilön omistama -- suhde siis yksi moneen -- annotaatio <code>@OneToMany</code>.</p>

<pre class="sh_java">
@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    @OneToMany
    private List&lt;Esine&gt; esineet;


    // ...
    public List&lt;Esine&gt; getEsineet() {
        if (this.esineet == null) {
            this.esineet = new ArrayList&lt;&gt;();
        }

        return this.esineet;
    }
    // ...
</pre>

            <p>Yllä olevaa esimerkkiä käytettäessä luokalle <code>Esine</code> luodaan tietokantatauluun automaattisesti sarake, johon tallennetaan omistavan <code>Henkilo</code>-olion yksilöivä tunnus. Esinelista luodaan tarvittaessa jos sitä ei ole jo olemassa.</p>
	    

            <p>Moni-moneen yhteys tapahtuu tietokantatauluja suunniteltaessa liitostaulun avulla. JPA:ssa moni-moneen yhteydet määritellään annotaatiolla <code>@ManyToMany</code>. Tällöin yhteys tulee merkitä kummallekin puolelle. Jos henkilö voi omistaa useita esineitä, ja esineellä voi olla useita omistajia, toteutus on seuraavanlainen.</p>

            <pre class="sh_java">
@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    @ManyToMany
    private List&lt;Esine&gt; esineet;
    ...</pre>

                <pre class="sh_java">
@Entity
public class Esine extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    private Double paino;
    @ManyToMany(mappedBy = "esineet")
    private List&lt;Henkilo&gt; omistajat;</pre>

            <p>Yllä oleva määritelmä luo liitostaulun Esine- ja Henkilo-taulujen välille. Esine-luokassa olevassa @ManyToMany-annotaatiossa oleva parametri <code>mappedBy = "esineet"</code> kertoo että Esine-luokan <code>omistajat</code>-lista saadaan liitostaulusta, ja että se kytketään luokan Henkilo listaan <code>esineet</code>.</p>

	    <aside class="info">
	      <br/>
	      <h1>@OneToMany ja @ManyToMany -annotaatiot</h1>

	      <p>Kun kirjoitat NetBeansissa viitteen entiteettiluokasta toiseen, NetBeans kysyy viittauksen tyyppiä. Tutustu tähän toiminnallisuuteen, sillä se helpottaa annotaatioiden määrittelyä.</p>

	    </aside>




            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-simplebanking">
                      Simple Banking
                    </a>
                  </h1>
                </header>
                <div id="t-simplebanking" class="collapse">
		  
                  <p>Sovelluksessa on toteutettuna entiteetit tilien ja asiakkaiden hallintaan, mutta niiden väliltä puuttuu kytkös. Muokkaa sovellusta siten, että asiakkaalla voi olla monta tiliä, mutta jokaiseen tiliin liittyy tasan yksi asiakas.</p>
		  
		  <p>Tilin lisäämisen tulee kytkeä tili myös asiakkaaseen. Alla olevassa esimerkissä tietokannassa on kaksi asiakasta ja kolme tiliä.</p>
		  
                  <p><img class="browser-img" src="img/2016-mooc/ex24.png"/></p>
		  
                  <p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
                </div>
              </div>
	    </div>


	    <h2>Transaktiot ja viitteiden automaattinen hallinta</h2>

            <p>Haluamme usein tallentaa olion joka viittaa olioon, josta viitataan takaisin.</p>

            <p>Pohditaan tätä kontekstissa, jossa tavoitteena on lisätä uusia Henkilo-olioita olemassaolevan esineen omistajiksi. Esineellä on lista sen omistajista. Yksi ratkaisu on seuraava. </p>

<pre class="sh_java">
@Transactional
public void lisaaOmistaja(Long henkiloId, Long esineId) {
    Esine esine = esineRepository.findOne(esineId);
    Henkilo henkilo = henkiloRepository.findOne(henkiloId);

    henkilo.getEsineet().add(esine);
    esine.getOmistajat().add(henkilo);
}</pre>

            <p>Koska ylläolevassa esimerkissä koodi suoritetaan transaktion sisällä, ladattuihin olioihin tehdyt muutokset viedään tietokantaan transaktion lopussa.</p>

            <h3>Olemassaolevan olion poistaminen</h3>


            <p>Pohditaan seuraavaksi tilannetta, jossa haluaisimme poistaa tietyn henkilön. Ensimmäinen hahmotelma on kutakuinkin seuraavanlainen:</p>

<pre class="sh_java">
@Transactional
public void remove(Long henkiloId) {
    personRepository.delete(henkiloId);
}</pre>

            <p>Yllä ongelmana on kuitenkin se, että esineet eivät kadota viittausta henkilöön. Käytännössä henkilö jää "haamuksi" järjestelmään tai saamme virheen poistoa yrittäessä. Jos haluamme poistaa viittaukset henkilöön, joudumme tekemään sen käsin.</p>

                <pre class="sh_java">
@Transactional
public void remove(Long henkiloId) {
    Henkilo henkilo = personRepository.findOne(henkiloId);
    
    for (Esine esine: henkilo.getEsineet()) {
        esine.getOmistajat().remove(henkilo);
    }

    personRepository.delete(person);
}</pre>

	    <p>Ei kovin nättiä. </p>


            <h2>Omien kyselyiden toteuttaminen</h2>
	    
            <p>Spring Data JPA ei tarjoa kaikkia kyselyitä valmiiksi. Uudet kyselyt, erityisesti attribuuttien perusteella tapahtuvat kyselyt, tulee määritellä erikseen. Laajennetaan aiemmin määriteltyä rajapintaa <code>HenkiloRepository</code> siten, että sillä on metodi <code>List&lt;Henkilo&gt; findByNimi(String nimi)</code> -- eli hae henkilöt, joilla on tietty nimi.</p>


<pre class="sh_java">
// pakkaus

import org.springframework.data.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    List&lt;Henkilo&gt; findByNimi(String nimi);
}</pre>

            <p>Ylläoleva esimerkki on esimerkki kyselystä, johon ei tarvitse erillistä toteutusta. Koska tietokantataululla on valmis sarake nimi, arvaa Spring Data JPA että kysely olisi muotoa <code>SELECT * FROM Henkilo WHERE nimi = :nimi</code> ja luo sen valmiiksi. Lisää Spring Data JPA:n kyselyistä löytyy sen <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation" target="_blank">dokumentaatiosta</a>.</p>

            <aside class="info">
	      <br/>
	      
              <h1>Kyselyt Java Persistence Apin kautta</h1>
	      
              <p>Java Persistence APIn kautta tehdyt kyselyt eivät ole natiivia SQL:ää, vaan seuraavat JPQL-määritelmää (Java Persistence Query Language), joka kuitenkin muistuttaa SQL:ää. JPQL-kielestä löytyy lisää tietoa osoitteesta <a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html" target="_blank">http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html</a>.</p>

            </aside>


            <p>Tehdään toinen esimerkki, jossa joudumme oikeasti luomaan oman kyselyn. Lisätään rajapinnalle <code>HenkiloRepository</code> metodi <code>findJackBauer</code>, joka suorittaa kyselyn <code>"SELECT h FROM Henkilo h WHERE h.nimi = 'Jack Bauer'"</code>.</p>


<pre class="sh_java">
// pakkaus

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    List&lt;Henkilo&gt; findByNimi(String nimi);
    @Query("SELECT h FROM Henkilo h WHERE h.nimi = 'Jack Bauer'")
    Henkilo findJackBauer();
}</pre>

            <p>Käytössämme on nyt myös metodi <code>findJackBauer</code>, joka suorittaa <code>@Query</code>-annotaatiossa määritellyn kyselyn. Tarkempi kuvaus kyselyiden määrittelystä osana rajapintaa löytyy Spring Data JPAn <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query" target="_blank">dokumentaatiosta</a>.</p>





            <h2>Viitattujen olioiden noutaminen tietokannasta</h2>

            <p>Tietokanta-abstraktioita tarjoavat komponentit kuten Hibernate päättävät mitä tehdään haettavaan olioon liittyville viitteille. Yksi vaihtoehto on hakea viitatut oliot automaattisesti kyselyn yhteydessä ("Eager"), toinen vaihtoehto taas on hakea viitatut oliot vasta kun niitä pyydetään eksplisiittisesti esimerkiksi get-metodin kautta ("Lazy").</p>

            <p>Tyypillisesti one-to-many ja many-to-many -viitteet haetaan vasta niitä tarvittaessa, ja one-to-one ja many-to-one viitteet heti. Oletuskäyttäytymistä voi muuttaa <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/FetchType.html" target="_blank">FetchType</a>-parametrin avulla. Esimerkiksi alla ehdotamme, että <code>asunnot</code>-lista noudetaan heti.</p>

<pre class="sh_java">
// pakkaus

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;

    // oletamme, että Asunto-entiteetti on olemassa
    @OneToMany(fetch=FetchType.EAGER)
    @JoinColumn 
    private List&lt;Asunto&gt; asunnot; 

    // getterit ja setterit
}
</pre>

            <p>Käytännössä tietokannasta tarvittaessa haku toteutetaan muokkaamalla get-metodia siten, että tietokantakysely tapahtuu metodia kutsuttaessa. Staattisesti tyypitetyissä ohjelmointikielissä tämä käytännössä vaatii sitä, että luokkien rakennetta muutetaan joko ajonaikaisesti tai lähdekooditiedostojen kääntövaiheessa -- käyttämämme komponentit tekevät tämän puolestamme.</p>




            <aside class="info">
	      
	      <br/>
	      
              <h1>N+1 Kyselyn ongelma</h1>
	      
              <p>Viitattujen olioiden lataaminen vasta niitä tarvittaessa on yleisesti ottaen hyvä idea, mutta sillä on myös kääntöpuolensa. Pohditaan tilannetta, missä kirjalla voi olla monta kirjoittajaa, ja kirjoittajalla monta kirjaa -- <code>@ManyToMany</code>. Jos haemme tietokannasta listan kirjoja (1 kysely), ja haluamme tulostaa kirjoihin liittyvät kirjoittajat, tehdään jokaisen kirjan kohdalla erillinen kysely kyseisen kirjan kirjoittajille (n kyselyä). Tätä ongelmaa kutsutaan N+1 -kyselyn ongelmaksi.</p>
		  
              <p>Jos kirjoja tarvitaan sekä ilman kirjoittajaa että kirjoittajan kanssa, on FetchType-parametrin asettaminen <code>EAGER</code>-tyyppiseksi yksi vastaus. Tällöin kuitenkin osassa tapauksista haetaan ylimääräistä dataa tietokannasta. Toinen vaihtoehto on luoda erillinen kysely yhdelle vaihtoehdoista, ja lisätä kyselyyn vinkki (<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-hints" target="_blank">Spring Data JPA, applying query hints</a>) kyselyn toivotusta toiminnallisuudesta.</p>

            </aside>
		

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-lentokentat">
                      Airports and aircrafts
                    </a>
                  </h1>
                </header>
                <div id="t-lentokentat" class="collapse">
		  
                  <p>Jatkokehitetään tässä tehtävässä sovellusta lentokoneiden ja lentokenttien hallintaan. Projektissa on jo valmiina ohjelmisto, jossa voidaan lisätä ja poistaa lentokoneita. Tavoitteena on lisätä toiminnallisuus lentokoneiden kotikenttien asettamiseksi.</p>
		  
                  <h1>Tallennettavat: <code>Aircraft</code> ja <code>Airport</code>.</h1>
		  
                  <p>Lisää luokkaan <code>Aircraft</code> attribuutti <code>airport</code>, joka kuvaa lentokoneen kotikenttää, ja on tyyppiä <code>Airport</code>. Koska usealla lentokoneella voi olla sama kotikenttä, käytä attribuutille <code>airport</code> annotaatiota <code>@ManyToOne</code>. Lisää attribuutille myös <code>@JoinColumn</code>-annotaatio, jonka avulla kerrotaan että tämä attribuutti viittaa toiseen tauluun. Lisää luokalle myös oleelliset get- ja set-metodit.</p>
		  
                  <p>Lisää seuraavaksi <code>Airport</code>-luokkaan attribuutti <code>aircrafts</code>, joka kuvaa kaikkia koneita, keiden kotikenttä kyseinen kenttä on, ja joka on tyyppiä <code>List&lt;Aircraft&gt;</code>. Koska yhdellä lentokentällä voi olla useita koneita, lisää attribuutille annotaatio <code>@OneToMany</code>. Koska luokan <code>Aircraft</code> attribuutti <code>airport</code> viittaa tähän luokkaan, aseta annotaatioon <code>@OneToMany</code> parametri <code>mappedBy="airport"</code>. Nyt luokka <code>Airport</code> tietää että attribuuttiin <code>aircrafts</code> tulee ladata kaikki <code>Aircraft</code>-oliot, jotka viittaavat juuri tähän kenttään.</p>
		  
                  <p>Lisää lisäksi <code>Airport</code>-luokan <code>@OneToMany</code>-annotaatioon parametri <code>fetch = FetchType.EAGER</code>, jolloin lentokenttään liittyvät lentokoneet haetaan kyselyn yhteydessä.</p>
		  
                  <p>Lisää lopuksi luokalle <code>Airport</code> oleelliset get- ja set-metodit.</p>
		  
		  
                  <h1>Lentokentän asetus lentokoneelle</h1>
		  
                  <p>Lisää sovellukselle toiminnallisuus lentokentän lisäämiseen lentokoneelle. Käyttöliittymä sisältää jo tarvittavan toiminnallisuuden, joten käytännössä sinun tulee toteuttaa luokalle <code>AircraftController</code> metodi <code>String assignAirport</code>. Kun käyttäjä lisää lentokoneelle lentokenttää, käyttöliittymä lähettää POST-tyyppisen kyselyn osoitteeseen <code>/aircrafts/{aircraftId}/airports</code>, missä <code>aircraftId</code> on lentokoneen tietokantatunnus. Pyynnön mukana tulee lisäksi parametri <code>airportId</code>, joka sisältää lentokentän tietokantatunnuksen.</p>
		  
                  <p>Toteuta metodi siten, että haet aluksi pyynnössä saatuja tunnuksia käyttäen lentokoneen ja lentokentän, tämän jälkeen asetat lentokoneelle lentokentän ja lentokentälle lentokoneen, ja lopuksi tallennat haetut oliot.</p>
		  
                  <p>Ohjaa lopuksi pyyntö osoitteeseen <code>/aircrafts</code></p>
		  
                  <p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
                </div>
              </div>
	      
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-elokuvatietokanta">
                      Movie database
                    </a>
                  </h1>
                </header>
                <div id="t-elokuvatietokanta" class="collapse">
		  
                  <p>Tämä on avoin tehtävä jossa saat itse suunnitella huomattavan osan ohjelman sisäisestä rakenteesta. Ainoat määritellyt asiat ohjelmassa ovat käyttöliittymä ja domain-oliot, jotka tulevat tehtäväpohjan mukana. Tehtäväpohjassa on myös valmis konfiguraatio.</p>
		  
                  <p>Tehtävästä on mahdollista saada yhteensä 4 pistettä.</p>
		  
                  <p>Huom! Kannattanee aloittaa näyttelijän lisäämisestä ja poistamisesta. Suunnittele ensin sopiva tietokantaolio, sekä sille sopivat repository-oliot. Jatka tämän jälkeen kontrollerin toteutuksella -- sekä mahdollisesti palvelukerroksen lisäämisellä. Kannattanee hyödyntää valmiiksi tarjotuissa käyttöliittymätiedostoissa olevaa koodia osana tietokantaolioiden attribuuttien määrittelyä.</p>
		  
                  <h1>pisteytys</h1>
		  
                  <ol class="pisteytys">
                    <li>+ 1p: Näyttelijän lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                      <ul>
                        <li><code>GET /actors</code> - näyttelijöiden listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>actors</code>, joka sisältää kaikki näyttelijät ja luo sivun <code>/src/main/resources/templates/actors.html</code> pohjalta näkymän.</li>
			
                        <li><code>POST /actors</code> - parametri <code>name</code>, jossa on lisättävän näyttelijän nimi. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
			
                        <li><code>DELETE /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää poistettavan näyttelijän tunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                      </ul>
                    </li>
		    
                    <p></p>
		    
                    <li>+ 1p: Elokuvan lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                      <ul>
                        <li><code>GET /movies</code> - elokuvien listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>movies</code>, joka sisältää kaikki elokuvat ja luo sivun <code>/src/main/resources/templates/movies.html</code> pohjalta näkymän.</li>
			
                        <li><code>POST /movies</code> - elokuvan lisäys, parametrit <code>name</code>, joka sisältää lisättävän elokuvan nimen, ja <code>lengthInMinutes</code>, joka sisältää elokuvan pituuden minuuteissa. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>
			
                        <li><code>DELETE /movies/{movieId}</code> - polun parametri <code>movieId</code>, joka sisältää poistettavan elokuvan tietokantatunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>
                      </ul>
                    </li>
		    
                    <p></p>
		    
                    <li>+ 2p: Näyttelijän voi lisätä elokuvaan (kun näyttelijä tai elokuva poistetaan, tulee myös poistaa viitteet näyttelijästä elokuvaan ja elokuvasta näyttelijään). Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                      <ul>
			
                        <li><code>GET /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää näytettävän näyttelijän tietokantatunnuksen. Asettaa pyyntöön sekä attribuutin <code>actor</code> jossa näyttelijä-olio että attribuutin <code>movies</code>, jossa kaikki elokuvat, sekä luo sivun <code>/src/main/resources/templates/actor.html</code> pohjalta näkymän.</li>
			
                        <li><code>POST /actors/{actorId}/movies</code> - polun parametri <code>actorId</code>, joka sisältää kytkettävän näyttelijän tietokantatunnuksen, ja parametri <code>movieId</code>, joka sisältää kytkettävän elokuvan tietokantatunnuksen. Lisäämisen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                      </ul>
                    </li>
                  </ol>
                </div>
              </div>
            </div>
	    
	    

            <h2>Tietokantakyselyn tulosten järjestäminen ja rajoittaminen</h2>

            <p>Tietokantakyselyn tulokset halutaan usein hakea tai järjestää tietyn kriteerin mukaan. Jos tietokantadatan läpikäynti toteutettaisiin osana palvelua, tekisimme oikeastaan juuri sen työn, missä tietokannat loistavat.</p>

            <p>Esimerkiksi alla oleva lisäys tarjoaa metodin henkilöiden etsimiseen, joilla ei ole huonetta (oletamme että Henkilo-luokalla on attribuutti Asunto).</p>

<pre class="sh_java">
public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    List&lt;Henkilo&gt; findByAsuntoIsNull();
}</pre>

            <p>Vastaavasti voisimme hakea esimerkiksi nimen osalla: <code>findByNimiContaining(String osa)</code>.</p>

            <p>Spring Data JPAn rajapinta <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">JpaRepository</a> mahdollistaa muutaman lisäparametrin käyttämisen osassa pyyntöjä. Voimme esimerkiksi käyttää parametria <a href="http://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/PageRequest.html" target="_blank">PageRequest</a>, joka tarjoaa apuvälineet sivuttamiseen sekä pyynnön hakutulosten rajoittamiseen. Alla olevalla PageRequest-oliolla haluasimme ensimmäiset 50 hakutulosta attribuutin nimi mukaan käänteisessä järjestyksessä.</p>

<pre class="sh_java">
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "nimi");</pre>

            <p>Voimme muokata metodia <code>findByAsuntoIsNull</code> hyväksymään <code>Pageable</code>-rajapinnan toteuttavan olion parametriksi, jolloin metodi palauttaa <a href="http://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/api/org/springframework/data/domain/Page.html" target="_blank">Page</a>-luokan ilmentymän.</p>

<pre class="sh_java">
public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    Page&lt;Henkilo&gt; findByAsuntoIsNull(Pageable pageable);
}</pre>

            <p>Yhdistämällä kaksi edellistä, voisimme hakea kaikki huoneettomat henkilöt sopivasti järjestettynä:</p>

<pre class="sh_java">
//...
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
//...

    // tämä palvelussa
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "nimi");
    Page&lt;Henkilo&gt; henkiloSivu = henkiloRepository.findByAsuntoIsNull(pageable);
    List&lt;Henkilo&gt; henkilot = henkiloSivu.getContent();
</pre>



            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-viimeisetviestit">
                      Last Messages
                    </a>
                  </h1>
                </header>
                <div id="t-viimeisetviestit" class="collapse">
		  
                  <p>Tehtävässä on käytössä viestien lähetykseen käytettävä sovellus. Muokkaa sovellusta siten, että MessageServicen <code>list</code>-metodi palauttaa aina vain uusimmat 10 viestiä. Käytä tässä hyödyksi yllä nähtyä Pageable-oliota.</p>
		  
                </div>
              </div>
            </div>
	    

	    
	    <h2>Muita tietokantapalveluita</h2>

	    <p>Web-sovelluksissa käytetään tiedon tallentamiseen erilaisia tietokantapalveluita, joista merkittävimpiä ovat relaatiomalliin perustuvat relaatiotietokannat. Tietokantoja on toki myös muunlaisia: muita vaihtoehtoja ovat esimerkiksi NewSQL-tietokannat, jotka yhdistelevät avain-arvo -tietokantojen ja relaatiotietokantojen hyviä puolia, verkkotietokannat, joissa paljon yhteyksiä sisältävän tiedon hakeminen ja tallentaminen on tehokkaampaa, sekä erilaiset verkossa toimivat palvelut kuten <a href="https://www.firebase.com/" target="_blank">Firebase</a>.</p>

	    <p>Tutustutaan seuraavassa tehtävässä pikaisesti <a href="https://www.firebase.com/" target="_blank">Firebase</a>en. Firebase tarjoaa sovelluskehittäjille ilmaisen paikan tiedon tallentamiseen sovelluksen kehitysvaiheessa. Firebasen oleelliset kirjastot saa projektin käyttöön kun lisää <code>pom.xml</code> -tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.firebase&lt;/groupId&gt;
    &lt;artifactId&gt;firebase-client-jvm&lt;/artifactId&gt;
    &lt;version&gt;2.5.2&lt;/version&gt;
&lt;/dependency&gt;
</pre>

	    <p>Firebaseen tallennettavat resurssit liittyvät aina tiettyyn osoitteeseen sekä osoitteen alla olevaan polkuun. Tämän osion viimeisessä tehtävässä on valmiiksi toteutettuna luokka, jonka avulla Firebaseen voi tehdä kyselyitä -- hauskaa tutustumista!</p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellofirebase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellofirebase">
                      Hello Firebase
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellofirebase" class="collapse">
		  
		  <p>Tässä tehtävässä on valmiiksi toteutettuna esineiden tallentaminen ja noutaminen Firebase-palvelusta. Tutustu ensin sovelluksen toimintaan ja kokeile tiedon hakemista ja tallentamista. Huomaat myös, että tieto ei katoa, vaikka käynnistät palvelinohjelmiston uudestaan.</p>
		  
		  <p>Toteuta tehtävässä toiminnallisuus esineiden poistamiseen ja muokkaamiseen. Poistamisen tulee poistaa esine Firebase-palvelusta (luokassa FirebaseService on valmis toiminnallisuus tähän) ja muokkaamisen tulee avata uusi sivu, jossa esineen nimeä voi muuttaa. Voit tehdä konkreettisen muokkaustoiminnallisuuden vaikkapa siten, että poistat vanhan esineen muokkauksen yhteydessä ja lisäät uuden esineen vanhaan esineeseen liittyvillä muokatuilla tiedoilla.</p>
		  
		  <p>Kuten muutamassa aiemmassakin tehtävässä, tässä tehtävässä ei ole testejä. Palauttaessasi tehtävän palvelimelle kerrot tehneesi sen valmiiksi. Testit on jätetty tästä pois, jotta voit luoda oman Firebase-palvelun ja käyttää myös sitä.</p>

		  <p>Kun olet saanut tehtävän valmiiksi, tarkastele vielä sovelluksen rakennetta. Huomaat toivottavasti, että vaikka tallennuslogiikka on muuttunut, niin sen perusosat eivät poikkea merkittävästi muista sovelluksistamme.</p>


                </div>
              </div>
            </div>



          </section>
	  <!-- END OSA2 -->

	  <!-- BEGIN OSA3 -->
          <section class="weeklimit" data-week-id="3">
	    
            <header>
              <h1 id="osa3">Osa 3</h1>
            </header>

	    <p>Aloitamme taas edellisen viikon kertauksella ja tutustumme samalla ajan tallentamiseen tietokantaan. Tämän jälkeen tarkastelemme HTTP-protokollan tilattomuuden hyötyjä ja haittoja sekä tutustumme evästeiden käyttöön. Evästeiden avulla voidaan kiertää tilattomuuteen liittyviä rajoitteita. Tämän jälkeen tutustumme konfiguraatioprofiileihin, joiden avulla testaus- ja kehityskäytössä oleva sovellus voi käyttää erilaisia asetuksia kuin tuotantokäytössä oleva sovellus. Osion lopuksi tutustutaan web-sovellusten automaatiseen testaamiseen.</p>



            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa2-kertaus-ex" data-count="30">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa2-kertaus">
                      Osa 2, kertaus: Exams and Questions
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa2-kertaus" class="collapse">
		  
		  <p>Toisessa kertaustehtävässä tehtävänäsi on täydentää kokeiden ja koekysymysten hallintaan tarkoitettua sovellusta. Sovellukseen on toteutettu valmiiksi rungot kokeiden ja koekysymysten lisäämiseen tarvittaviin kontrollereihin, jonka lisäksi sovelluksessa on osittain valmiina tarvitut <code>Exam</code> ja <code>Question</code> -entiteetit.</p>

		  <p>Lisää sovellukseen tarvittavat Repository-rajapinnat ja täydennä Exam- ja Question-entiteettejä niin, että yhteen kokeeseen monta kysymystä ja yksi kysymys voi liittyä useampaan kokeeseen. Toteuta myös kontrollereille tarvittavat metodit ja toiminnallisuudet -- saat näitä selville HTML-sivuja tarkastelemalla. </p>

                </div>
              </div>
	    </div>


	    <h2>Muutama sana ajan tallentamisesta tietokantaan</h2>
	    
            <p>Aikaa kuvaavat attribuutit tulee annotoida <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Temporal.html" target="_blank">@Temporal</a></code>-annotaatiolla, joka määrittelee mikä osa ajasta tallennetaan. Annotaatiolle annetaan parametrina <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/TemporalType.html" target="_blank">TemporalType</a></code>-tyyppinen arvo, joka kertoo tarkemman tallennusmuodon. Arvo <code>TemporalType.DATE</code> tallentaa päivämäärän (esim. 2012-09-15), <code>TemporalType.TIME</code> tallentaa kellonajan (esim. 18:00:00), ja arvo <code>TemporalType.TIMESTAMP</code> tallentaa päivän ja ajan (esim. 2012-09-15 18:00:00).</p>

            <p>Annotaatiolla <code>@Temporal</code> merkityn attribuutin tulee olla joko tyyppiä <code>java.util.Date</code> tai tyyppiä <code>java.util.Calendar</code>. Alla on määritelty entiteettiluokka <code>GroceryItem</code>, joka kuvaa elintarviketta. Elintarvikkeella on myös parasta ennen-päivämäärä (bestBefore).</p>

<pre class="sh_java">
// pakkaus ja importit

@Entity
public class GroceryItem extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @Temporal(TemporalType.DATE)
    private Date bestBefore;

    // getterit ja setterit
}</pre>

	    <p>Aikamääreitä voi lähettää myös sovelluksesta palvelimelle. Tällöin kontrollerissa tulee määritellä tapa aikaa kuvaavan merkkijonon muuntamiseen. Exams and Questions -sovelluksessa oli käytössä <code>@DateTimeFormat</code>-annotaatio, joka toimii juurikin merkkijonon muuntamiseen.</p>

<pre class="sh_java">
public String addExam(@RequestParam String subject,
            @RequestParam @DateTimeFormat(pattern = "yyyy-MM-dd") Date examDate) {
...
</pre>

	    <p>Edellä oleva hahmo <code>yyyy-MM-dd</code> olettaa, että palvelimelle lähetetään aika merkkijonona, jossa on ensin vuosi (4 numeroa), sitten viiva, sitten kuukausi (2 numeroa), sitten viiva, ja lopulta päivä (2 numeroa). Tämä muoto liittyy <a href="https://tools.ietf.org/html/rfc3339#section-5.6" target="_blank">RFC3339-spesifikaatioon</a>, joka määrittelee muodon, mitä päivämäärissä <em>pitäisi</em> käyttää kun tietoa lähetetään palvelimelle. Spesifikaation takia voimme olettaa (tai toivoa), että esimerkiksi HTML:n <a href="https://www.w3.org/TR/html-markup/input.date.html" target="_blank">date</a>-elementtiin syötettävä päivämäärä lähetetään palvelimelle em. muodossa.</p>


	    
            <h1 data-count="5">HTTP-protokollan tilattomuus ja evästeet</h1>

            <p>HTTP on tilaton protokolla. Tämä tarkoittaa sitä, että HTTP:n näkökulmasta jokainen pyyntö on erillinen kokonaisuus, joka ei liity aiempiin pyyntöihin. Suunnittelupäätöksen taustalla oli se, että internetissä sisältöä voidaan hakea useammasta sijainnista, jolloin tilan ylläpito olisi ollut turhan hidasta (<a href="https://www.w3.org/Protocols/HTTP/HTTP2.html" target="_blank">Basic HTTP as defined in 1992</a>). Päätös tilattomuudesta oli alunperin hyvä: suurin osa verkkoliikenteestä liittyy staattisen sisällön hakemiseen, palvelinten ei tarvitse varata resursseja käyttäjän tilan ylläpitämiseen, ja palvelinten ja selainohjelmistojen toteuttajien ei tarvinnut toteuttaa mekanismeja käyttäjien tilan ylläpitämiseen.</p>

	    <p>Käyttäjän tunnistamiseen pyyntöjen välillä on kuitenkin tarvetta. Esimerkiksi verkkokaupat ja muut käyttäjän kirjautumista vaativat palvelut tarvitsevat tavan käyttäjän tunnistamiseen. Klassinen -- mutta huono -- tapa kiertää HTTP:n tilattomuus on ollut säilyttää GET-muotoisessa osoitteessa parametreja, joiden perusteella asiakas voidaan tunnistaa palvelinsovelluksessa. Tämä ei kuitenkaan ole suositeltavaa, sillä osoitteessa olevia parametreja voi muokata käsin, ja ne saattavat jättää sovellukseen ylimääräisiä tietoturva-aukkoja (palaamme tietoturvaan myöhemmin).</p>

            <aside class="info">
	      
	      <br/>

              <h1>Case: GET-parametri tunnistautumiseen</h1>
	      
              <p>Eräässä järjestelmässä verkkokaupan toiminnallisuus oli toteutettu siten, että GET-parametrina säilytettiin numeerista ostoskorin identifioivaa tunnusta. Käyttäjäkohtaisuus oli toteutettu palvelinpuolella siten, että tietyllä GET-parametrilla näytettiin aina tietyn käyttäjän ostoskori. Uusien tuotteiden lisääminen ostoskoriin onnistui helposti, sillä pyynnöissä oli aina mukana ostoskorin tunnistava GET-parametri. Ostoskorit oli valitettavasti identifioitu juoksevalla numerosarjalla. Henkilöllä 1 oli ostoskori 1, henkilöllä 2 ostoskori 2 jne..</p>
	      <p>Koska käytännössä kuka tahansa pääsi katsomaan kenen tahansa ostoskoria vain osoitteessa olevaa numeroa vaihtamalla, olivat ostoskorien sisällöt välillä hyvin mielenkiintoisia.</p>

            </aside>
		
            <p>HTTP-protokollan tilattomuus ei pakota palvelinohjelmistoja tilattomuuteen. Palvelimella tilaa pidetään yllä jollain tavalla tekniikalla, joka ei näy HTTP-protokollaan asti. Yleisin tekniikka tilattomuuden kiertämiseen on evästeiden käyttö.</p>


            <h2>HTTP ja evästeet</h2>

            <p>Merkittävä osa verkkosovelluksista sisältää käyttäjäkohtaista toiminnallisuutta, jonka toteuttamiseen sovelluksella täytyy olla jonkinlainen tieto käyttäjästä sekä mahdollisesti käyttäjän tilasta. HTTP/1.1 tarjoaa mahdollisuuden tilallisten verkkosovellusten toteuttamiseen evästeiden (<em>cookies</em>) avulla.</p>
	    
            <p>Asettamalla käyttäjän tekemän pyynnön vastaukseen eväste, tulee käyttäjän jatkossa pyyntöä tehdessä aina palauttaa kyseinen eväste pyynnön otsaketietoina. Tämä tapahtuu automaattisesti selaimen toimesta. Evästeitä käytetään istuntojen (<em>session</em>) ylläpitämiseen: istuntojen avulla pidetään kirjaa käyttäjästä useampien pyyntöjen yli.</p>

            <p>Evästeet toteutetaan otsakkeiden avulla. Kun käyttäjä tekee pyynnön palvelimelle, ja palvelimella halutaan asettaa käyttäjälle eväste, palauttaa palvelun vastauksen mukana otsakkeen <code>Set-Cookie</code>, jossa määritellään käyttäjäkohtainen evästetunnus. Set-Cookie voi olla esimerkiksi seuraavan näköinen:</p>

<pre>
Set-Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg; Max-Age=3600; Domain=".helsinki.fi"
</pre>

            <p>Ylläoleva palvelimelta lähetetty vastaus ilmoittaa pyytää selainta tallettamaan evästeen. Selaimen tulee jatkossa lisätä eväste <code>SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg</code> jokaiseen <code>helsinki.fi</code>-osoitteeseen. Eväste on voimassa tunnin, eli selain ja palvelin voi unohtaa sen tunnin kuluttua sen asettamisesta. Tarkempi syntaksi evästeen asettamiselle on seuraava:</p>

<pre>
Set-Cookie: nimi=arvo [; Comment=kommentti] [; Max-Age=elinaika sekunteina]
                      [; Expires=parasta ennen paiva] [; Path=polku tai polunosa jossa eväste voimassa]
                      [; Domain=palvelimen osoite (URL) tai osoitteen osa jossa eväste voimassa]
                      [; Secure (jos määritelty, eväste lähetetään vain salatun yhteyden kanssa)]
                      [; Version=evästeen versio]
</pre>


            <p>Evästeet tallennetaan selaimen sisäiseen evästerekisteriin, josta niitä haetaan aina kun käyttäjä tekee selaimella kyselyn. Evästeet lähetetään palvelimelle jokaisen viestin yhteydessä <code>Cookie</code>-otsakkeessa.</p>

<pre>
Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg
</pre>

            <p>Evästeiden nimet ja arvot ovat yleensä monimutkaisia ja satunnaisesti luotuja niiden yksilöllisyyden takaamiseksi. Samaan palvelinosoitteeseen voi liittyä useampia evästeitä. Yleisesti ottaen evästeet ovat sekä hyödyllisiä että haitallisia: niiden avulla voidaan luoda yksiöityjä käyttökokemuksia tarjoavia sovelluksia, mutta niitä voidaan käyttää myös käyttäjien seurantaan ympäri verkkoa.</p>
	    
            <aside class="info">
	      
	      <br/>
              
	      <h1>Evästeet hs.fi -palvelussa</h1>
	      
              <p>Painamalla F12 tai valitsemalla Tools -> Developer tools, pääset tutkimaan sivun lataamiseen ja sisältöön liittyvää statistiikkaa. Lisäneuvoja löytyy <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank">Google Developers</a> -sivustolta.</p>
	      
              <p>Avaa developer tools, ja mene osoitteeseen <a href="http://www.hs.fi" target="_blank">http://www.hs.fi</a>. Valitsemalla developer toolsien välilehden <code>Resources</code>, löydät valikon erilaisista sivuun liittyvistä resursseista. Avaa <code>Cookies</code> ja valitse vaihtoehto <code>www.hs.fi</code>. Kuinka moni palvelu pitää sinusta kirjaa kun menet Helsingin sanomien sivuille?</p>
	      
            </aside>


	    <h2>Evästeet ja sessiot</h2>

	    <p>Kun selain lähettää palvelimelle pyynnön yhteydessä evästeen, etsii palvelin evästeen perusteella käynnissä olevaa sessiota. Jos sessio löytyy, annetaan siihen liittyvät tiedot sovelluksen käyttöön. Jos sessiota taas ei löydy, voidaan selaimelle palauttaa uusi eväste ja aloittaa uusi sessio, jolloin session tiedot löytyvät jatkossa palvelimelta.</p>

	    <p>Javassa sessioiden käsittelyyn löytyy <a href="http://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpSession.html" target="_blank">HttpSession</a>-luokka, joka tarjoaa välineet sessio- ja käyttäjäkohtaisen tiedon tallentamiseen. Oleellisimmat luokan metodit ovat <code>public void setAttribute(String name, Object value)</code>, joka tallentaa sessioon arvon, sekä <code>public Object getAttribute(String name)</code>, jonka avulla kyseinen arvo löytyy.</p>

	    <p>Session saa yksinkertaisimmillaan käyttöön lisäämällä sen kontrollerimetodin parametriksi. Tällöin Spring liittää metodiin parametrin automaattisesti. Alla on kuvattuna sovellus, joka pitää sessiokohtaista kirjaa käyttäjien tekemistä pyynnöistä.</p>

<pre class="sh_java">
import javax.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class VisitCountController {
    
    @RequestMapping("*")
    @ResponseBody
    public String count(HttpSession session) {
        int visits = 0;
        if (session.getAttribute("count") != null) {
            visits = (int) session.getAttribute("count");
        }
        
        visits++;
        session.setAttribute("count", visits);
        
        return "Visits: " + visits;
    }
}
</pre>

	   
	    <p>Kun käyttäjä tekee ensimmäistä kertaa pyynnön sovellukseen, palauttaa sovellus merkkijonon "Visits: 1". Vastauksen yhteydessä palautetaan myös eväste. Kun käyttäjä tekee seuraavan kerran pyynnön sovellukseen, lähettää selain pyynnön yhteydessä myös evästeen palvelimelle, jolloin palvelin osaa tunnistaa käyttäjän ja hakee oikean istunnon tiedot -- vastaukseksi palautuu lopulta merkkijono "Visits: 2".</p>  

            <div class="tehtavat">
	      
              <div class="tehtava" id="t-hellosession-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellosession">
		      Hello Session
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellosession" class="collapse">

		  <p>Toteuta sovellus, joka palauttaa käyttäjälle merkkijonon "Hello there!" jos käyttäjä ei ole ennen vieraillut sovelluksessa. Jos käyttäjä on vieraillut sovelluksessa aiemmin, tulee sovelluksen palauttaa käyttäjälle merkkijono "Hello again!".</p>
		  
                </div>
              </div>
	    </div>
	    
	    
	    <aside class="info">

	      <br/>

	      <h1>Evästeiden ja istuntojen testaaminen selaimella</h1>
	      
	      <p>Istuntojen toiminnallisuuden testaaminen selaimella onnistuu näppärästi selainten tarjoaman anonyymitoiminnallisuuden avulla. Esimerkiksi Chromessa voi valita "New incognito window", mikä avaa käyttöön selainikkunan, missä ei aluksi ole lainkaan vanhoja evästeitä muistissa. Kun palvelimelle tehdään pyyntö, tallentuu vastauksen yhteydessä palautettava eväste selaimen muistiin vain siksi aikaa kun anonyymi-ikkuna on auki.</p>

	      <p>Session pituus riippuu esimerkiksi palvelimen asetuksista <code>session timeout</code> ja siitä, että salliiko käyttäjä evästeiden käytön.</p>

	    </aside>
	    
            <p>HttpSession-olioon pääsee käsiksi myös muualla sovelluksessa, ja sen voi injektoida esimerkiksi palveluun <code>@Autowired</code>-annotaation avulla. Edellinen kontrolleriin toteutettu toiminnallisuus voitaisiin tehdä myös palvelussa.</p>
	    
<pre class="sh_java">
// importit

@Service
public class CountService {

    @Autowired
    private HttpSession session;

    public int incrementAndCount() {
        int count = 0;
        if (session.getAttribute("count") != null) {
            count = (int) session.getAttribute("count");
        }
        
        count++;
        session.setAttribute("count", count);
        return count;
    }
}</pre>

	    <p>Nyt kontrollerin koodi olisi kevyempi:</p>

<pre class="sh_java">
// importit

@Controller
public class VisitCountController {

    @Autowired
    private CountService countService;   

    @RequestMapping("*")
    @ResponseBody
    public String count() {
        return "Visits: " + countService.incrementAndCount();
    }
}
</pre>


            <div class="tehtavat">
  
	      <div class="tehtava" id="t-reloadheroes-ex">
    
		<header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-reloadheroes">
		      Reload Heroes
                    </a>
                  </h1>
                </header>
		
                <div id="t-reloadheroes" class="collapse">
		  
		  <p>Reload Heroes -sovellus pitää kirjaa käyttäjän tekemistä sivun uudelleenlatauksista. Kun käyttäjä saapuu sovellukseen ensimmäistä kertaa, hänelle luodaan satunnainen käyttäjätunnus ja hänen vierailujen määrä asetetaan yhteen. Jokaisen uudelleenvierailun yhteydessä käyttäjän vierailujen määrä kasvaa yhdellä.</p>

		  <p>Täydennä luokan <code>ReloadStatusService</code> metodit seuraavasti:</p>
	
		  <ul>
		    <li>Metodi <code>public List&lt;ReloadStatus&gt; getTopList()</code> palauttaa viisi eniten uudelleenlatauksia tehnyttä käyttäjää suuruusjärjestyksessä. Listan ensimmäisellä sijalla on eniten uudelleenlatauksia tehnyt henkilö, toisella sijalla toiseksi eniten jne.</li>

		    <li>Metodi <code>public ReloadStatus reload()</code> palauttaa pyynnön tehneeseen henkilöön liittyvän ReloadStatus-olion. Jos käyttäjä ei ole tehnyt yhtäkään pyyntöä aiemmin, tulee käyttäjälle luoda uusi tunnus sekä alustaa uudelleenlatausten määrä yhteen. Jos taas käyttäjä on tehnyt pyyntöjä aiemmin, tulee käyttäjän tekemien pyyntöjen määrää kasvattaa yhdellä. Tieto pyyntöjen määrästä tulee myös tallentaa tietokantaan. </li>
		  </ul>

		  <p>Kun sovellus on valmis, toimii se kuten osoitteessa <a href="https://still-beyond-90359.herokuapp.com" target="_blank">https://still-beyond-90359.herokuapp.com</a> oleva sovellus.</p>
	  
                </div>
              </div>
	    </div>

	    <aside class="info">

	      <br/>

	      <h1>Milloin sessioita kannattaa käyttää?</h1>

	      <p>Muutamia faktoja sessioista:</p>

	      <ul>
		<li>Sessio häviää kun käyttäjä poistaa selaimesta evästeet.</li>
		<li>Sessio häviää kun evästeen elinikä kuluu loppuun.</li>
		<li>Jokaisessa päätelaitteessa on tyypillisesti oma sessio: jos palvelua käytetään kännykällä ja padilla, kummallakin on omat evästeet.</li>
		<li>Käyttäjä voi estää evästeiden käytön selaimen asetuksista.</li>
	      </ul>

	      <p>Sessioiden käyttö on näppärää sellaisen tiedon tallentamiseen mikä saakin kadota. Jos tiedon säilyvyys on oleellista sovelluksen toiminnan kannalta, kannattaa se tallentaa esimerkiksi tietokantaan.</p>

	    </aside>

	    <p>Springin annotaatio <code>@Autowired</code> luo oletuksena yhden ilmentymän luokasta, joka asetetaan <code>@Autowired</code>-annotaatiolla määriteltyyn luokkaan. Palveluiden ja komponenttien luomista voidaan kontrolloida erillisen <code>@Scope</code>-annotaation avulla, mikä mahdollistaa ilmentymien luonnin esimerkiksi sessiokohtaisesti. Seuraavassa on esimerkki ostoskorista, joka on sessiokohtainen ja jokaiselle käyttäjälle oma.</p>

<pre class="sh_java">
// importit 

@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart implements Serializable {

    private Map&lt;Item, Integer&gt; items;

    public ShoppingCart() {
        this.items = new TreeMap&lt;&gt;();
    }

    public Map&lt;Item, Integer&gt; getItems() {
        return items;
    }

    public void setItems(Map&lt;Item, Integer&gt; items) {
        this.items = items;
    }

    public boolean isEmpty() {
        return items == null || items.isEmpty();
    }
}</pre>

            <p>Ylläolevasta komponentista luotavat ilmentymät ovat elossa vain käyttäjän session ajan, eli sen aikaa kun käyttäjän eväste on elossa. Ylläolevasta ostoskorista saa lisättyä ilmentymän sovellukseen aivan kuten muistakin komponenteista, eli <code>@Autowired</code>-annotaatiolla.</p>

	    <aside class="info">
	      <br/>
	      <h1>Mikä ihmeen proxymode?</h1>

	      <p>Tarkempaa tietoa em. annotaatiosta löytyy <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html#beans-factory-scopes-other-injection" target="_blank">Springin dokumentaatiosta</a>.</p>
	    </aside>

	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-euroshopper">
                      EuroShopper
                    </a>
                  </h1>
                </header>
                <div id="t-euroshopper" class="collapse">
		  
                  <p>Tässä tehtävässä toteutetaan verkkokauppaan ostoskoritoiminnallisuus.</p>
		  
                  <h1>Ostoskori</h1>
		  
                  <p>Luo pakkaukseen <code>wad.domain</code> luokka <code>ShoppingCart</code>, joka tarjoaa seuraavat toiminnallisuudet.</p>
		  
                  <ul>
                    <li> Metodi <code>getItems()</code> palauttaa <code>Map&lt;Item, Long&gt;</code>-tyyppisen olion, joka sisältää ostoskorissa olevien tuotteiden tuotekohtaisen lukumäärän.</li>
                    <li> Metodi <code>addToCart(Item item)</code> lisää ostoskoriin yhden kappaleen <code>Item</code>-tyyppistä esinettä.</li>
                    <li> Metodi <code>removeFromCart(Item item)</code> poistaa ostoskorista yhden kappaleen <code>Item</code>-tyyppistä esinettä. Jos lukumäärä laskee nollaan, <code>getItems()</code>-metodin ei tule sisältää enää kyseistä tuotetta.</li>
                  </ul>
		  
		  
                  <h1>Kontrolleri ostoskorille</h1>
		  
                  <p>Tee ostoskorista sessiokohtainen, eli eri käyttäjien tulee saada eri ostoskori käyttöönsä. Annotaatiosta <code>Scope</code> on tässä hyötyä.</p>
		  
                  <p>Luo projektiin sopiva kontrolleri, joka tarjoaa seuraavat osoitteet ja toiminnallisuudet.</p>
		  
                  <ul>
                    <li>GET /cart asettaa model-olion "items"-nimiseen attribuuttiin ostoskorin sisällön (aiempi <code>getItems()</code>). Pyynnön vastauksena käyttäjälle näytetään sivu, joka luodaan polussa <code>/src/main/resources/templates/cart.html</code> olevasta näkymästä.</li>
                    <li>POST /cart/items/{id} lisää ostoskoriin yhden {id}-tunnuksella tietokannasta löytyvän Item-olion. Pyyntö ohjataan osoitteeseen <code>/cart</code>.</li>
                    <li>DELETE /cart/items/{id} poistaa ostoskorista yhden {id}-tunnuksella tietokannasta löytyvän Item-olion. Pyyntö ohjataan osoitteeseen <code>/cart</code>.</li>
                  </ul>
		  
                  <h1>Tilauksen tekeminen</h1>
		  
                  <p>Muokkaa luokkaa <code>wad.service.OrderService</code> siten, että tilaus tallennetaan tietokantaan. Tutustu luokkiin <code>Order</code>, <code>OrderItem</code> ja <code>UserDetails</code> ennen toteutusta. Varmista että esimerkiksi <code>OrderItem</code> viittaa oikeaan tietokantatauluun.</p>
		  
                  <p>Kun tilaus on tehty, tyhjennä ostoskori.</p>
		  
                </div>
              </div>
            </div>
	    

	    <h2>Käyttäjän tunnistaminen ja kirjautuminen</h2>

	    <p>Käyttäjän tunnistautumis- ja kirjautumistoiminnallisuus rakennetaan tyypillisesti myös evästeiden avulla. Jos käyttäjällä ei ole evästettä, mikä liittyy kirjautuneen käyttäjän sessioon, hänet ohjataan kirjautumissivulle. Kirjautumisen yhteydessä käyttäjään liittyvään evästeeseen lisätään tieto siitä, että käyttäjä on kirjautunut -- tämän jälkeen sovellus tietää, että käyttäjä on kirjautunut.</p>

	    <p>Kirjautumissivuja ja -palveluita on kirjoitettu useita, ja sellainen löytyy lähes jokaisesta web-sovelluskehyksestä. Myös Spring-sovelluskehyksessä löytyy oma projekti kirjautumistoiminnallisuuden toteuttamiseen. Käytämme seuraavaksi <a href="http://projects.spring.io/spring-security/" target="_blank">Spring Security</a> -projektia. Sen saa käyttöön lisäämällä Spring Boot -projektin <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

            <p>Komponentti tuo käyttöömme mm. filtterin, joka tarkastelee pyyntöjä ennen kuin ne ohjataan kontrollerimetodeille. Jos käyttäjän tulee olla kirjautunut päästäkseen haluamaansa osoitteeseen, ohjaa filtteri pyynnön tarvittaessa erilliselle kirjautumisivulle.</p>

	    <p>Kirjautumista varten tulee luoda erillinen konfiguraatiotiedosto, jossa määritellään sovellukseen liittyvät salattavat sivut. Oletuskonfiguraatiolla pääsy estetään käytännössä kaikkiin sovelluksen resursseihin. Luodaan oma konfiguraatiotiedosto <code>SecurityConfiguration</code>, joka sisältää sovelluksemme tietoturvakonfiguraation. Huom! Kun konfiguraatiotiedostoja alkaa olla useampia, voit asettaa ne asettaa esimerkiksi erillisen pakkauksen <code>wad.config</code> sisään. </p>

<pre class="sh_java">
// pakkaus 

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // Ei päästetä käyttäjää mihinkään sovelluksen resurssiin ilman
        // kirjautumista. Tarjotaan kuitenkin lomake kirjautumiseen, mihin
        // pääsee vapaasti. Tämän lisäksi uloskirjautumiseen tarjotaan
        // mahdollisuus kaikille. 
        http.authorizeRequests()
                .anyRequest().authenticated().and()
                .formLogin().permitAll().and()
                .logout().permitAll();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        // käyttäjällä jack, jonka salasana on bauer, on rooli USER
        auth.inMemoryAuthentication()
                .withUser("jack").password("bauer").roles("USER");
    }
}</pre>

            <p>Tietoturvakonfiguraatio koostuu kahdesta osasta. Ensimmäisessä osassa <code>configure(HttpSecurity http)</code> määritellään sovelluksen osoitteet joihin on pääsy kielletty tai pääsy sallittu. Toisessa osassa <code>public void configureGlobal(AuthenticationManagerBuilder auth)</code> taas määritellään  -- tässä tapauksessa -- käytössä olevat käyttäjätunnukset ja salasanat.</p>

            <p>Kun määritellään osoitteita, joihin käyttäjä pääsee käsiksi, on hyvä varmistaa, että määrittelyssä on mukana lause <code>anyRequest().authenticated()</code> -- tämä käytännössä johtaa tilanteeseen, missä kaikki osoitteet, joita ei ole erikseen määritelty, vaatii kirjautumista. Voimme määritellä osoitteita, jotka eivät vaadi kirjautumista seuraavasti:</p>

<pre class="sh_java">
    // ..
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers("/free").permitAll()
                .antMatchers("/access").permitAll()
                .antMatchers("/to/*").permitAll()
                .anyRequest().authenticated().and()
                .formLogin().permitAll().and()
                .logout().permitAll();
    }
    // ..</pre>                            

            <p>Ylläolevassa esimerkissä osoitteisiin <code>/free</code> ja <code>/access</code> ei tarvitse kirjautumista. Tämän lisäksi kaikki osoitteet polun <code>/to/</code> alla on kaikkien käytettävissä. Loput osoitteet on kaikilta kielletty. Komento <code>formLogin().permitAll()</code> määrittelee sivun käyttöön kirjautumissivun, johon annetaan kaikille pääsy, jonka lisäksi komento <code>logout().permitAll()</code> antaa kaikille pääsyn uloskirjautumistoiminnallisuuteen.</p>


            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloauthentication">
                      Hello Authentication
                    </a>
                  </h1>
                </header>
                <div id="t-helloauthentication" class="collapse">
		  
                  <p>Tehtävässä on sovellus viestien näyttämiseen. Tehtävänäsi on lisätä siihen salaustoiminnallisuus -- kenenkään muun kuin käyttäjän "maxwell_smart" ei tule päästä viesteihin käsiksi. Aseta Maxwellin salasanaksi "kenkapuhelin".</p>
		  
                </div>
              </div>
            </div>
	    

	    <p>Käyttäjätunnukset tallennetaan tyypillisesti tietokantaan, mistä ne voi tarvittaessa hakea. Salasanoja ei tule tallentaa sellaisenaan, sillä ne <a href="http://www.forbes.com/sites/thomasbrewster/2015/10/28/000webhost-database-leak/" target="_blank">voivat</a> <a href="https://techcrunch.com/2016/06/08/twitter-hack/" target="_blank">joskus</a> <a href="http://www.theregister.co.uk/2016/06/16/verticalscope_breach/" target="_blank">päätyä</a> <a href="https://en.wikipedia.org/wiki/2012_LinkedIn_hack" target="_blank">vääriin</a> <a href="http://www.independent.co.uk/life-style/gadgets-and-tech/news/gmail-hotmail-yahoo-email-passwords-stolen-hacked-hackers-russia-a7014711.html" target="_blank">käsiin</a>. Palaamme salasanojen tallentamismuotoon myöhemmin, nyt tutustumme vain siihen liittyvään tekniikkaan.</p>

	    <aside class="info">
	      <br/>

	      <h1>Klassinen erhe: USER</h1>

	      <p>Aloitteleva web-ohjelmoija tekee usein entiteetin, jossa on kenttä <code>USER</code>. Kyseinen sana on kuitenkin varattu SQL-spesifikaatiossa, joten sitä ei voi käyttää..</p>

	    </aside>

	    
	    <p>Käyttäjätunnuksen ja salasanan noutamista varten tarvitsemme käyttäjälle entiteetin sekä sopivan repository-toteutuksen. Tarvitsemme lisäksi oman <a href="https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/core/userdetails/UserDetailsService.html" target="_blank">UserDetailsService</a>-rajapinnan toteutuksen, jota käytetään käyttäjän hakemiseen tietokannasta. Allaolevassa esimerkissä rajapinta on toteutettu siten, että tietokannasta haetaan käyttäjää. Jos käyttäjä löytyy, luomme siitä <a href="https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/core/userdetails/User.html" target="_blank">User</a>-olion, jonka palvelu palauttaa.</p>

<pre class="sh_java">
// importit

@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private AccountRepository accountRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Account account = accountRepository.findByUsername(username);
        if (account == null) {
            throw new UsernameNotFoundException("No such user: " + username);
        }

        return new org.springframework.security.core.userdetails.User(
                account.getUsername(),
                account.getPassword(),
                true,
                true,
                true,
                true,
                Arrays.asList(new SimpleGrantedAuthority("USER")));
    }
}</pre>

	    <p>Kun oma UserDetailsService-luokka on toteutettu, voimme ottaa sen käyttöön SecurityConfiguration-luokassa.</p>

<pre class="sh_java">
// ..

@Configuration
@EnableWebSecurity
public class SecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // mahdollistetaan h2-konsolin käyttö
        http.csrf().disable();
        http.headers().frameOptions().sameOrigin();
        
        http.authorizeRequests()
                .antMatchers("/h2-console/*").permitAll()
                .anyRequest().authenticated();
        http.formLogin()
                .permitAll();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</pre>

		<p>Edellisessä esimerkissä salasanojen tallentamisessa käytetään <a href="https://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html" target="_blank">BCrypt</a>-algoritmia, joka rakentaa merkkijonomuotoisesta salasanasta hajautusarvon. Tällöin tietokantaan tallennettujen salasanojen vuoto ei ole täysi kriisi, vaikka ei siltikään toivottavaa.</p>  

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodbauthentication">
                      Hello Db Authentication
                    </a>
                  </h1>
                </header>
                <div id="t-hellodbauthentication" class="collapse">
		  
                  <p>Tehtävän ohjelmakoodiin on toteutettu käyttäjät tunnistava sovellus, joka tallentaa käyttäjien salasanat tietokantaan. Tutustu sovelluksen ohjelmakoodiin ja lisää <code>DefaultController</code>-luokassa olevaa ohjelmakoodia mukaillen sovellukseen toinen käyttäjä, jonka salasana on myös "smart".</p>
		  
		  <p>Käy tämän jälkeen tarkastelemassa sovelluksen tietokantaa osoitteessa <code>http://localhost:8080/h2-console</code> (aseta JDBC URL -kentän arvoksi <code>jdbc:h2:mem:testdb</code>). Vaikka lisäämäsi käyttäjän salasana on myös "smart" pitäisi tietokannassa olevien hajautusarvojen olla erilaiset.</p>
		  
                </div>
              </div>
            </div>
	    
	    <p>Kun käyttäjä on kirjautuneena, saa häneen liittyvän käyttäjätunnuksen ns. tietoturvakontekstista.</p>

<pre class="sh_java">
Authentication auth = SecurityContextHolder.getContext().getAuthentication();
String username = auth.getName();
</pre>
	    
	    
	    <aside class="info">
	      
	      <br/>

	      <h1>Uloskirjautuminen</h1>
	      
	      <p>Käyttäjä voi uloskirjautua tekemällä POST-pyynnön sovelluksen osoitteeseen <code>/logout</code>. Miksi tavallinen GET-pyyntö ei riitä? Minkälaisia rajoitteita ja määreitä HTTP-protokollan GET-pyyntöihin liittyi?</p>
	      
	    </aside>
	    
	    
	    
	    <h2>Lakiteknisiä asioita evästeisiin liittyen</h2>
	    
	    
	    <p>Euroopan komissio on säätänyt yksityisyydensuojaan liittyvän lain, joka määrää kertomaan käyttäjille evästeiden käytöstä. Käytännössä käyttäjältä tulee pyytää lupaa minkä tahansa sisällön tallentamiseen hänen koneelleen (<a href="http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=CELEX:32002L0058:EN:HTML" target="_blank">ePrivacy directive, Article 5, kohta (3)</a>). Myöhemmin säädetty <a href="http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=CELEX:32002L0058:EN:HTML" target="_blank">tarkennus</a> tarkentaa määritelmää myös evästeiden käytön kohdalla.</p>

	    <aside>
	      <p>(25) However, such devices, for instance so-called "cookies", can be a legitimate and useful tool, for example, in analysing the effectiveness of website design and advertising, and in verifying the identity of users engaged in on-line transactions. Where such devices, for instance cookies, are intended for a legitimate purpose, such as to facilitate the provision of information society services, their use should be allowed on condition that users are provided with clear and precise information in accordance with Directive 95/46/EC about the purposes of cookies or similar devices so as to ensure that users are made aware of information being placed on the terminal equipment they are using. Users should have the opportunity to refuse to have a cookie or similar device stored on their terminal equipment. This is particularly important where users other than the original user have access to the terminal equipment and thereby to any data containing privacy-sensitive information stored on such equipment. Information and the right to refuse may be offered once for the use of various devices to be installed on the user's terminal equipment during the same connection and also covering any further use that may be made of those devices during subsequent connections. The methods for giving information, offering a right to refuse or requesting consent should be made as user-friendly as possible. Access to specific website content may still be made conditional on the well-informed acceptance of a cookie or similar device, if it is used for a legitimate purpose.</p>
	    </aside>

            <p>Lisätietoa mm. osoitteessa <a href="http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=OJ:L:2009:337:0011:0036:EN:PDF" target="_blank">http://eur-lex.europa.eu/LexUriServ/LexUriServ.do?uri=OJ:L:2009:337:0011:0036:EN:PDF</a> sekä <a href="http://ec.europa.eu/justice/data-protection/article-29/documentation/opinion-recommendation/files/2012/wp194_en.pdf" target="_blank">http://ec.europa.eu/justice/data-protection/article-29/documentation/opinion-recommendation/files/2012/wp194_en.pdf</a>.</p>
	    
	    
	    <h1>Konfiguraatioprofiilit</h1>
	    
	    <p>Ohjelmistotuotannossa on tyypillistä, että jokaisella ohjelmistokehittäjällä on oma ympäristö, missä sovellusta voi kehittää ja testata. Sovelluksen siirtäminen koneelta toiselle ei vaadi muutoksia ohjelman lähdekoodiin, vaan muutokset ovat heti myös muiden kokeiltavissa. Samanlaista joustavuutta odotetaan myös silloin kun sovelluksesta julkaistaan uusi versio käyttäjille.</p>
	    
	    <p>Sovelluksen julkaisun eli esimerkiksi tuotantopalvelimelle siirtämisen ei tule vaatia muutoksia sovelluksen lähdekoodiin. Kun sovellus on julkisessa käytössä, sillä on tyypillisesti ainakin usein eri tietokantaosoite kuin sovelluskehitysvaiheessa, mahdollisesti eri tietokannanhallintajärjestelmä, sekä todennäköisiä erilaisia salasanoihin ja ohjelman tuottamiin tulostuksiin (logeihin) liittyviä asetuksia.</p>

	    <p>Tarvitsemme siis tavan olennaisten asetusten määrittelyyn ympäristökohtaisesti.</p>


	    <h2>Konfiguraatioprofiilit Spring-sovelluskehyksessä</h2>


	    <p>Spring-projekteissa konfiguraatiotiedostot sijaitsevat tyypillisesti kansiossa <code>src/main/resources/</code>. Spring etsii kansiosta tiedostoa nimeltä <code>application.properties</code>, johon ohjelmistokehittäjä voi määritellä sovelluksen käynnistyksen yhteydessä käytettäviä asetuksia. Asetustiedosto voi sisältää esimerkiksi tietokantaan liittyviä asetuksia:</p>

<pre>
spring.datasource.driverClassName=tietokanta-ajuri
spring.datasource.url=jdbc-osoite
</pre>

	    <p>Lista tyypillisistä asetuksista löytyy osoitteesta <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html" target="_blank">http://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html</a>.</p>

	    <p>Käytettävän profiilin ja konfiguraatiotiedoston vaihtaminen toteutetaan tyypillisesti niin, että käytetyllä koneella on määriteltynä ympäristömuuttuja (<code>SPRING_PROFILES_ACTIVE</code>), joka kertoo käytettävän profiilin. Ympäristömuuttujan voi antaa myös sovellukselle parametrina sovellusta käynnistettäessä (<code>java ... -Dspring.profiles.active=arvo ...</code>).</p>

	    <p>Jos käytössä on aktiivista profiilia kuvaava ympäristömuuttuja, etsii Spring oletuskonfiguraatiotiedoston (<code>application.properties</code>) lisäksi myös <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties" target="_blank">aktiiviseen profiiliin liittyvää konfiguraatiotiedostoa</a>. Jos aktiivisena profiilina on <code>production</code>, etsitään myös konfiguraatiotiedostoa <code>application-production.properties</code>. Konfiguraatioprofiili voisi esimerkiksi sisältää tietoa käytettävästä tietokanta-ajurista sekä tietokannan osoitteesta.</p>


	    <h2>Ohjelmakoodissa määriteltävät profiilit</h2>

	    <p>Osa Springin konfiguraatiosta tapahtuu ohjelmallisesti. Esimerkiksi tietoturvaan liittyvät asetukset, esimerkiksi aiemmin näkemämme <code>SecurityConfiguration</code>-luokka, määritellään usein ohjelmallisesti. Haluamme kuitenkin luoda tilanteen, missä tuotannossa on eri asetukset kuin kehityksessä.</p>

	    <p>Tämä onnistuu <code>@Profile</code>-annotaation avulla, jonka kautta voimme asettaa tietyt luokat tai metodit käyttöön vain kun <code>@Profile</code>-annotaatiossa määritelty profiili on käytössä. Esimerkiksi aiemmin luomamme <code>SecurityConfiguration</code>-luokka voidaan määritellä tuotantokäyttöön seuraavasti:</p>

<pre class="sh_java">
// importit

@Profile("production")
@Configuration
@EnableWebSecurity
public class ProductionSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .anyRequest().authenticated();
        http.formLogin()
                .permitAll();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder());
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</pre>

	    <p>Voimme luoda erillisen tietoturvaprofiilin, jota käytetään oletuksena sovelluskehityksessä. Oletusprofiili määritellään merkkijonolla <code>default</code>.</p>

<pre class="sh_java">
// importit

@Profile("default")
@Configuration
@EnableWebSecurity
public class DefaultSecurityConfiguration extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        // sallitaan h2-konsolin käyttö
        http.csrf().disable();
        http.headers().frameOptions().sameOrigin();
        
        http.authorizeRequests()
                .antMatchers("/h2-console/*").permitAll()
                .anyRequest().authenticated();
        http.formLogin()
                .permitAll();
    }

    @Autowired
    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {
        auth.inMemoryAuthentication()
                .withUser("jack").password("bauer").roles("USER");
    }
}
</pre>

	    <p>Nyt tuotantoympäristössä käyttäjät noudetaan tietokannasta, mutta kehitysympäristössä on erillinen testikäyttäjä. Jos profiilia ei ole erikseen määritelty, käytetään oletusprofiilia (default).</p>

 
	    <h2>Sovelluksen siirtäminen pilvipalveluun</h2>

            <p>Tutustutaan seuraavaksi sovelluksen siirtämiseen <a href="https://www.heroku.com/" target="_blank">Heroku</a>-pilvipalveluun. Heroku on palvelu, joka tarjoaa rajoitetun (ja ilmaisen) sijoituspaikan vähän resursseja kuluttaville sovelluksille. Toisin kuin aiemmin toteuttamiemme sovellusten tietokanta, Herokun käyttämä tietokannanhallintajärjestelmä on erillinen sovelluksesta, jolloin tietokantaan tallennetut tiedot pysyvät tietokannassa vaikka sovellus sammuisi välillä.</p>

	    <p>Seuraa ensin osoitteessa <a href="https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku" target="_blank">https://devcenter.heroku.com/articles/deploying-spring-boot-apps-to-heroku</a> olevaa opasta Spring Boot -sovelluksen käytöstä Herokussa ja luo ensimmäinen pilvessä sijaitseva Heroku-sovelluksesi.</p>

	    <p>Jotta saisimme oman tietokantaa käyttävän sovelluksen Herokuun, tarvitsemme muutaman lisäaskeleen. Heroku käyttää PostgreSQL-tietokannanhallintajärjestelmää, joten tarvitsemme sen ajurin sekä erillisen tietokantayhteyksiä hallitsevan apukirjaston. Nämä saa käyttöön lisäämällä projektin pom.xml-tiedostoon seuraavat riippuvuudet.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-dbcp2&lt;/artifactId&gt;
&lt;/dependency&gt;
</pre>

	    <p>Nyt käytössämme on tietokanta-ajuri. Lisätään pom.xml-tiedostoon vielä liitännäinen, joka luo projektista käynnistyvät jar-tiedoston.</p>

<pre class="sh_xml">
&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;repackage&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</pre>

	    <p>Luodaan seuraavaksi konfiguraatiotiedosto, jolla määrittelemme sovelluksen käyttöön PostgreSQL-kielen sekä pyydämme tietokantakyselyitä näkyville. Seuraava sisältö tulee tiedostoon <code>src/main/resources/application-production.properties</code>.</p>

<pre>
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect
spring.jpa.generate-ddl=true
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
</pre>

	    <p>Luodaan tämän jälkeen profiili tuotantokäyttöä varten. Profiili noudattaa Herokun opasta osoitteessa <a href="https://devcenter.heroku.com/articles/connecting-to-relational-databases-on-heroku-with-java" target="_blank">https://devcenter.heroku.com/articles/connecting-to-relational-databases-on-heroku-with-java</a>, mutta on käytössä vain profiililla <code>production</code>. Tämän avulla sovellus muuntaa Herokun antaman tietokantaosoitteen sovelluksen käyttöön.</p>

<pre class="sh_java">
// pakkaus

import java.net.URI;
import java.net.URISyntaxException;
import org.apache.commons.dbcp2.BasicDataSource;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

@Configuration
@Profile("production")
public class ProductionProfile {

    @Bean
    public BasicDataSource dataSource() throws URISyntaxException {
        URI dbUri = new URI(System.getenv("DATABASE_URL"));

        String username = dbUri.getUserInfo().split(":")[0];
        String password = dbUri.getUserInfo().split(":")[1];
        String dbUrl = "jdbc:postgresql://" + dbUri.getHost() + ':' + dbUri.getPort() + dbUri.getPath();

        BasicDataSource basicDataSource = new BasicDataSource();
        basicDataSource.setUrl(dbUrl);
        basicDataSource.setUsername(username);
        basicDataSource.setPassword(password);

        return basicDataSource;
    }
}</pre>


	    <p>Luodaan lopulta vielä erillinen <code>Procfile</code>-tiedosto, jonka perusteella Heroku osaa käynnistää sovelluksen. Procfile-tiedoston sisältö on seuraava:</p>

<pre>
web: java $JAVA_OPTS -Dspring.profiles.active=production -Dserver.port=$PORT -jar target/*.jar
</pre>

	    <p>Tämän jälkeen sovelluksen siirtäminen tuotantoon onnistuu alkuperäisiä Herokun ohjeita noudattamalla.</p>


	    <p>Käytännössä siis Heroku määrittelee sovellukselle käynnistysparametrit sekä portin, jonka lisäksi määrittelemme aktiiviseksi profiiliksi tuotantoprofiilin. Kun sovellus siirretään herokuun, se käyttää Herokun tietokantaa. Toisaalta, kun sovellusta kehitetään paikallisesti, käytössä on testitietokanta -- ihan näppärää.</p>


	    <p>Voit kokeilla ReloadHeroes-sovellusta osoitteessa <a href="https://still-beyond-90359.herokuapp.com/" target="_blank">https://still-beyond-90359.herokuapp.com/</a>.</p>



            <h1>Sovellusten testaaminen</h1>



            <p>Kuten ohjelmistotuotannossa yleensä, myös palvelinohjelmistoja rakennettaessa sovellusten testaaminen hyödyntää sekä kehitystyötä että tulevaa ylläpitotyötä. Testaaminen voidaan karkeasti jakaa kolmeen osaan: yksikkötestaukseen, integraatiotestaukseen ja järjestelmätestaukseen. Tämän lisäksi on mm. myös käytettävyys- ja tietoturvatestaus, joita emme tässä käsittele tarkemmin.</p>

	    <p>Yksikkötestauksessa testataan sovellukseen kuuluvia pienimpiä yksittäisiä komponentteja ja varmistetaan että niiden tarjoamat rajapinnat toimivat tarkoitetulla tavalla. Integraatiotestauksessa testataan että komponentit toimivat yhdessä kuten niiden pitäisi, ja järjestelmätestauksessa varmistetaan, että järjestelmä toimii vaatimusten mukaan järjestelmän käyttäjille tarjotun rajapinnan (esim. selain) kautta.</p>

	    
            <h2>Yksikkötestaus</h2>
	
            <p>Yksikkötestauksella tarkoitetaan lähdekoodiin kuuluvien yksittäisten osien testausta. Termi yksikkö viittaa ohjelman pienimpiin mahdollisiin testattaviin toiminnallisuuksiin, kuten olion tarjoamiin metodeihin. Seuratessamme <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank">single responsibility principle</a>ä, jokaisella oliolla ja metodilla on yksi selkeä vastuu, jota voi myös testata. Testaus tapahtuu yleensä testausohjelmistokehyksen avulla, jolloin luodut testit voidaan suorittaa automaattisesti. Yleisin Javalla käytettävä testauskehys on JUnit, jonka saa käyttöön lisäämällä siihen liittyvän riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre>

            <p>Yksittäisen riippuvuuden määre <code>scope</code> kertoo milloin riippuvuutta tarvitaan. Määrittelemällä <code>scope</code>-elementin arvoksi <code>test</code> on riippuvuudet käytössä vain testejä ajettaessa. Uusia testiluokkia voi luoda NetBeansissa valitsemalla New -> Other -> JUnit -> JUnit Test. Tämän jälkeen NetBeans kysyy testiluokalle nimeä ja pakkausta. Huomaa että lähdekoodit ja testikoodit päätyvät erillisiin kansioihin -- juurin näin sen pitääkin olla. Kun testiluokka on luotu, on projektin rakenne kutakuinkin seuraavanlainen.</p>

            <pre>
.
|-- pom.xml
`-- src
    |-- main
    |   |-- java
    |   |   `-- wad
    |   |       `-- ... oman projektin koodit
    |   |-- resources
    |           `-- ... resurssit, mm. konfiguraatio ja thymeleafin templatet
    |           
    `-- test
        `-- java
            `-- wad
                `-- ... testikoodit!
                </pre>


            <p>Tehtäväpohjissa JUnit-testikirjasto on valmiina mukana. Yksikkötestauksesta JUnit-kirjaston avulla löytyy pieni opas kurssin <a href="https://github.com/mluukkai/OTM2015/wiki/JUnit-ohje" target="_blank">Ohjelmistotekniikan menetelmät</a> sivuilta.</p>


            <h2>Integraatiotestaus</h2>

            <p>Spring tarjoaa <code>spring-test</code>-komponentin, jonka avulla JUnit-kirjasto saa @Autowired-annotaatiot toimimaan. Tämän kautta pääsemme tilanteeseen, missä voimme injektoida testimetodille esimerkiksi kokonaisen palvelun, sekä testata sen tarjoamien metodien toimintaa. Testattava palvelu voi hyödyntää muita komponentteja, jolloin testauksen kohteena on kokonaisuuden toiminta yhdessä.</p>

            <p>Spring test-komponentista on myös Spring Boot -projekti, jonka voimme ottaa käyttöömme lisäämällä seuraavan riippuvuuden pom.xml-tiedostoon. Käytetyn riippuvuuden versio liittyy Spring Boot -projektin versioon, eikä sitä tarvitse määritellä tarkemmin.</p>
	    
            <pre class="sh_xml">
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;</pre>

	    
            <p>Yksittäisten palvelujen testaamisessa tarvitsemme testiluokkien alkuun kaksi annotaatiota. Annotaatio <code>@RunWith(SpringRunner.class)</code> kertoo että käytämme Springiä yksikkötestien ajamiseen ja annotaatio <code>@SpringBootTest</code> lataa sovelluksen osat käyttöön. Testiluokka, johon injektoidaan automaattisesti <code>MyService</code>-palvelu, näyttää seuraavalta.</p>

<pre class="sh_java">
@RunWith(SpringRunner.class)
@SpringBootTest
public class ApplicationTest {

    @Autowired
    private MyService myService;

    // ... testit jne
}</pre>

            <p>Käynnistämällä Springin osana testejä, saamme käyttöömme oliokontekstin, jonka avulla voimme asettaa testattavat oliot testiluokkiin testaamista varten. Testattavien olioiden riippuvuudet asetetaan myös automaattisesti, eli jos <code>MyService</code> sisältää muita komponentteja, on ne myös automaattisesti asetettu.</p>

            <p>Voimme ylläolevalla lähestymistavalla testata myös sitä, että sovelluksemme eri osat toimivat yhteen toivotusti. Oletetaan, että käytössämme on luokka <code>PersonService</code>, joka tarjoaa metodin <code>save</code>, jonka pitäisi tallentaa parametrina annettava <code>Person</code>-olio tietokantaan. Tämän lisäksi käytössämme on <code>PersonRepository</code>, jolla on metodi <code>findByName</code>, minkä avulla voimme hakea tietokannasta henkilön sen nimen perusteella. Kummatkin toteutukset voidaan injektoida suoraan testiluokkaan, testi itsessään ensin tallentaa henkilön <code>PersonService</code>-olion avulla, ja tarkistaa sen jälkeen <code>PersonRepository</code>-oliolta että kyseinen henkilö on olemassa.</p>


<pre class="sh_java">
// importit

@RunWith(SpringRunner.class)
@SpringBootTest
public class ApplicationTest {

    @Autowired
    private PersonService personService;

    @Autowired
    private PersonRepository personRepository;

    @Test
    public void testSavePerson() {
        Person person = new Person();
        person.setName("Jack Bauer");
        person.setAge(42);

        personService.save(person);

        Person retrieved = personService.findByName("Jack Bauer");
        assertNotNull(retrieved);
        assertEquals(42, retrieved.getAge());
    }

    // ja muita testejä
}</pre>

            <p>Ylläolevassa testissä olevat metodit <code>assertNotNull</code> ja <code>assertEquals</code> ovat JUnit-kirjaston tarjoamia toiminnallisuuksia.</p>

	    
            <h2>Järjestelmätestaus</h2>

            <p>Järjestelmätestauksessa on tarkoitus varmistaa, että järjestelmä toimii toivotulla tavalla. Järjestelmää testataan saman rajapinnan kautta, kuin mitä sen loppukäyttäjät käyttävät. Järjestelmätestaukseen on monenlaisia työkaluja, joista käsittelemme tässä kahta. Tutustumme ensin integraatiotestauksessa käytetyn <code>spring-test</code>-komponenttiin järjestelmätason testaustoiminnallisuuteen, jonka jälkeen tutustumme harjoitustehtävän kautta <code>Selenium</code> ja <code>FluentLenium</code> -kirjastoihin.</p>

            <p>Springin tarjoama <code>spring-test</code> tarjoaa tuen järjestelmätestaamiseen. Annotaatiolla <code>@SpringBootTest</code> testeillä on käytössä myös web-sovelluksen konteksti, jonka avulla voidaan luoda <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/web/servlet/MockMvc.html" target="_blank">MockMvc</a>-olio. MockMvc-oliolla pystymme tekemään pyyntöjä sovelluksen tarjoamiin osoitteisiin, tarkistelemaan pyyntöjen onnistumista, sekä tarkastelemaan vastauksena saatua dataa.</p>

            <p>Alla oleva esimerkki käynnistää sovelluksen ja tekee kolme GET-pyyntöä osoitteeseen <code>/messages</code>. Ensimmäinen pyyntö liittyy testiin, missä varmistetaan että vastaus on sisältää statuskoodin <code>200</code> eli "OK", toinen pyyntö liittyy testiin joka varmistaa että vastauksen tyyppi on JSON-muotoista dataa, ja kolmas pyyntö tarkistaa että vastauksessa on merkkijono "Awesome". Alun <code>setUp</code>-metodi luo <code>MockMvc</code>-olion injektoidun palveinkontekstin perusteella.</p>

            <pre class="sh_java">
// muut importit

// mm. mockMvc:n get- ja post-metodit
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@RunWith(SpringRunner.class)
@SpringBootTest
public class MessagesTest {

    @Autowired
    private WebApplicationContext webAppContext;

    private MockMvc mockMvc;

    @Before
    public void setUp() {
        this.mockMvc = MockMvcBuilders.webAppContextSetup(webAppContext).build();
    }

    @Test
    public void statusOk() throws Exception {
        mockMvc.perform(get("/messages"))
                .andExpect(status().isOk());
    }


    @Test
    public void responseTypeApplicationJson() throws Exception {
        mockMvc.perform(get("/messages"))
                .andExpect(content().contentType(MediaType.APPLICATION_JSON));
    }

    @Test
    public void responseContainsTextAwesome() throws Exception {
        MvcResult res = mockMvc.perform(get("/messages"))
                .andReturn();

        String content = res.getResponse().getContentAsString();
        Assert.assertTrue(content.contains("Awesome"));
    }
}</pre>

                <p>Voit myös testata modeliin asetettujen attribuuttien olemassaoloa ja oikeellisuutta. Olemassaolon voi tarkistaa <code>model()</code>-metodin kautta, ja <code>MvcResult</code>-olion kautta pääsee käsiksi modelin sisältöön.</p>

                <pre class="sh_java">
    @Test
    public void modelHasAttributeMessages() throws Exception {
        mockMvc.perform(get("/messages"))
                .andExpect(model().attributeExists("messages"));
    }

    @Test
    public void messagesCorrect() throws Exception {
        MvcResult res = mockMvc.perform(get(API_URI))
                .andReturn();

        // oletetaan, että kontrolleri asettaa listan Message-tyyppisiä olioita
        // modeliin

        List&lt;Message&gt; messages = (List) res.getModelAndView().getModel().get("messages");

        // tarkista lista
    }
</pre>        


            <p>MockMvc:n avulla voi testata käytännössä suurinta osaa palvelinsovellusten toiminnallisuudesta, mutta samalla se tarjoaa pääsyn samaan rajapintaan kuin mitä selain käsitteelee.</p>
	    
	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-lentokentatredux">
                      Airports and Airplanes Redux
                    </a>
                  </h1>
                </header>
                <div id="t-lentokentatredux" class="collapse">
		  
                  <p>Muistamme edellisestä osiosta tehtävän, missä tehtiin sovellus lentokoneiden ja lentokenttien hallintaan. Tässä tehtävässä harjoitellaan hieman sekä integraatio- että järjestelmätestausta.</p>
		  
		  <p>Huom! Tässä tehtävässä ei ole automaattisia testejä, joilla testattaisiin kirjoittamiasi testejä. Palauttaessasi tehtävän olet tarkistanut, että kirjoittamasi testit toimivat kuten tehtävänannossa on kuvattu.</p>
		  
                  <h1>AirportServiceTest</h1>
		  
                  <p>Sovellusessa on luokka <code>AirportService</code>, mikä sijaitsee pakkauksessa <code>wad.service</code>. Sille ei kuitenkaan ole yhtäkään testiä :(</p>

                  <p>Lisää testikansioon (<code>Test Packages</code>) pakkaus <code>wad.service</code>, ja luo sinne luokka <code>AirportServiceTest</code>.</p>
		  
                  <p>Lisää luokalle tarvittavat annotaatiot sekä oliomuuttujat, ja toteuta luokalle testimetodit, joiden avulla testataan että haluttu lentokone todellakin lisätään lentokentälle. Haluat ainakin tietää että:</p>
		  
                  <ul>
                    <li>Kun lentokone on lisätty lentokentälle, tietokannasta samalla tunnuksella haettavalla lentokoneella on asetettu lentokenttä, ja se on juuri se lentokenttä mihin kone on lisätty.</li>
                    <li>Kun lentokone on lisätty lentokentälle, lentokentältä löytyy myös kyseinen kone.</li>
                    <li>Kun lentokone on lisätty yhdelle lentokentälle, se ei ole muilla lentokentillä.</li>
                    <li>Lentokoneen lisääminen samalle lentokentälle useasti ei johda siihen, että lentokenttä sisältää saman koneen monta kertaa.</li>
                  </ul>
		  
                  <p>Aina kun lisäät yksittäisen testin, voit ajaa testit klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Test".</p>                        
		  
                  <h1>AircraftControllerTest</h1>
		  
                  <p>Luo testikansioon pakkaus <code>wad.controller</code> ja lisää sinne luokka <code>AircraftControllerTest</code>. Lisää luokkaan tarvittavat määrittelyt, jotta voit käyttää <code>MockMvc</code>-komponenttia testeissä.</p>
		  
                  <p>Tee seuraavat testit:</p>
		  
                  <ul>
                    <li>Kun osoitteeseen <code>/aircrafts</code> tehdään GET-pyyntö, vastauksen status on 200 (ok) ja vastauksen model-oliossa on parametrit <code>aircrafts</code> ja <code>airports</code>.</li>
                    <li>Kun osoitteeseen <code>/aircrafts</code> tehdään POST-pyyntö, jonka parametriksi annetaan <code>name</code>-kenttä, jonka arvona on "HA-LOL", pyynnön vastaukseksi tulee uudelleenohjaus. Tee tämän jälkeen erillinen kysely tietokantaan esim. <code>AircraftRepository</code>:n avulla, ja varmista, että tietokannasta löytyy lentokone, jonka nimi on <code>HA-LOL</code>.</li>
                    <li>Kun osoitteeseen <code>/aircrafts</code> tehdään POST-pyyntö, jonka parametriksi annetaan <code>name</code>-kenttä, jonka arvona on "XP-55", pyynnön vastaukseksi tulee uudelleenohjaus. Tee tämän jälkeen GET-pyyntö osoitteeseen <code>/aircrafts</code>, ja tarkista että pyynnön vastauksena saatavan <code>model</code>-olion sisältämässä <code>"aircrafts"</code>-listassa on juuri luotu lentokone.</li>
                  </ul>
		  
                  <p>Tässäkin tehtävässä, aina kun lisäät yksittäisen testin, voit ajaa testit klikkaamalla projektia oikealla hiirennapilla ja valitsemalla "Test".</p>                        
                </div>
              </div>
            </div>
	    

            <p>MockMvc:n lisäksi järjestelmätestaukseen käytetään melko paljon käyttöliittymän testaamiseen tarkoitettua <a href="http://www.seleniumhq.org/" target="_blank">Selenium</a>ia ja siihen liittyviä lisäosia kuten <a href="https://github.com/FluentLenium/FluentLenium" target="_blank">FluentLenium</a>. Käytännössä edellämainitut ovat web-selaimen toimintojen automatisointiin tarkoitettuja välineitä, jotka antavat sovelluskehittäjälle mahdollisuuden käydä läpi sovelluksen käyttöliittymää ohjelmallisesti.</p>

	    <p>Lisätään FluentLenium-kirjaston vaatimat riippuvuudet, oletetaan että testit kirjoitetaan JUnit-testikirjaston avulla (FluentLenium tarjoaa myös muita vaihtoehtoja).</p>

            <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;
    &lt;artifactId&gt;fluentlenium-core&lt;/artifactId&gt;
    &lt;version&gt;0.13.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.fluentlenium&lt;/groupId&gt;
    &lt;artifactId&gt;fluentlenium-assertj&lt;/artifactId&gt;
    &lt;version&gt;0.13.1&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;
    &lt;artifactId&gt;htmlunit-driver&lt;/artifactId&gt;
&lt;/dependency&gt;
</pre>


	    <h3>FluentLenium testien kirjoittaminen</h3>


            <p>Ajatellaan loppukäyttäjän haluamaa toiminnallisuutta "Käyttäjä voi ilmoittautua oppitunnille". Järjestelmä tarjoaa sivun, jonka ensimmäinen linkki vie ilmoittautumissivulle. Ilmoittautumissivulla tulee olla tietty otsikko -- varmistamme, että olemme oikealla sivulla. Tämän lisäksi ilmoiuttautumissivulla on lomakekenttä, jonka attribuutin <em>id</em> arvo on "name". Jos kentällä on attribuutti <em>id</em>, voidaan se valita kirjoittamalla "#kentannimi". Täytetään kenttään arvo "Bob" ja lähetetään lomake. Tämän jälkeen sivulla tulee olla teksti "Ilmoittautuminen onnistui!".</p>


            <pre class="sh_java">
// importit

@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class ElokuvatietokantaTest extends FluentTest {

    public WebDriver webDriver = new HtmlUnitDriver();

    @Override
    public WebDriver getDefaultDriver() {
        return webDriver;
    }

    @LocalServerPort
    private Integer port;

    @Test
    public void canSignUp() {
        goTo("http://localhost:" + port);

        click(find("a").first());
        assertEquals("Ilmoittautuminen", title());

        fill(find("#name")).with("Bob");
        submit(find("form").first());

        assertTrue(pageSource().contains("Ilmoittautuminen onnistui!"));
    }
// ...
                </pre>


            <p>Yllä annotaatio <code>@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</code> käynnistää palvelimen integraatiotestausta satunnaisessa portissa, joka saadaan muuttujaan <code>port</code> annotaation <code>@LocalServerPort</code> avulla. Luomme tämän lisäksi ajurin näkymien läpikäyntiin (rivi <code>private WebDriver webDriver = new HtmlUnitDriver();</code>, joka tarjotaan testiluokkamme peritylle toiminnallisuudelle (<code>FluentTest</code>) metodin <code>getDefaultDriver()</code> kautta.</p>

	    <p>Yllä menemme ensin paikalliseen osoitteeseen <code>http://localhost:<em>portti</em></code>, missä portin numero on satunnaisesti valittu -- surffaamme siis haluttuun osoitteeseen. Haemme tämän jälkeen ensimmäisen linkin, eli <code>a</code>-elementin sivulta, ja klikkaamme sitä. Tämän jälkeen tarkistamme, että sivun otsake on <code>Ilmoittautuminen</code>. Tätä seuraa kentän, jonka id on "name" täyttäminen "Bob"-merkkijonolla, jonka jälkeen lomake lähetetään. Kun lomake on lähetetty, haetaan sivun lähdekoodista tekstiä "Ilmoittautuminen onnistui!". Jos tekstiä ei löydy, testi epäonnistuu.</p>

	    <p>FluentLenium-kirjastoon liittyvää dokumentaatiota löytyy osoitteesta <a href="http://www.fluentlenium.org/" target="_blank">http://www.fluentlenium.org/</a>, jonka lisäksi googlesta löytyy apua seuraavaan tehtävään.</p>
	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-elokuvatredux">
                      Movie Database Redux
                    </a>
                  </h1>
                </header>
                <div id="t-elokuvatredux" class="collapse">
		  
                  <p>Muistamme toisesta osiosta myös tehtävän, missä tehtiin sovellus elokuvien ja näyttelijöiden hallintaan. Tässä tehtävässä harjoitellaan hieman järjestelmätestausta FluentLeniumin avulla. Tehtävässä ei ole automaattisia testejä, sillä sinun tehtävänä on toteuttaa ne.</p>
		  
                  <h1>Näyttelijän lisääminen ja poistaminen</h1>
		  
                  <p>Luo testikansioon <code>wad.selenium</code> testiluokka <code>ActorTest</code>, johon asetat Selenium-testaamiseen tarvittavat komponentit.</p>
		  
                  <p>Toteuta testi, jolla varmistetaan että käyttäjän lisääminen ja poistaminen onnistuu. Testin tulee toimia seuraavasti:</p>
		  
                  <ol>
                    <li>Menee näyttelijäsivulle</li>
                    <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                    <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Van Damme", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                    <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                    <li>Klikkaa "Van Damme"en liittyvää poista-nappia </li>
                    <li>Tarkistaa että sivulla ei ole tekstiä "Van Damme"</li>
                  </ol>
		  
                  <p>Toteuta seuraavaksi testi, joka tekee seuraavat askeleet:</p>
		  
                  <ol>
                    <li>Menee näyttelijäsivulle</li>
                    <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                    <li>Tarkistaa ettei sivulla ole tekstiä "Chuck Norris"</li>
                    <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Chuck Norris", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                    <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                    <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                    <li>Etsii kentän jonka id on "name", asettaa kenttään tekstin "Van Damme", ja lähettää lomakkeeseen liittyvän lomakkeen.</li>
                    <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                    <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                    <li>Klikkaa "Van Damme"en liittyvää poista-nappia</li>
                    <li>Klikkaa henkilön "Chuck Norris" poista-nappia</li>
                    <li>Tarkistaa ettei sivulla ole tekstiä "Van Damme"</li>
                    <li>Tarkistaa että sivulla on teksti "Chuck Norris"</li>
                  </ol>
		  
		  
                  <h1>Elokuvan lisääminen ja näyttelijän lisääminen elokuvaan</h1>
		  
                  <p>Luo testikansioon <code>wad.selenium</code> testiluokka <code>MovieTest</code>, johon asetat Selenium-testaamiseen tarvittavat komponentit.</p>
		  
                  <p>Toteuta seuraavat askeleet</p>
		  
                  <ol>
                    <li>Mene elokuvasivulle</li>
                    <li>Tarkista että sivulla ei ole tekstiä "Bloodsport"</li>
                    <li>Tarkista että sivulla ei ole tekstiä "Van Damme"</li>
                    <li>Etsi kenttä jonka id on "name" ja lisää siihen arvo "Bloodsport"</li>
                    <li>Etsi kenttä jonka id on "lengthInMinutes" ja lisää siihen arvo "92"</li>
                    <li>Lähetä kenttään liittyvä lomake</li>
		    
                    <li>Tarkista että sivulla on teksti "Bloodsport"</li>
                    <li>Tarkista että sivulla ei ole tekstiä "Van Damme"</li>
		    
                    <li>Mene näyttelijäsivulle</li>
                    <li>Tarkista ettei sivulla ole tekstiä "Van Damme"</li>
                    <li>Etsi kenttä jonka id on "name", aseta kenttään teksti "Van Damme", ja lähetä lomake.</li>
                    <li>Tarkistaa että sivulla on teksti "Van Damme"</li>
                    <li>Etsi linkki, jossa on teksti "Van Damme" ja klikkaa siitä.</li>
                    <li>Etsi nappi, jonka id on "add-to-movie", ja klikkaa sitä.</li>
		    
                    <li>Mene elokuvasivulle</li>
		    
                    <li>Tarkista että sivulla on teksti "Bloodsport"</li>
                    <li>Tarkista että sivulla on teksti "Van Damme"</li>
                  </ol>
		  
                  <p>Suorita taas testit klikkaamalla projektia oikealla hiirennäppäimellä ja valitsemalla <code>Test</code>.</p>
                </div>
              </div>
            </div>
	    
	    
	    <h2>Konfiguraatioprofiilit ja testaaminen</h2>

	    <p>Testien ajamisessa voidaan käyttää myös konfiguraatioprofiileja. Kun sovellukselle on määritelty erilaisia profiileja, esimerkiksi kirjautumiseen liittyvät konfiguraatiot, voidaan tietty profiili aktivoida testeissä. Testin aktivointi tapahtuu annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/test/context/ActiveProfiles.html" target="_blank">ActiveProfiles</a> avulla.</p>

	    <p>Alla olevassa esimerkissä testiluokan testit suoritetaan siten, että käytössä on profiiliin "test" liittyvä konfiguraatio, eli se konfiguraatio, joka on määritelty annotaatiolla <code>@Profile("test")</code> (tai <code>@Profile(values = {"test", "muita"})</code> jos halutaan että samaa konfiguraatiota käytetään useammassa profiilissa.</p>

            <pre class="sh_java">
@RunWith(SpringRunner.class)
@SpringBootTest
@ActiveProfiles("dev")
public class ApplicationTest {
// ...
            </pre>

	    
	    
          </section>
	  <!-- END OSA3 --->

          <!-- BEGIN OSA4 --->
          <section class="weeklimit" data-week-id="4">
	    
            <header>
              <h1 id="osa4">Osa 4</h1>
            </header>
	    

	    <p>Neljäs osio alkaa kertaustehtävällä, jossa täydennetään varauskalenterin toiminnallisuutta. Tämän jälkeen keskitymme web-ohjelmistoille tyypilliseen ohjelmistokehitysprosessiin sekä tähän liittyviin oleellisiin työvälineisiin. Lopulta tutustumme REST-arkkitehtuurimalliin.</p>
	    
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa3-kertaus-ex" data-count="38">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa3-kertaus">
                      Osa 3, kertaus: Reservations
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa3-kertaus" class="collapse">
		  
		  <p>Tässä tehtävässä tehtävänäsi on täydentää kesken jäänyttä varaussovellusta siten, että kaikki käyttäjät näkevät varaukset, mutta vain kirjautuneet käyttäjät pääsevät lisäämään varauksia.</p>

		  <p>Kun käyttäjä tekee pyynnön sovelluksen juuripolkuun <code>/reservations</code>, tulee hänen nähdä varaussivu. Allaolevassa esimerkissä tietokannassa ei ole varauksia, mutta jos niitä on, tulee ne listata kohdan Current reservations alla.</p>


		  <img src="img/2016-mooc/ex38-emptylist.png" class="browser-img"/>
		  
		  <p>Jos kirjautumaton käyttäjä yrittää tehdä varauksen, hänet ohjataan kirjautumissivulle.</p>

		  <img src="img/2016-mooc/ex38-login.png" class="browser-img"/>
		  
		  <p>Kun kirjautuminen onnistuu, voi käyttäjä tehdä varauksia.</p>


		  <img src="img/2016-mooc/ex38-reservations.png" class="browser-img"/>

		  <p>Sovelluksen tulee kirjautumis- ja varaustoiminnallisuuden lisäksi myös varmistaa, että varaukset eivät mene päällekkäin.</p>

		  <p>Luokassa <code>DefaultController</code> luodaan muutamia testikäyttäjiä, joita voi (esimerkiksi) käyttää sovelluksen testauksessa. Tarvitset ainakin:</p>

		  <ul>
		    <li>Palvelun käyttäjän tunnistautumiseen (esim. CustomUserDetailsService, kts. tehtävä 35), jolla täydennät luokkaa SecurityConfiguration</li>
		    <li>Tavan aikaleimojen käsittelyyn (kts. esim. tehtävä 30)</li>
		    <li>Kontrollerin varausten käsittelyyn ja tekemiseen</li>
		  </ul>
		  
                </div>
              </div>
	    </div>
	    

	    <h2>Käyttäjät ja oikeudet</h2>

	    <p>Käyttäjillä on usein erilaisia oikeuksia sovelluksessa. Verkkokaupassa kaikki voivat listata tuotteita sekä lisätä tuotteita ostoskoriin, mutta vain tunnistautuneet käyttäjät voivat tehdä tilauksia. Tunnistautuneista käyttäjistä vain osa, esimerkiksi kaupan työntekijät, voivat tehdä muokkauksia tuotteisiin.</p>

	    <p>Tällaisen toiminnan toteuttamiseen käytetään oikeuksia, joiden lisääminen vaatii muutamia muokkauksia aiempaan kirjautumistoiminnallisuuteemme. Aiemmin näkemässämme luokassa <code>CustomUserDetailsService</code> noudettiin käyttäjä seuraavasti:</p>

<pre class="sh_java">
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Account account = accountRepository.findByUsername(username);
        if (account == null) {
            throw new UsernameNotFoundException("No such user: " + username);
        }

        return new org.springframework.security.core.userdetails.User(
                account.getUsername(),
                account.getPassword(),
                true,
                true,
                true,
                true,
                Arrays.asList(new SimpleGrantedAuthority("USER")));
    }
</pre> 

	    <p>Palautettavan <code>User</code>-olion luomiseen liittyy lista oikeuksia. Yllä käyttäjälle on määritelty oikeus <code>USER</code>, mutta oikeuksia voisi olla myös useampi. Seuraava esimerkki palauttaa käyttäjän "USER" ja "ADMIN" -oikeuksilla.</p>

<pre class="sh_java">
        return new org.springframework.security.core.userdetails.User(
                account.getUsername(),
                account.getPassword(),
                true,
                true,
                true,
                true,
                Arrays.asList(new SimpleGrantedAuthority("USER"), new SimpleGrantedAuthority("ADMIN")));
</pre> 

	    <p>Oikeuksia käytetään käytettävissä olevien polkujen rajaamisessa. Voimme rajata luokassa <code>SecurityConfiguration</code> osan poluista esimerkiksi vain käyttäjille, joilla on <code>ADMIN</code>-oikeus. Alla olevassa esimerkissä kaikki käyttäjät saavat tehdä GET-pyynnön sovelluksen juuripolkuun. Vain <code>ADMIN</code>-käyttäjät pääsevät polkuun <code>/clients</code>, jonka lisäksi muille sivuille tarvitaan kirjautuminen (mikä tahansa oikeus). Kuka tahansa pääsee kirjautumislomakkeeseen käsiksi.</p>


<pre class="sh_java">
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(HttpMethod.GET, "/").permitAll()
                .antMatchers("/clients").hasAnyAuthority("ADMIN")
                .anyRequest().authenticated();
        http.formLogin()
                .permitAll();
    }
</pre>

	    <p>Oikeuksia varten määritellään tyypillisesti erillinen tietokantataulu, ja käyttäjällä voi olla useampia oikeuksia.</p>

	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-onlyfortheselected">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-onlyfortheselected">
                      Only for the Selected
                    </a>
                  </h1>
                </header>
		
                <div id="t-onlyfortheselected" class="collapse">

		  <p>Sovelluksessa on toteutettuna käyttäjienhallinta tällä hetkellä siten, että käyttäjillä ei ole erillisiä oikeuksia. Muokkaa sovellusta ja lisää sovellukseen käyttäjäkohtaiset oikeudet. Suojaa tämän jälkeen sovelluksen polut seuraavasti:</p>

		  <ul>
		    <li>Kuka tahansa saa nähdä polusta <code>/happypath</code> palautetun tiedon</li>
		    <li>Vain USER tai ADMIN -käyttäjät saavat nähdä polusta <code>/secretpath</code> palautetun tiedon</li>		
		    <li>Vain ADMIN-käyttäjät saavat nähdä polusta <code>/adminpath</code> palautetun tiedon</li>
		  </ul>

		  <p>Lisää sovellukseen myös seuraavat käyttäjät:</p>

		  <table class="table">
		    <tr>
		      <th>Käyttäjätunnus</th>
		      <th>Salasana</th>
		      <th>Oikeudet</th>
		    </tr>
		    <tr>
		      <td>larry</td>
		      <td>larry</td>
		      <td>USER</td>
		    </tr>
		    <tr>
		      <td>moe</td>
		      <td>moe</td>
		      <td>USER ja ADMIN</td>
		    </tr>
		    <tr>
		      <td>curly</td>
		      <td>curly</td>
		      <td>ADMIN</td>
		    </tr>
		  </table>

                </div>
              </div>
	    </div>
	    

	    <aside class="info">
	      <br/>
	      <h1>Käyttätunnus jäi määrittelemättä?</h1>

	      <p>Jos Spring Security -komponentin ottaa käyttöön, mutta ei luo siihen liittyvää konfiguraatiota, ovat oletuksena kaikki polut salattu. Salasana löytyy sovelluksen käynnistyksen yhteydessä tulostuvista viesteistä.</p>
	    
	    </aside>
	    
            <h1 data-count="8">Tyypillinen ohjelmistokehitysprosessi</h1>
	    
	    <p>Ohjelmiston elinkaareen kuuluu vaatimusmäärittely, suunnittelu, toteutus, testaus, sekä ylläpito ja jatkokehitys. Vaatimusmäärittelyyn kuuluu ohjelmistoon liittyvien toiveiden ja vaatimusten kartoitus, jota seuraa suunnittelu, missä pohditaan miten vaatimukset toteutetaan. Toteutusvaihe sisältää ohjelmointia sekä sovelluksen elinympäristöön liittyvien komponenttien yhteensovittamista. Testaukseen kuuluu sovelluksen testaus niin automaattisesti kuin manuaalisesti. Kun ohjelmisto tai sen osa on toiminnassa, tulee elinkaaren osaksi myös käytössä olevasta ohjelmistosta löytyvien virheiden korjaaminen sekä uusien ominaisuuksien kehittäminen.</p>

	    <p>Ohjelmointiin ja ohjelmistojen kehitykseen liittyy jatkuva etsiminen ja kokeileminen. Ongelmat pyritään ratkaisemaan kokeilemalla vaihtoehtoja kunnes ongelmaan löytyy sopiva ratkaisu. Jos ongelma on osittain tuttu, on tarkasteltavia vaihtoehtoja vähemmän, ja jos ongelma on tuttu, on siihen tyypillisesti ainakin yksi valmis ratkaisumalli. Tämän hetken suosituimmat ohjelmistokehitysmenetelmät (ketterät menetelmät kuten Scrum ja Kanban) ohjaavat työn läpinäkyvyyteen, oman työskentelyn kehittämiseen sekä siihen, että muiden osallistuminen ohjelmistokehitykseen on helppoa.</p>

	    <h2>Ohjelmistoon liittyvät toiveet ja vaatimukset</h2>
	    
	    <p>Ohjelmistoon liittyvistä toiveista ja vaatimuksista keskustellaan asiakkaan ja käyttäjien kanssa, ja ne kirjataan muistiin. Vaatimukset kirjataan usein lyhyessä tarinamuodossa, joka kerrotaan uutta toiminnallisuutta toivovan henkilön näkökulmasta: "As a (käyttäjän tyyppi) I want (tavoite) so that (syy)." -- esimerkiksi "As a user I want to be able to view the messages so that I can see what others have written". Vaatimuksia kirjattaessa saadaan kuva ohjelmistolta toivotusta toiminnallisuudesta, jonka jälkeen toiminnallisuuksia voidaan järjestää tärkeysjärjestykseen. </p>
	    
	    <p>Toiminnallisuuksien tärkeysjärjestykseen asettaminen tapahtuu yhdessä asiakkaan ja käyttäjien kanssa. Kun toiminnallisuudet ovat kutakuinkin tärkeysjärjestyksessä, valitaan niistä muutama kerrallaan työstettäväksi. Samalla varmistetaan asiakkaan kanssa, että ohjelmistokehittäjät ja asiakas ymmärtävät toiveen samalla tavalla. Kun toiminnallisuus on valmis, toiminnallisuus näytetään asiakkaalle ja asiakas pääsee kertomaan uusia toiminnallisuustoiveita sekä mahdollisesti uudelleenjärjestelemään vaatimusten tärkeysjärjestystä.</p>

            <p>Vaatimuksia ja toiveita, sekä niiden kulkemista projektin eri vaiheissa voidaan käsitellä esimerkiksi <a href="https://trello.com/" target="_blank">Trello</a>:n avulla. <a href="https://www.youtube.com/watch?v=7najSDZcn-U" target="_blank">Ohje Trellon käyttöön</a>.</p>


	    <h2>Versionhallinta</h2>
	    
	    <p>Ohjelmiston lähdekoodin ja dokumentaatio tallennetaan keskitetysti versionhallintaan, mistä kuka tahansa voi hakea ohjelmistosta uusimman version sekä lähettää sinne uudemman päivitetyn version. Käytännössä jokaisella ohjelmistokehittäjällä on oma hiekkalaatikko, jossa ohjelmistoon voi tehdä muutoksia vaikuttamatta muiden tekemään työhön. Jokaisella ohjelmistokehittäjällä on yleensä samat tai samankaltaiset työkalut (ohjelmointiympäristö, ...), mikä helpottaa muiden kehittäjien auttamista.</p>

	    <p>Kun ohjelmistokehittäjä valitsee vaatimuksen työstettäväksi, hän tyypillisesti hakee projektin versionhallinnasta projektin uusimman version, sekä lähtee toteuttamaan uutta vaatimusta. Kun vaatimukseen liittyvä osa tai komponentti on valmis sekä testattu paikallisesti (automaattiset testit on olemassa, toimii ohjelmistokehittäjän koneella), lähetetään uusi versio versionhallintapalvelimelle.</p>

	    <p>Versionhallintapalvelin sisältää myös mahdollisesti useampia versioita projektista. Esimerkiksi git-mahdollistaa ns. branchien käyttämisen, jolloin uusia ominaisuuksia voidaan toteuttaa erillään "päähaarasta". Kun uusi ominaisuus on valmis, voidaan se lisätä päähaaraan. Versionhallinnassa olevia koodeja voidaan myös tägätä julkaisuversioiksi.</p>

            <p>Yleisin versionhallintatyökalu on <a href="https://en.wikipedia.org/wiki/Git_(software)" target="_blank">Git</a>, joka on käytössä <a href="https://github.com/" target="_blank">Github</a>issa. <a href="https://guides.github.com/activities/hello-world/" target="_blank">Ensiaskeleet Githubin käyttöön</a>.</p>


	    <h2>Jatkuva integraatio</h2>

            <p>Versionhallintapalvelin on tyypillisesti kytketty integraatiopalvelimeen, jonka tehtävänä on suorittaa ohjelmistoon liittyvät testit jokaisen muutoksen yhteydessä sekä tuottaa niistä mahdollisesti erilaisia raportteja. Integraatiopalvelin kuuntelee käytännössä versionhallintajärjestelmässä tapahtuvia muutoksia, ja hakee uusimman lähdekoodiversion muutoksen yhteydessä.</p>
	    
            <p>Kun testit ajetaan sekä paikallisella kehityskoneella että erillisellä integraatiokoneella ohjelmistosta huomataan virheitä, jotka eivät tule esille muutoksen tehneen kehittäjän paikallisella koneella (esimerkiksi erilainen käyttöjärjestelmä, selain, ...). On myös mahdollista että ohjelmistosta ei noudeta kaikkia sen osia -- ohjelmisto voi koostua useista komponenteista --  jolloin kaikkien vaikutusten testaaminen paikallisesti on mahdotonta. Jos testit eivät mene läpi integraatiokoneella, korjataan muutokset mahdollisimman nopeasti.</p>
	    
            <p>Työkaluja automaattiseen kääntämiseen ja jatkuvaan integrointiin ovat esimerkiksi <a href="https://travis-ci.org" target="_blank">Travis</a> ja <a href="https://coveralls.io" target="_blank">Coveralls</a>. Travis varmistaa että viimeisin lähdekoodiversio kääntyy ja että testit menevät läpi, ja Coveralls tarjoaa välineitä testikattavuuden ja projektin historian tarkasteluun -- tässä hyödyksi on esimerkiksi <a href="https://github.com/cobertura/cobertura" target="_blank">Cobertura</a>. Kummatkin ovat ilmaisia käyttää kun projektin lähdekoodi on avointa -- kumpikin tarjoaa myös suoran Github-tuen.</p>
	    
            <p>Travisin käyttöönottoon vaaditaan käytännössä se, että projekti on esimerkiksi Githubissa ja että sen juurikansiossa on travisin konfiguraatiotiedosto <code>.travis.yml</code>. Yksinkertaisimmillaan konfiguraatiotiedosto sisältää vain käytetyn ohjelmointikielen -- travis osaa esimerkiksi päätellä projektin tyypin <code>pom.xml</code>-tiedoston pohjalta. <a href="https://docs.travis-ci.com/user/getting-started/" target="_blank">Ohje Traviksen käyttöönottoon</a>. </p>


	    <h2>Nopeasti näytille</h2>

	    <p>Kun uusi vaatimus tai sen osa on saatu valmiiksi, kannattaa viedä palvelimelle palautteen saamista varten. On tyypillistä, että ohjelmistolle on ainakin <em>Staging</em>- ja <em>Tuotanto</em>-palvelimet. Staging-palvelin on lähes identtinen ympäristö tuotantoympäristöön verrattuna. Staging (usein myös QA)-ympäristöön kopioidaan ajoittain tuotantoympäristön data, ja se toimii viimeisenä testaus- ja validointipaikkana (Quality assurance) ennen tuotantoon siirtoa. QA-ympäristöä käytetään myös demo- ja harjoitteluympäristönä. Kun QA-ympäristössä oleva sovellus on päätetty toimivaksi, siirretään sovellus tuotantoympäristöön.</p>

	    <p>Tuotantoympäristö voi olla yksittäinen palvelin, tai se saattaa olla joukko palvelimia, joihin uusin muutos viedään hiljalleen. Tuotantoympäristö on tyypillisesti erillään muista ympäristöistä mahdollisten virheiden minimoimiseksi.</p>

	    <p>Käytännössä versioiden päivitys tuotantoon tapahtuu usein automaattisesti. Esimerkiksi ohjelmistoon liittyvä Travis-konfiguraatio voidaan määritellä niin, että jos kaikki testit menevät läpi integraatiopalvelimella, siirretään ohjelmisto <a href="https://docs.travis-ci.com/user/deployment/heroku" target="_blank">automaattisesti tuotantoon</a>. Esimerkiksi Herokussa sijaitsevaan sovellukseen muutokset voidaan hakea automaattisesti Githubista (<a href="https://devcenter.heroku.com/articles/github-integration" target="_blank">ohje</a>).</p>


	    <aside class="info">
	      <br/>
	      <h1>Tietokantamigraatiot</h1>

	      <p>Ohjelmistojen kehityksessä tulee vastaan tyypillisesti tilanne, missä tuotantokäytössä olevaa tietokantaskeemaa tulee muuntaa. Koska käytössä oleva tietokantaversio voi poiketa ohjelmistokehittäjän koneesta riippuen -- joku saattaa työstää uutta versiota, jollain toisella voi olla työn alla korjaukset vanhempaan versioon -- tarvitaa myös tietokantamuutosten automatisointiin välineitä. Tähän löytyy työvälineitä kuten <a href="http://www.liquibase.org/" target="_blank">Liquibase</a> ja <a href="https://flywaydb.org/" target="_blank">Flyway</a>, joista molemmista löytyy myös <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/howto-database-initialization.html" target="_blank">Spring Boot</a>-ohjeet.</p>

	      <p>Käytännössä tietokantamigraatiot toteutetaan niin, että tietokannasta pidetään yllä tietokantataulujen muutos- ja muokkauskomennot sisältäviä versiokohtaisia tiedostoja. Käytössä olevaan tietokantaan on määritelty esimerkiksi taulu, jossa on tieto tämänhetkisestä versiosta. Jos käynnistettävässä sovelluksessa on uudempia muutoksia, ajetaan niihin liittyvät komennot tietokantaan ja tietokantaan merkitty versio päivittyy.</p>

	      <p>Jos sovellus sijaitsee palvelussa kuten Heroku, jossa sovelluksen käynnistykseen on varattu vain rajattu aika, kannattaa tietokantamigraatioihin liittyvistä versiotiedostoista tehdä ohjelmalliset. Tällöin migraatio tapahtuu vasta kun sovellus on käynnistynyt, eikä käynnistystä keskeytetä ajan mahdollisen ylittymisen vuoksi. Esimerkiksi Flyway mahdollistaa muutosten tekemisen Java-koodissa.</p>

	    </aside>

	      


	    <h1>REST-Arkkitehtuurimalli</h1>
            

	    <p>REST (<a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">representational state transfer</a>) on ohjelmointirajapintojen toteuttamiseen tarkoitettu arkkitehtuurimalli (tai "tyyli"), joka määrittelee sovellukset tietoa käsittelevien osien (komponentit), tietokohteiden (resurssit), sekä näitä yhdistävien yhteyksien kautta.</p>

	    <p>Tietoa käsittelevät osat ovat selainohjelmisto, palvelinohjelmisto, ym. Resurssit ovat sovelluksen käsitteitä (henkilöt, kirjat, laskentaprosessit, laskentatulokset -- mikä tahansa voi käytännössä olla resurssi) sekä niitä yksilöiviä osoitteita. Resurssikokoelmat ovat löydettävissä ja navigoitavissa: resurssikokoelma voi löytyä esimerkiksi osoitteesta <code>/persons</code>, <code>/books</code>, <code>/processes</code> tai <code>/results</code>. Yksittäisille resursseille määritellään uniikit osoitteet (esimerkiksi <code>/persons/1</code>), ja niillä on myös määritelty esitysmuoto (esimerkiksi HTML, JSON tai XML); dataa voi lähettää ja vastaanottaa samassa muodossa. Resursseja ja tietoa käsittelevien osien yhteys perustuu tyypillisesti asiakas-palvelin -malliin, missä asiakas tekee pyynnön ja palvelin kuuntelee ja käsittelee vastaanottamiaan pyyntöjä sekä vastaa niihin.</p>
	    
            <aside class="info">
	      <br/>
	      
              <h1>Tiedon alkulähteille</h1>
	      
              <p>Tutustu Roy T. Fieldingin ja Richard N. Taylorin artikkeliin <a href="resources/principled-design-of-the-modern-web-architecture.pdf" target="_blank">"Principled Design of the Modern Web Architecture"</a>, jossa REST määritellään sekä Fieldingin väitöskirjan <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank">viidenteen lukuun</a>. Vaikka emme tässä kappaleessa täytä kaikkia REST-rajapintoihin liittyviä vaatimuksia -- ainakaan aluksi -- on Roy Fielding sitä mieltä, että <a href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_blank">oleellista on mahdollisuus resurssien välillä navigointiin</a>.</p>
		
              <p><em>"A truly RESTful API looks like hypertext. Every addressable unit of information carries an address, either explicitly (e.g., link and id attributes) or implicitly (e.g., derived from the media type definition and representation structure). Query results are represented by a list of links with summary information, not by arrays of object representations (query is not a substitute for identification of resources)."</em></p>
		
            </aside>

	    
            <h2>REST-rajapinnat ja Web-sovellukset</h2>
            
            <p>HTTP-protokollan yli käsiteltävillä REST-rajapinnoilla on tyypillisesti seuraavat ominaisuudet:</p>

	    <ul>
	      <li>Juuriosoite resurssien käsittelyyn (esimerkiksi <code>/books</code>)</li>
	      <li>Resurssien esitysmuodon määrittelevä mediatyyppi (esimerkiksi <code>HTML</code>, <code>JSON</code>, ...), joka kertoo asiakkaalle miten resurssiin liittyvä data tulee käsitellä.</li>
	      <li>Resursseja voidaan käsitellä HTTP-protokollan metodeilla (GET, POST, DELETE, ..)</li>
	    </ul>
	    
	    <p>Kirjojen käsittelyyn ja muokkaamiseen määriteltävä rajapinta voisi olla esimerkiksi seuraavanlainen:</p>

            <ul>
              <li>GET-pyyntö osoitteeseen <code>/books</code> palauttaa kaikkien kirjojen tiedot.</li>
              <li>GET osoitteeseen <code>/books/{id}</code>, missä <code>{id}</code> on yksittäisen kirjan yksilöivä tunniste, palauttaa kyseisen kirjan tiedot.</li>
              <li>PUT osoitteeseen <code>/books/{id}</code>, missä <code>{id}</code> on yksittäisen kirjan yksilöivä tunniste, muokataan kyseisen kirjan tietoja. Kirjan uudet tiedot lähetetään osana pyyntöä.</li>
              <li>DELETE osoitteeseen <code>/books/{id}</code> poistaa kirjan tietyllä tunnuksella.</li>
              <li>POST osoitteeseen <code>/books</code> luo uuden kirjan pyynnön rungossa lähetettävän datan pohjalta. Palvelun vastuulla on päättää kirjalle tunnus.</li>
            </ul>

            <p>Osoitteissa käytetään tyypillisesti substantiivejä -- ei <code>books?id={id}</code> vaan <code>/books/{id}</code>. HTTP-pyynnön tyyppi määrittelee operaation. DELETE-tyyppisellä pyynnöllä poistetaan, POST-tyyppisellä pyynnöllä lisätään, PUT-tyyppisellä pyynnöllä päivitetään tietoja, ja GET-tyyppisellä pyynnöllä haetaan.</p>

            <p>Datan muoto on toteuttajan päätettävissä. Tällä hetkellä eräs suosituista datamuodoista on <a href="http://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a>, sillä sen käyttäminen osana selainohjelmistoja on suoraviivaista JavaScriptin kautta. Myös palvelinohjelmistot tukevat olioiden muuttamista JSON-muotoon.</p>

            <p>Oletetaan että edelläkuvattu kirjojen käsittelyyn tarkoitettu rajapinta käsittelee JSON-muotoista dataa. Kirjaa kuvaava luokka on seuraavanlainen:</p>
                
<pre class="sh_java">
package wad;

public class Book {
    private Long id;
    private String name;

    public Long getId() {
        return this.id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return this.name;
    }

    public String setName(String name) {
        this.name = name;
    }
}</pre>
                
            <p>Kun luokasta on tehty olio, jonka <code>id</code>-muuttujan arvo on <code>2</code> ja nimi <code>"Harry Potter and the Chamber of Secrets"</code>, on sen JSON-esitys seuraavanlainen:</p>

<pre>
{
  "id":2,
  "name":"Harry Potter and the Chamber of Secrets"
}</pre>
            
	    <p>JSON-notaatio määrittelee olion alkavalla aaltosululla <code>{</code>, jota seuraa oliomuuttujien nimet ja niiden arvot. Lopulta olio päätetään sulkevaan aaltosulkuun <code>}</code>. Oliomuuttujien nimet ovat hipsuissa <code>&quot;</code> sillä ne käsitellään merkkijonoina. Muuttujien arvot ovat arvon tyypistä riippuen hipsuissa. Tarkempi kuvaus JSON-notaatiosta löytyy sivulta <a href="http://json.org/" target="_blank">json.org</a>.</p>

            <p>Pyynnön rungossa lähetettävän JSON-muotoisen datan muuttaminen olioksi tapahtuu annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestBody.html" target="_blank">@RequestBody</a> avulla. Annotaatio @RequestBody edeltää kontrollerimetodin parametrina olevaa oliota, johon sovelluskehittäjä pyytää Spring-sovelluskehystä asettamaan JSON-muotoisen datan arvot.</p>

<pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST)
    public String postBook(@RequestBody Book book) {
        bookRepository.save(book);
        return "redirect:/books";
    }</pre>

            <p>Vastauksen saa lähetettyä käyttäjälle JSON-muodossa lisäämällä pyyntöä käsittelevään metodiin annotaatio <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseBody.html" target="_blank">@ResponseBody</a>. Annotaatio @ResponseBody pyytää Spring-sovelluskehystä asettamaan palvelimen tuottaman datan selaimelle lähetettävän vastauksen runkoon. Jos vastaus on olio, muutetaan se (oletuksena) automaattisesti JSON-muotoiseksi vastaukseksi.</p>

<pre class="sh_java">
    @RequestMapping(method=RequestMethod.GET)
    @ResponseBody
    public Book getBook() {
        Book book = new Book();
        book.setName("Spring API");
        return book;
    }</pre>

            <p>Edellä mainitut annotaatiot voi myös yhdistää. Oletetaan, että käytössä on <code>bookRepository</code>-niminen olio, jonka metodi <code>save</code> lisää kirjalle yksilöivän tunnuksen ja varastoi sen myöhempää käyttöä varten. Metodi myös palauttaa viitteen uuteen kirja-olioon. Uuden kirjan lisääminen tapahtuisi tällöin seuraavasti.</p> 

<pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST)
    @ResponseBody
    public Book postBook(@RequestBody Book book) {
        return bookRepository.save(book);
    }</pre>
                
            <p>Nyt palvelulle voi lähettää JSON-muotoista dataa; vastaus on myös JSON-muotoinen, mutta luotavaan kirjaan on liitetty sen yksilöivä tunnus.</p>

            <p>Voimme lisätä annotaatioon @RequestMapping lisätietoa metodin tuottamasta datasta. Attribuutti <code>consumes</code> kertoo minkälaista dataa metodin kuuntelema osoite hyväksyy. Metodi voidaan rajoittaa vastaanottamaan JSON-muotoista dataa merkkijonolla <code>"application/json"</code>. Vastaavasti metodille voidaan lisätä tietoa datasta, jota se tuottaa. Attribuutti <code>produces</code> kertoo tuotettavan datatyypin. Alla määritelty metodi sekä vastaanottaa että tuottaa JSON-muotoista dataa.</p>

<pre class="sh_java">
    @RequestMapping(method=RequestMethod.POST, 
                      consumes="application/json", produces="application/json")
    @ResponseBody
    public Book postBook(@RequestBody Book book) {
        return bookStorage.create(book);
    }</pre>


            <p>Jos on toteuttamassa omaa REST-rajapintaa, kannattanee joko käyttää Spring Data REST -komponenttia (palaamme tähän hieman myöhemmin) tai määritellä kontrolleriluokan annotaatioksi <code>@RestController</code>. Tämä asettaa jokaisen luokan metodiin annotaation <code>@ResponseBody</code> sekä sopivan datatyypin -- tässä tapauksessa "application/json".</p>

            <p>Toteutetaan seuraavaksi kaikki tarvitut metodit kirjojen tallentamiseen. Kontrolleri hyödyntää erillistä luokkaa, joka tallentaa kirjaolioita tietokantaan ja tarjoaa tuen aiemmin määrittelemiemme books-osoitteiden ja pyyntöjen käsittelyyn -- PUT-metodi on jätetty omaa kokeilua varten.</p>


            <pre class="sh_java">
// importit

@RestController
@RequestMapping("books")
public class BookController {

    @Autowired
    private BookRepository bookRepository;

    @RequestMapping(method=RequestMethod.GET)
    public List&lt;Book&gt; getBooks() {
        return bookRepository.findAll();
    }

    @RequestMapping(value="/{id}", method=RequestMethod.GET)
    public Book getBook(@PathVariable Integer id) {
        return bookRepository.findOne(id);
    }

    @RequestMapping(value="/{id}", method=RequestMethod.DELETE)
    public Book deleteBook(@PathVariable Integer id) {
        return bookRepository.delete(id);
    }    

    @RequestMapping(method=RequestMethod.POST)
    public Book postBook(@RequestBody Book book) {
        return bookRepository.save(book);
    }
}</pre>

	    
            <aside class="info">
	      <br/>
              <h1>Apuvälineitä rajapinnan tarjoavan sovelluksen testaamiseen</h1>
	      
              <p>Palvelinohjelmistot, jotka tarjoavat vain avoimen rajapinnan kolmannen osapuolen ohjelmistoille, eivät tyypillisesti sisällä erillistä käyttöliittymää. Tällöin niiden testaaminen tapahtuu tyypillisesti sekä automaattisilla testeillä, että erilaisilla selainohjelmistoilla. Yksi hyvin hyödyllinen apuväline on <a href="https://www.getpostman.com/" target="_blank">Postman</a>, jonka saa lisättyä Google Chromeen Googlen web-storesta.</p>
	      
              <p>Postmanin hyödyntäminen on erittäin suositeltavaa -- kannattaa katsoa sen johdatusvideo, joka löytyy Postmanin sivulta. Katso myös <a href="https://www.youtube.com/watch?v=7YcW25PHnAA" target="_blank">RESTiä käsittelevä</a> Youtube-video, missä Postmania käytetään hieman.</p>
            </aside>
	    
	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-tulospalvelu">
                      ScoreService
                    </a>
                  </h1>
                </header>
                <div id="t-tulospalvelu" class="collapse">
		  
                  <p>Tässä tehtävässä toteutetaan pelitulospalvelu, joka tarjoaa REST-rajapinnan pelien ja tuloksien käsittelyyn. <strong>Huom! Kaikki syötteet ja vasteet ovat JSON-muotoisia olioita.</strong> Tehtäväpohjassa on toteutettu valmiiksi luokat <code>Game</code> ja <code>Score</code> sekä käytännölliset <code>Repository</code>-rajapinnat.</p>
		  
                  <h1>GameController</h1>
		  
                  <p>Pelejä käsitellään luokan <code>Game</code> avulla.</p>
		  
                  <p>Toteuta pakkaukseen <code>wad.controller</code> luokka <code>GameController</code>, joka tarjoaa REST-rajapinnan pelien käsittelyyn:</p>
                  <ul>
                    <li><code>POST /games</code> luo uuden pelin sille annetun pelin tiedoilla ja palauttaa luodun pelin tiedot. (Huom. vieläkin! Pyynnön <strong>rungossa</strong> oleva data on aina JSON-muotoista. Vastaukset tulee myös palauttaa JSON-muotoisina.)</li>
                    <li><code>GET /games</code> listaa kaikki talletetut pelit.</li>
                    <li><code>GET /games/{name}</code> palauttaa yksittäisen pelin tiedot <strong>pelin nimen perusteella</strong>.</li>
                    <li><code>DELETE /games/{name}</code> poistaa nimen mukaisen pelin. Palauttaa poistetun pelin tiedot.</li>
                  </ul>
		  
                  <h1>ScoreController</h1>
		  
                  <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia tuloksia (luokka <code>Score</code>). Jokainen pistetulos kuuluu tietylle pelille, ja tulokseen liittyy aina pistetulos <code>points</code> numerona sekä pelaajan nimimerkki <code>nickname</code>.</p>
		  
                  <p>Toteuta luokka <code>wad.controller.ScoreController</code>, joka tarjoaa REST-rajapinnan tuloksien käsittelyyn:</p>
		  
                  <ul>
                    <li><code>POST /games/{name}/scores</code> luo uuden tuloksen pelille <code>name</code> ja asettaa tulokseen pelin tiedot. Tuloksen tiedot lähetetään kyselyn rungossa.</li>
                    <li><code>GET /games/{name}/scores</code> listaa pelin <code>name</code> tulokset.</li>
                    <li><code>GET /games/{name}/scores/{id}</code> palauttaa tunnuksella <code>id</code> löytyvän tuloksen <code>name</code>-nimiselle pelille.</li>
                    <li><code>DELETE /games/{name}/scores/{id}</code> poistaa avaimen <code>id</code> mukaisen tuloksen peliltä <code>name</code> (pelin tietoja ei tule pyynnön rungossa). Palauttaa poistetun tuloksen tiedot.</li>
                  </ul>
		  
                </div>
              </div>
            </div>
	    
	    
            <h2>Valmiin palvelun käyttäminen</h2>

            <p>Toisen sovelluksen tarjoamaan REST-rajapintaan pääsee kätevästi käsiksi <a href="http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html" target="blank">RestTemplate</a>-luokan avulla. Voimme luoda oman komponentin kirjojen hakemiseen.</p>
                
<pre class="sh_java">
// importit

@Service
public class BookService {

    private RestTemplate restTemplate;
    
    public BookService() {
        this.restTemplate = new RestTemplate();
    }

    // tänne luokan tarjoamat palvelut
}</pre>

                

            <ul>
              <li>GET osoitteeseen <em>/books</em> palauttaa kaikkien kirjojen tiedot <em>tai</em> osajoukon kirjojen tiedoista -- riippuen toteutuksesta.</li>
                    <pre class="sh_java">
// kirjojen hakeminen
List&lt;Book&gt; books = restTemplate.getForObject("<em>osoite</em>/books", List.class);</pre>
              <li>GET osoitteeseen <em>/books/{id}</em>, missä {id} on yksittäisen kirjan yksilöivä tunniste, palauttaa kyseisen kirjan tiedot.</li>
                    <pre class="sh_java">
// tunnuksella 5 määritellyn kirjan hakeminen
Book book = restTemplate.getForObject("<em>osoite</em>/books/{id}", Book.class, 5);</pre>
              <li>PUT osoitteeseen <em>/books/{id}</em>, missä {id} on yksittäisen kirjan yksilöivä tunniste, muokkaa kyseisen kirjan tietoja tai lisää kirjan kyseiselle tunnukselle (toteutuksesta riippuen, lisäystä ei aina toteutettu). Kirjan tiedot lähetetään pyynnön rungossa.</li>

                    <pre class="sh_java">
// tunnuksella 5 määritellyn kirjan hakeminen
Book book = restTemplate.getForObject("<em>osoite</em>/books/{id}", Book.class, 5);
book.setName(book.getName() + " - DO NOT BUY!");

// kirjan tietojen muokkaaminen
restTemplate.put("<em>osoite</em>/books/{id}", book, 5);</pre>
              <li>DELETE osoitteeseen <em>/books/{id}</em> poistaa kirjan tietyllä tunnuksella.</li>

                    <pre class="sh_java">
 // tunnuksella 32 määritellyn kirjan poistaminen
restTemplate.delete("<em>osoite</em>/books/{id}", 32);</pre>
              <li>POST osoitteeseen <em>/books</em> luo uuden kirjan pyynnön rungossa lähetettävän datan pohjalta. Palvelun vastuulla on päättää kirjalle tunnus.</li>

                    <pre class="sh_java">
Book book = new Book();
book.setName("Harry Potter and the Goblet of Fire");

// uuden kirjan lisääminen
book = restTemplate.postForObject("<em>osoite</em>/books", book, Book.class);</pre>
            </ul>

            <p>Usein sovellukset hyödyntävät kolmannen osapuolen tarjoamaa palvelua omien toiminnallisuuksiensa toteuttamiseen. Harjoitellaan tätä seuraavaksi. </p>

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-gamerater">
                      GameRater
                    </a>
                  </h1>
                </header>
                <div id="t-gamerater" class="collapse">
		  
                  <p>Palvelu <em>GameRater</em> lisää aiempaan tulospalveluun mahdollisuuden arvostella yksittäisiä pelejä antamalla niille numeroarvosanan 0-5. Arvostelu tehdään kuitenkin erilliseen palveluun, emmekä siis laajenna edellistä palvelua suoraan.</p>
		  
                  <p><em>GameRater</em>-palvelun tulee käyttää <em>Tulospalvelu</em>-palvelun REST-rajapintaa, jonka avulla se tarjoaa samanlaisen rajapinnan pelien ja tulosten käsittelyyn. Ainoastaan pelien arvostelut käsitellään ja talletetaan tässä palvelussa! Arvosteluihin käytettävä entiteetti <code>Rating</code> ja siihen liittyvät palveluluokat on valmiina tehtäväpohjassa.</p>
		  
                  <p><strong>Huom!</strong> Joudut tutkimaan tehtäväpohjassa annettua koodia, jotta voit hyödyntää sitä. Joudut myös lukemaan tehtävän <em>Tulospalvelu</em> kuvausta tämän tehtävän toteutuksessa.</p>
		  
                  <p><strong>Huom!</strong> Valmis <em>Tulospalvelu</em>-palvelu löytyy osoitteesta <code>http://wepa-scoreservice-heroku.herokuapp.com/games</code>, joten voit tehdä tämän tehtävän täysin riippumatta tulospalvelu-tehtävästä.</p>
		  
		  
                  <h1>GameRestClient ja GameController</h1>
		  
                  <p>Tee luokka <code>wad.service.GameRestClient</code>, joka toteuttaa rajapinnan <code>GameService</code>. Luokan tulee käyttää <em>Tulospalvelu</em>-palvelua kaikissa rajapinnan määrittelemissä toiminnoissa. REST-rajapinnan käyttö onnistuu Springin <code>RestTemplate</code>-luokan avulla.</p>
		  
                  <p><strong>Huom!</strong> <code>GameRestClient</code>-luokan <code>setUri</code>-metodi ottaa parametriksi yllä annetun URL-osoitteen valmiiseen <em>Tulospalvelu</em>-palveluun.</p>
		  
                  <p>Luo luokka <code>wad.controller.GameController</code>, joka tarjoaa <strong>täsmälleen samanlaisen</strong> JSON/REST-rajapinnan kuin <em>Tulospalvelu</em>-palvelun <code>GameController</code>, mutta siten, että jokainen toiminto käyttää valmista <em>Tulospalvelu</em>-palvelua rajapinnan <code>GameService</code> kautta.</p>
		  
                  <p><strong>Huom!</strong> Muista asettaa <code>GameService</code>-rajapinnan kautta URL-osoite valmiiseen <code>http://wepa-scoreservice-heroku.herokuapp.com/games</code>-osoitteeseen ohjelman käynnistyessä, esimerkiksi controller-luokan <code>@PostConstruct</code>-metodissa.</p>
		  
		  
                  <h1>RatingController</h1>
		  
                  <p>Jokaiselle pelille voidaan tallettaa pelikohtaisia arvosteluja entiteetin <code>Rating</code> avulla. Arvosteluun liittyy numeroarvosana <code>rating</code> (0-5).</p>
		  
                  <p>Arvostelut liittyvät peleihin, jotka on talletettu eri palveluun, joten entiteetin <code>Rating</code> viittaus peliin täytyy tallettaa suoraan avaimena. Koska peleihin viitataan REST-rajapinnassa pelin nimellä, talletetaan jokaiseen <code>Rating</code>-entiteettiin pelin nimi attribuuttiin <code>gameName</code>. Tämän attribuutin avulla voidaan siis löytää arvosteluja pelin nimen perusteella.</p>
		  
                  <p>Toteuta luokka <code>wad.controller.RatingController</code>, joka tarjoaa REST-rajapinnan arvostelujen käsittelyyn:</p>
		  
                  <ul>
                    <li><code>POST /games/{name}/ratings</code> luo uuden arvostelun pelille <code>name</code> - ainoa vastaanotettava attribuutti on <code>rating</code></li>
                    <li><code>GET /games/{name}/ratings</code> listaa talletetut arvostelut pelille <code>name</code></li>
                    <li><code>GET /games/{name}/ratings/{id}</code> palauttaa yksittäisen arvostelun tiedot pelin nimen <code>name</code> ja avaimen <code>id</code> perusteella</li>
                    <li><code>DELETE /games/{name}/ratings/{id}</code> poistaa avaimen <code>id</code> mukaisen arvostelun</li>
                  </ul>
		  
                </div>
              </div>
            </div>
            
                
	    
            <aside class="info">
	      <br/>
	      
              <h1>Navigoitavuus</h1>
	      
              <p>Tähän asti toteuttamiemme palveluiden tarjoamat rajapinnat eivät ole sisältäneet linkkejä, joiden avulla resurssien välillä navigointi olisi ollut helppoa tai mahdollista. Tutustumme kohta menetelmään, jonka avulla näiden palveluiden tekeminen helpottuu huomattavasti; toinenkin tekniikka on olemassa -- osoitteessa <a href="http://spring.io/guides/gs/rest-hateoas/" target="_blank">http://spring.io/guides/gs/rest-hateoas/</a> kuvataan eräs menetelmä navigoitavan REST-rajapinnan toteuttamiseen.</p>
              
            </aside>
	    
	    
            <h2>REST-palvelun kypsyystasot</h2>
	    
            <p>Martin Fowler käsittelee artikkelissaan <a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">Richardson Maturity Model</a> REST-rajapintojen kypsyyttä. Richardson Maturity Model (RMM) jaottelee REST-toteutuksen kolmeen tasoon, joista kukin tarkentaa toteutusta.</p>
	    
            <p>Aloituspiste on tason 0 palvelut, joita ei pidetä REST-palveluina. Näissä palveluissa HTTP-protokollaa käytetään lähinnä väylänä viestien lähettämiseen ja vastaanottamiseen, ja HTTP-protokollan käyttötapaan ei juurikaan oteta kantaa. Esimerkki tason 0 palvelusta on yksittäinen kontrollerimetodi, joka päättelee toteutettavan toiminnallisuuden pyynnössä olevan sisällön perusteella.</p>
	    
            <p>Tason 1 palvelut käsittelevät palveluita resursseina. Resurssit kuvataan palvelun osoitteena (esimerkiksi <code>/books</code>-resurssi sisältää kirjoja), ja resursseja voidaan hakea tunnisteiden perusteella (esim. <code>/books/nimi</code>). Edelliseen tasoon verrattuna käytössä on nyt konkreettisia resursseja; olio-ohjelmoijan kannalta näitä voidaan pitää myös olioina joilla on tila.</p>
	    
            <p>Tasolla 2 resurssien käsittelyyn käytetään kuvaavia HTTP-pyyntötyyppejä. Esimerkiksi resurssin pyyntö tapahtuu GET-metodilla, ja resurssin tilan muokkaaminen esimerkiksi PUT, POST, tai DELETE-metodilla. Näiden lisäksi palvelun vastaukset kuvaavat tapahtuneita toimintoja. Esimerkiksi jos palvelu luo resurssin, vastauksen tulee olla statuskoodi <code>201</code>, joka viestittää selaimelle resurssin luomisen onnistumisesta. Oleellista tällä tasolla on pyyntötyyppien erottaminen sen perusteella että muokkaavatko ne palvelimen dataa vai ei (GET vs. muut).</p>
	    
            <p>Kolmas taso sisältää tasot 1 ja 2, mutta lisää käyttäjälle mahdollisuuden ymmärtää palvelun tarjoama toiminnallisuus palvelimen vastausten perusteella. Webissä huomiota herättänyt termi <a href="https://weblogs.java.net/blog/mkarg/archive/2010/02/14/what-hateoas-actually-means" target="_blank">HATEOAS</a> käytännössä määrittelee miten web-resursseja tulisi löytää webistä.</p>
	    
	    
            <p>RESTin isä, Roy Fielding, pitää vain tason 3 sovellusta oikeana REST-sovelluksena. Ohjelmistosuunnittelun näkökulmasta jokainen taso parantaa sovelluksen ylläpidettävyyttä -- <em>Level 1 tackles the question of handling complexity by using divide and conquer, breaking a large service endpoint down into multiple resources; Level 2 introduces a standard set of verbs so that we handle similar situations in the same way, removing unnecessary variation; Level 3 introduces discoverability, providing a way of making a protocol more self-documenting.</em> (<a href="http://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank">lähde</a>)</p>
	    
	    
            <p><em>Huom! Sovellusta suunniteltaessa ja toteuttaessa ei tule olettaa että RMM-tason 3 sovellus olisi parempi kuin RMM-tason 2 sovellus. Sovellus voi olla huono riippumatta toteutetusta REST-rajapinnan muodosta -- jossain tapauksissa rajapintaa ei oikeasti edes tarvita; asiakkaan tarpeet ja toiveet määräävät mitä sovelluskehittäjän kannattaa tehdä.</em></p>
	    
	    
	    
            <h2>Spring Data Rest</h2>
	    
            <p>Spring-sovelluskehys sisältää projektin <a href="http://projects.spring.io/spring-data-rest/" target="_blank">Spring Data REST</a>, minkä avulla REST-palveluiden tekeminen helpottuu hieman. Lisäämällä projektin <code>pom.xml</code>-konfiguraatioon riippuvuus <code>spring-boot-starter-data-rest</code> saamme Spring Boot-paketoidun version kyseisestä projektista käyttöömme.</p>
	    
            <pre class="sh_xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

            <p>Nyt Repository-luokkamme tarjoavat automaattisesti REST-rajapinnan, jonka kautta resursseihin pääsee käsiksi. REST-rajapinta luodaan oletuksena sovelluksen juureen, ja tehdään luomalla monikko domain-olioista. Esimerkiksi, jos käytössä on luokka <code>Book</code>, sekä sille määritelty <code>BookRepository</code>, joka perii Spring Data JPA:n rajapinnan, generoidaan rajapinnan <code>/books</code> alle toiminnallisuus kirja-olioiden muokkaamiseen.</p>
	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-esinevarasto">
                      RestItemRepository
                    </a>
                  </h1>
                </header>
                <div id="t-esinevarasto" class="collapse">
		  
                  <p>Luo rajapinta <code>ItemRepository</code>, joka tarjoaa <code>Item</code>-olioiden tietokantatallennustoiminnallisuuden. Lisää tämän jälkeen Spring Data REST-riippuvuus pom.xml-tiedostoon, ja tarkista REST-rajapintasi toiminta esimerkiksi Postman REST Clientin avulla. Wat is this magic?</p>
		  
                </div>
              </div>
            </div>
	    
	    
            <p>Usein käytännössä sovelluksemme kuitenkin toimivat jo palvelun juuripalvelussa, ja haluaisimme esimerkiksi tarjota rajapinnan erillisessä osoitteesssa. Spring Data REST-projektin konfiguraatiota voi muokata erillisen <code>RepositoryRestMvcConfiguration</code>-luokan kautta. Alla olevassa esimerkissä REST-rajapinta luodaan osoitteen <code>/api/v1</code>-alle. Annotaatio <code>@Component</code> kertoo Springille että luokka tulee ladata käyttöön käynnistysvaiheessa; rajapinta kertoo mistä luokasta on kyse.</p>
	    
            <pre class="sh_java">
// pakkaus ja importit

@Component
public class CustomizedRestMvcConfiguration extends RepositoryRestConfigurerAdapter {

    @Override
    public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) {
        config.setBasePath("/api/v1");
    }
}
</pre>
	       
            <p>Nyt jos sovelluksessa on entiteetti <code>Book</code> sekä siihen sopiva <code>BookRepository</code>, on Spring Data REST-rajapinta osoitteessa <code>/api/v1/books</code>.</p>

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-viestiapi">
                      MessageApi
                    </a>
                  </h1>
                </header>
                <div id="t-viestiapi" class="collapse">
		  
                  <p>Tehtävässä on käytössä nyt jo tutuhko viestien kirjoitus- ja lukemispalvelu. Lisää sovellukseen REST-rajapinta viestien käsittelyyn. GET-pyynnön osoitteeseen <code>/api/messages</code> tulee palauttaa lista viesteistä, POST-pyyntö osoitteeseen <code>/api/messages</code> luo uuden viestin, jne.</p>
		  
                </div>
              </div>
            </div>
	    
	    
            <p>Käytännössä sovelluksen kehittäjä ei kuitenkaan tyypillisesti halua kaikkia HTTP-protokollan metodeja kaikkien käyttöön. Käytössä olevien metodien rajaaminen onnistuu käytettävää <code>Repository</code>-rajapintaa muokkaamalla. Alla olevassa esimerkissä <code>BookRepository</code>-rajapinnan olioita ei pysty poistamaan automaattisesti luodun REST-rajapinnan yli.</p>
	    
            <pre class="sh_java">
// pakkaus
import wad.domain.Book;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.rest.core.annotation.RestResource;

public interface BookRepository extends JpaRepository&lt;Message, Long&gt; {

    @RestResource(exported = false)
    @Override
    public void delete(Long id);

}</pre>

            <h3>Spring Data REST ja RestTemplate</h3>

            <p>Spring Data RESTin avulla luotavien rajapintojen hyödyntäminen onnistuu RestTemplaten avulla. Esimerkiksi yllä luotavasta rajapinnasta voidaan hakea <code>Resource</code>-olioita, jotka sisältävät kirjoja. RestTemplaten metodin <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#exchange-java.lang.String-org.springframework.http.HttpMethod-org.springframework.http.HttpEntity-java.lang.Class-java.lang.Object...-" target="_blank">exchange</a></code> palauttaa vastausentiteetin, mikä sisältää hakemamme olion tiedot. Kyselyn mukana annettava <code>ParameterizedTypeReference</code> taas kertoo minkälaiseksi olioksi vastaus tulee muuntaa.</p>
	      
            <pre class="sh_java">
RestTemplate restTemplate = new RestTemplate();
ResponseEntity&lt;Resource&lt;Book&gt;&gt; response = 
    restTemplate.exchange("<em>osoite</em>/books/1", // osoite
                          HttpMethod.GET, // metodi
                          null, // pyynnön runko; tässä tyhjä
                          new ParameterizedTypeReference&lt;Resource&lt;Book&gt;&gt;() {}); // vastaustyyppi

if (response.getStatusCode() == HttpStatus.OK) {
    Resource&lt;Book&gt; resource = response.getBody();
    Book book = resource.getContent();
}
            </pre>



            <aside class="info">
              <h1>HAL</h1>
	      
              <p>HAL on spesifikaatio siitä, miten rajapinnat tulee toteuttaa jotta ne ovat helposti löydettävissä. Spring Data RESTin avulla luodut rajapinnat toteuttavat HAL-spesifikaation -- tutustu spesifikaatioon tarkemmin osoitteessa <a href="http://stateless.co/hal_specification.html" target="_blank">http://stateless.co/hal_specification.html</a>.</p>
	      
              </aside>
	    




	  </section>

          <!-- END OSA4 --->

          <!-- BEGIN OSA5 --->
          <section class="weeklimit" data-week-id="5">
	    
            <header>
              <h1 id="osa5">Osa 5</h1>
            </header>



	    <p>Viides osio alkaa kertaustehtävällä, jossa teemme viestien lisäämiseen ja hakemiseen tarkoitetun REST-rajapinnan. Tämän jälkeen tutustumme pikaisesti mediatyyppeihin sekä tiedostojen tallentamiseen ja lataamiseen, jota seuraa selaimessa tapahtuvaan toimintaan keskittyminen. Osio loppuu web-sovellusten tietoturvaan liittyvällä keskustelulla.</p>
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa4-kertaus-ex" data-count="44">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa4-kertaus">
                      Osa 4, kertaus: MessageService
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa4-kertaus" class="collapse">

                  <p>Toteuta REST-rajapinta valmiiksi annettujen Message-olioiden käsittelyyn. Rajapinnan tarjoamien metodien tulee palauttaa tietoa muodossa <code>application/hal+json;charset=UTF-8</code>, ja viestilista tulee löytyä polusta <code>/messages</code>. Pohdi sovellusta toteuttaessasi minkälaisia muita polkuja sovelluksessa tulee olla, sekä mieti myös niiden tarjoamia toiminnallisuuksia. </p>

                </div>
              </div>
	    </div>



	    <h2>Mediatyypit</h2>

	    
            <p>Pyyntöjä lähetettäessä ja vastaanottaessa palvelin vastaanottaa ja kertoo pyynnön tyypin otsakkeella <code>Content-Type</code>. Tätä tietoa lähetettävän tai vastaanotettavan datan muodosta kutsutaan <a href="http://en.wikipedia.org/wiki/Internet_media_type" target="_blank">mediatyypiksi</a>, millä dataa käsittelevä ohjelmisto voi päättää mitä datalla tehdään. Mediatyyppi sisältää yleensä kaksi osaa; mediatyypin sekä tarkenteen (esim <code>application/json</code>). Kattava lista eri mediatyypeistä löytyy IANA-organisaation ylläpitämästä <a href="http://www.iana.org/assignments/media-types/media-types.xhtml" target="_blank">mediatyyppilistasta</a>.</p>

            <p>Tyypillisiä mediatyyppejä ovat erilaiset kuvat <code>image/*</code>, videot <code>video/*</code>, äänet <code>audio/*</code> sekä erilaiset tekstimuodot kuten JSON <code>application/json</code>.</p>

            <p>Web-palvelut voivat tarjota käytännössä mitä tahansa näistä tiedostotyypeistä käyttäjälle; käyttäjän sovellusohjelmisto päättelee vastauksessa tulevan mediatyypin mukaan osaako se käsitellä tiedoston.</p>

	    <p>Yksinkertaisimmillaan mediatiedoston lähetys palvelimelta toimii Springillä seuraavasti. Oletetaan, että käytössämme on levypalvelin ja polussa <code>/media/data/</code> oleva PNG-kuvatiedosto <code>architecture.png</code>.</p>

<pre class="sh_java">
@RequestMapping(method = RequestMethod.GET, produces = "image/png")
public void copyImage(OutputStream out) throws IOException {
    Files.copy(Paths.get("/media/data/architecture.png"), out);
}</pre>

            <p>Yllä olevassa esimerkissä kerromme että metodi tuottaa <code>image/png</code>-tyyppistä sisältöä. Spring asettaa kontrollerin metodin parametriksi automaattisesti <code>OutputStream</code>-olion, johon pyynnön vastaus voidaan kirjoittaa. <code>Files</code>-luokan tarjoama <code>copy</code>-metodi kopioi kuvan suoraan tiedostosta pyynnön vastaukseksi.</p>

            <p>Ylläolevan kontrollerimetodin palauttaman kuvan voi näyttää osana sivua <code>img</code>-elementin avulla. Jos metodi kuuntelee osoitetta <code>/media/image.png</code>, HTML-elementti <code>&lt;img src="/media/image.png" /&gt;</code> hakee kuvan automaattisesti osoitteesta sivun latautuessa.</p>

            <p>Huom! Jos kuvat ovat staattisia eikä niitä esimerkiksi lisäillä tai poisteta, tulee niiden olla esimerkiksi projektin kansiossa <code>/src/main/resources/public/img</code> -- niille <strong>ei</strong> tule määritellä kontrollerimetodia. Kansion <code>public</code> alla olevat tiedostot kopioidaan web-sovelluksen käyttöön, ja niihin pääsee käsiksi web-selaimella ilman tarvetta kontrollerille.</p>


            <h2>Tiedostojen tallentaminen ja lataaminen</h2>


            <p>Web-sivuilta voi lähettää tiedostoja palvelimelle. Alla oleva lomake HTML-koodi luo lomakkeen, joka voi sisältää myös binääridataa (kts. <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2" target="_blank">multipart/form-data</a>).</p>

<pre class="sh_xml">
&lt;form method="POST" action="/files" enctype="multipart/form-data"&gt;
    &lt;input type="file" name="file" /&gt;
    &lt;input type="submit" value="Send!"/&gt;
&lt;/form&gt;</pre>

            <p>Lomake lähettää tiedot palvelimelle, jonka tulee käsitellä pyyntö. Pyynnön käsittely tapahtuu aivan kuten minkä tahansa muunkin pyynnön, mutta tässä tapauksessa pyynnön parametrin tyyppi on <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/multipart/MultipartFile.html" target="_blank">MultipartFile</a>, joka sisältää lähetettävän tiedoston tiedot.</p>

            <p>Alla oleva kontrollerimetodi vastaanottaa pyynnön, ja tulostaa pyynnössä lähetetyn tiedoston koon ja tyypin. Se ei kuitenkaan tee vielä muuta.</p>

<pre class="sh_java">
@RequestMapping(method = RequestMethod.POST)
public String save(@RequestParam("file") MultipartFile file) {
    System.out.println(file.getSize());
    System.out.println(file.getContentType());

    return "redirect:/files";
}</pre>

            <p>MultipartFile-olio sisältää myös tavutaulukon, missä pyynnössä lähetetty data sijaitsee.</p>

            <p>Tavutaulukon -- eli tässä tapauksessa datan -- tallennus tietokantaan onnistuu seuraavasti. Entiteetti <code>FileObject</code> sisältää tavutaulukon siten, että sen voi tallentaa tietokantaan.</p>

<pre class="sh_java">
import javax.persistence.Entity;
import javax.persistence.Lob;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class FileObject extends AbstractPersistable&lt;Long&gt; {

    @Lob
    private byte[] content;

    // getterit ja setterit
}</pre>        

            <p>Annotaatiolla <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Lob.html" target="_blank">@Lob</a> kerrotaan että annotoitu muuttuja tulee tallentaa tietokantaan isona dataobjektina. Tietokantamoottorit tallentavat nämä tyypillisesti erilliseen isommille tiedostoille tarkoitettuun sijaintiin, jolloin tehokkuus ei juurikaan kärsi erikokoisten kenttien takia.</p>

            <p>Kun entiteetille tekee repository-olion, voi sen ottaa käyttöön myös kontrollerissa. Tietokantaan tallentaminen tapahtuu tällöin seuraavasti:</p>

                <pre class="sh_java">
@RequestMapping(method = RequestMethod.POST)
public String save(@RequestParam("file") MultipartFile file) throws IOException {
    FileObject fo = new FileObject();
    fo.setContent(file.getBytes());

    fileObjectRepository.save(fo);

    return "redirect:/files";
}</pre>

            <p>Tiedoston lähetys kontrollerista onnistuu vastaavasti. Tässä tapauksessa oletamme, että data on muotoa <code>image/png</code>; kontrolleri palauttaa tietokantaoliolta saatavan tavutaulukon pyynnön vastauksen rungossa.</p> 

<pre class="sh_java">
@RequestMapping(value="{id}", method = RequestMethod.GET, produces = "image/png")
@ResponseBody
public byte[] get(@PathVariable Long id) {
    return fileObjectRepository.findOne(id).getContent();
}</pre>        


            <div class="tehtavat">
	      <div class="tehtava">

		<header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-gifbin">
                      GifBin
                    </a>
                  </h1>
                </header>

                <div id="t-gifbin" class="collapse">
                  <p>Tässä tehtävässä toteutetaan sovellus gif-kuvien varastointiin ja selaamiseen.</p>
		  
                  <p>Pääset toteuttamaan huomattavan osan sovelluksesta itse -- tarkista että suunnittelemasi domain-oliot sopivat yhteen annetun näkymän kanssa.</p>

		  
                  <p>Tehtäväpohjassa olevassa <code>gifs.html</code>-sivussa on toiminnallisuus, minkä avulla kuvia näytetään käyttäjälle.</p>
		  
                  <p>Toteuta toiminnallisuus, jonka avulla seuraavat toiminnot ovat käytössä.</p>
		  
                  <ul>
                    <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/gifs</code>, hänet ohjataan osoitteeseen <code>/gifs/1</code>.</li>
                    <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/gifs/{id}</code>, hänelle näytetään sivu <code>gifs</code>. Pyynnön modeliin tulee lisätä attribuutti <code>count</code>, joka sisältää tietokannassa olevien kuvien määrän. Tämän lisäksi, pyyntöön tulee lisätä attribuutti <code>next</code>, joka sisältää seuraavan kuvan tunnuksen -- jos sellainen on olemassa,  attribuutti <code>previous</code>, joka sisältää edeltävän kuvan tunnuksen -- jos sellainen on olemassa, ja <code>current</code>, joka sisältää nykyisen kuvan tunnuksen -- jos sellainen on olemassa.</li>
                    <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/gifs/{id}/content</code>, tulee hänelle palauttaa tunnukslla <code>{id}</code> tietokannassa oleva kuva -- vastauksen mediatyypiksi tulee asettaa myös <code>image/gif</code>.</li>
                  </ul>
		  
                  <p>HTML-sivulla on myös lomake, jonka avulla palvelimelle voi lähettää uusia kuvia. Toteuta palvelimelle toiminnallisuus, jonka avulla osoitteeseen <code>/gifs</code> tehdystä POST-pyynnöstä otetaan sisältö talteen ja tallennetaan se tietokantaa. Huom! Tallenna sisältö vain jos sen mediatyyppi on <code>image/gif</code>. Pyyntö uudelleenohjataan aina lopuksi osoitteeseen <code>/gifs</code>.</p>
		  
                </div>
              </div>
            </div>

	    
            <p>Kun isoja tiedostoja tallennetaan tietokantaan, kannattaa tietokanta suunnitella siten, että tiedostoja ei ladata tietokannasta sellaisten kutsujen yhteydessä, missä niitä ei tarvita. Voimme lisätä olioattribuuteille annotaatiolla <code>@Basic</code> lisämääreen <code>fetch</code>, minkä avulla hakeminen rajoitetaan eksplisiittisiin kutsuihin. Tarkasta tässä vaiheessa edellisen tehtävän mallivastaus -- huomaat että sielläkin -- vaikka annotaatio <code>@Basic</code> ei ollut käytössä -- konkreettinen kuva ladataan hyvin harvoin.</p>

<pre class="sh_java">
import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.Lob;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class FileObject extends AbstractPersistable&lt;Long&gt; {

    @Lob
    @Basic(fetch = FetchType.LAZY)
    private byte[] content;

    // getterit ja setterit
}</pre>

            <p>Ylläoleva <code>@Basic(fetch = FetchType.LAZY)</code> annotaatio pyytää JPA-toteutusta (tapauksessamme Hibernate) luomaan annotoidun olioattribuutin get-metodiin ns. proxymetodin -- data haetaan tietokannasta vasta kun metodia <code>getContent()</code> kutsutaan.</p>


            <h2>Yleiskäyttöinen tiedoston tallennus ja lataaminen</h2>

            <p>Edellisessä esimerkissä määrittelimme kontrollerimetodin palauttaman mediatyypin osaksi <code>@RequestMapping</code> annotaatiota. Usein tiedostopalvelimet voivat kuitenkin palauttaa lähes minkätyyppisiä tiedostoja tahansa. Tutustutaan tässä yleisempään tiedoston tallentamiseen ja lataukseen.</p>

            <p>Käytämme edellisessä esimerkissä käytettyä <code>FileObject</code>-entiteettiä toteutuksen pohjana.</p>

            <p>Jotta voimme kertoa tiedoston mediatyypin, haluamme tallentaa sen tietokantaan. Tallennetaan tietokantaan mediatyypin lisäksi myös tiedoston alkuperäinen nimi sekä tiedoston pituus.</p>

<pre class="sh_java">
import javax.persistence.Basic;
import javax.persistence.Entity;
import javax.persistence.Lob;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class FileObject extends AbstractPersistable&lt;Long&gt; {

    private String name;
    private String mediaType;
    private Long size;

    @Lob
    @Basic(fetch = FetchType.LAZY)
    private byte[] content;

    // getterit ja setterit
}</pre>


            <p>Pääsemme kaikkiin kenttiin käsiksi <code>MultipartFile</code>-olion kautta; muokataan aiemmin näkemäämme kontrolleria siten, että otamme kaikki yllämääritellyt kentät tietokantaan tallennettavaan olioon.</p>


<pre class="sh_java">
@RequestMapping(method = RequestMethod.POST)
public String save(@RequestParam("file") MultipartFile file) throws IOException {
    FileObject fo = new FileObject();

    fo.setName(file.getOriginalName());
    fo.setMediaType(file.getContentType());
    fo.setSize(file.getSize());
    fo.setContent(file.getBytes());

    fileObjectRepository.save(fo);

    return "redirect:/files";
}</pre>


            <p>Nyt tietokantaan tallennettu olio tietää myös siihen liittyvän mediatyypin. Haluamme seuraavaksi pystyä myös kertomaan kyseisen mediatyypin tiedostoa hakevalle käyttäjälle.</p>

            <p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">ResponseEntity</a>-oliota käytetään vastauksen paketointiin; voimme palauttaa kontrollerista ResponseEntity-olion, jonka pohjalta Spring luo vastauksen käyttäjälle. ResponseEntity-oliolle voidaan myös asettaa otsaketietoja, joihin saamme asetettua mediatyypin.</p>

<pre class="sh_java">
@RequestMapping(value = "/{id}", method = RequestMethod.GET)
public ResponseEntity&lt;byte[]&gt; viewFile(@PathVariable Long id) {
    FileObject fo = fileObjectRepository.findOne(id);

    final HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.parseMediaType(fo.getContentType()));
    headers.setContentLength(fo.getSize());

    return new ResponseEntity&lt;&gt;(fo.getContent(), headers, HttpStatus.CREATED);
}</pre>                         

            <p>Ylläolevassa esimerkissä vastaanotetaan pyyntö, minkä pohjalta tietokannasta haetaan FileObject-olio. Tämän jälkeen luodaan otsakeolio <code>HttpHeaders</code> ja asetetaan sille palautettavan datan mediatyyppi ja koko. Lopuksi palautetaan <code>ResponseEntity</code>-olio, mihin data, otsaketiedot ja pyyntöön liittyvä statusviesti (tässä tapauksessa CREATED) liitetään.</p>

            <p>Edeltävä esimerkki ei ota kantaa tiedoston nimeen tai siihen, miten se ladataan. Voimme lisäksi vastaukseen <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html" target="_blank">Content-Disposition</a>-otsakkeen, minkä avulla voidaan ehdottaa tiedoston tallennusnimeä sekä kertoa että tiedosto on liitetiedosto, jolloin se tulee tallentaa.</p>

<pre class="sh_java">
@RequestMapping(value = "/{id}", method = RequestMethod.GET)
public ResponseEntity&lt;byte[]&gt; viewFile(@PathVariable Long id) {
    FileObject fo = fileObjectRepository.findOne(id);

    final HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.parseMediaType(fo.getContentType()));
    headers.setContentLength(fo.getSize());
    headers.add("Content-Disposition", "attachment; filename=" + fo.getName());

    return new ResponseEntity&lt;&gt;(fo.getContent(), headers, HttpStatus.CREATED);
}</pre>                         




            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-filemanager">
                      FileManager
                    </a>
                  </h1>
                </header>
                <div id="t-filemanager" class="collapse">
		  
                  <p>Tässä tehtävässä toteutetaan yleisempi tiedostojen varastointiin ja näyttämiseen käytettävä sovellus.</p>
		  
                  <p>Kuten edellisessä tehtävässä, pääset toteuttamaan huomattavan osan sovelluksesta itse -- tarkista että suunnittelemasi domain-oliot sopivat yhteen annetun näkymän kanssa.</p>
		  
                  <p>Toteuta toiminnallisuus, jonka avulla seuraavat toiminnot ovat käytössä.</p>
		  
                  <ul>
                    <li>Kun käyttäjä tekee GET-tyyppisen pyynnön osoitteeseen <code>/files</code>, pyyntöön lisätään tietokannasta löytyvät tiedostot ja käyttäjä ohjataan sivulle <code>files.html</code>.</li>
                    <li>Kun käyttäjä lähettää lomakkeella tiedoston osoitteeseen <code>/files</code>, pyynnöstä otetaan talteen kaikki tiedot mitä näkymässä halutaan näyttää, ja tallennetaan ne tietokantaan. Pyyntö ohjataan lopuksi uudelleen osoitteeseen <code>/files</code>.</li>
                    <li>Kun käyttäjä klikkaa yksittäiseen tiedostoon liittyvää delete-nappia, tulee tiedosto poistaa tietokannasta. Lopuksi pyyntö uudelleenohjataan osoitteeseen <code>/files</code>.</li>
                    <li>Kun käyttäjä klikkaa yksittäiseen tiedostoon liittyvää nimeä sen lataamista varten, tulee tiedosto lähettää käyttäjälle. Aseta pyyntöön datan lisäksi myös tiedoston mediatyyppi että ja ehdotus tiedoston tallennusnimestä.</li>
                  </ul>
                </div>
              </div>
            </div>

	    
            <h1 data-count="10">Javascript-pohjaiset selainohjelmistot</h1>

	    <p>Tutustutaan seuraavaksi selainpuolen toiminnallisuuden peruspalasiin.</p>


	    <h2>Web-sivujen rakenne</h2>

	    <p>Web-sivut määritellään HTML-kielen avulla. Yksittäinen HTML-dokumentti koostuu sisäkkäin ja peräkkäin olevista elementeistä, jotka määrittelevät sivun rakenteen sekä sivun sisältävän tekstin. Rakenteen määrittelevät elementit erotellaan pienempi kuin (&lt;) ja suurempi kuin (&gt;) -merkeillä. Elementti avataan elementin nimen sisältävällä pienempi kuin -merkillä alkavalla ja suurempi kuin -merkkiin loppuvalla merkkijonolla, esim. <code>&lt;html&gt;</code>, ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva, esim <code>&lt;/html&gt;</code>. Yksittäisen elementin sisälle voi laittaa muita elementtejä.</p>

	    <p>Tyypillisen HTML-dokumentin runko näyttää seuraavalta. Kun klikkaat allaolevassa <code>iframe</code>-elementissä <code>Result</code>-tekstiä, näet HTML-sivun, ja kun painat <code>HTML</code>-tekstiä, näet HTML-koodin. Klikkaamalla elementin oikeassa ylälaidassa olevasta <em>Edit in JSFiddle</em>-linkistä, pääset muokkaamaan elementtiä suoraan JSFiddlessä.</p>

	    <iframe width="100%" height="250" src="http://jsfiddle.net/e3tuhyLz/embedded/html,result" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

	    <p>Yllä olevassa HTML-dokumentissa on dokumentin tyypin kertova erikoiselementti <code>&lt;!DOCTYPE html&gt;</code>, joka kertoo dokumentin olevan HTML-sivu. Tätä seuraa elementti <code>&lt;html&gt;</code>, joka aloittaa HTML-dokumentin. Elementti <code>&lt;html&gt;</code> sisältää yleensä kaksi elementtiä, elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>. Elementti <code>&lt;head&gt;</code> sisältää sivun otsaketiedot, eli esimerkiksi sivun käyttämän merkistön <code>&lt;meta charset="utf-8" /&gt;</code> ja otsikon <code>&lt;title&gt;</code>. Elementti <code>&lt;body&gt;</code> sisältää selaimessa näytettävän sivun rungon. Ylläolevalla sivulla on ensimmäisen tason otsake-elementti <code>h1</code> (<em>header 1</em>) ja tekstielementti <code>p</code> (<em>paragraph</em>).</p>

	    <p>Elementit voivat sisältää <em>tekstisolmun</em>. Esimerkiksi yllä olevat elementit <code>title</code>, <code>h1</code> ja <code>p</code> kukin sisältävät tekstisolmun eli tekstiä. Tekstisolmulle ei ole erillistä elementtiä tai määrettä, vaan se näkyy tekstinä käyttäjälle sivulla olevana tekstinä.</p>

	    <p>Puhe tekstisolmuista antaa viitettä jonkinlaisesta puurakenteesta. HTML-dokumentit ovat rakenteellisia dokumentteja, joiden rakenne on usein helppo ymmärtää puumaisena kaaviona. Ylläolevan web-sivun voi esittää esimerkiksi seuraavanlaisena puuna.</p>

<pre>
                   html

               /          \\

             /              \\

          head              body

        /       \\         /      \\

     meta       title     h1      p

                 :        :       :

              tekstiä  tekstiä tekstiä
</pre>

	    <p>Koska HTML-dokumentti on rakenteellinen dokumentti, on elementtien sulkemisjärjestyksellä väliä. Elementit tulee sulkea samassa järjestyksessä kuin ne on avattu. Esimerkiksi, järjestys <code>&lt;body&gt;&lt;p&gt;whoa, minttutee!&lt/body&gt;&lt;/p&gt;</code> on väärä, kun taas järjestys <code>&lt;body&gt;&lt;p&gt;whoa, minttutee!&lt;/p&gt;&lt/body&gt;</code> on oikea.</p>
	    

	    <p>Kaikki elementit eivät kuitenkaan sisällä tekstisolmua, eikä niitä suljeta erikseen. Yksi näistä poikkeuksista on <a href="http://www.w3schools.com/tags/tag_link.asp" target="_blank">link</a>-elementti.</p>


	    <p>Kun selaimet lataavat HTML-dokumenttia ja muodostavat sen perusteella muistissa säilytettävää puuta, ne käyvät sen läpi ylhäältä alas, vasemmalta oikealle. Kun selain kohtaa elementin, se luo sille uuden solmun. Seuraavista elementeistä luodut solmut menevät aiemmin luodun solmun alle kunnes aiemmin kohdattu elementti suljetaan. Aina kun elementti suljetaan, puussa palataan ylöspäin edelliselle tasolle.</p>



	    <h2>Elementit, attribuutit, nimet ja luokat</h2>


	    <p>Elementit voivat sisältää attribuutteja, joilla voi olla yksi tai useampi arvo. Edellä nähdyssä HTML-dokumentissa elementille <code>meta</code> on määritelty erillinen attribuutti <code>charset</code>, joka kertoo dokumentissa käytettävän merkistön: "utf-8". Vastaavasti tiedon syöttämiseen käytettävien lomakkeiden <code>input</code> ym. kentissä käyttämämme attribuutti <code>name</code> määrittelee nimen, jota käytetään palvelimelle lähetettävän kentän sisällön tunnistamisessa.</p>

	    <p>Muita yleisesti käytettäviä attribuuttityyppejä ovat <code>id</code>, joka määrittelee elementille uniikin tunnisteen sekä <code>class</code>, jonka avulla elementille voidaan määritellä tyyppiluokitus. Uudehkossa HTML5-määritelmässä elementit voivat sisältää myös <code>data</code>-attribuutteja, joiden toiminnallisuutta ei ole ennalta määritelty, ja joita käytetään tyypillisesti sovelluksen toiminnallisuuden takaamiseksi.</p>
	    
	    <p>Kun elementtejä haetaan id-attribuutin perusteella, vastaukseksi pitäisi tulla tyypillisesti vain yksi elementti, mutta class-attribuutin perusteella hakuvastauksia voi olla useampi.</p>

	    <aside class="info">
	    
	      <br/>
	      
	      <h1>Lista attribuuteista</h1>

	      <p>W3Schools-sivusto sisältää hyvän yhteenvedon käytössä olevista attribuuteista: <a href="http://www.w3schools.com/tags/ref_attributes.asp" target="_blank">http://www.w3schools.com/tags/ref_attributes.asp</a>. Lisätietoa data-attribuuteista löytyy osoitteesta <a href="http://www.w3schools.com/tags/att_global_data.asp" target="_blank">http://www.w3schools.com/tags/att_global_data.asp</a>.</p>
	      
	    </aside>
	    

	    <h2>Javascript-kieli</h2>


	    <p>Siinä missä HTML on kuvauskieli web-sivujen rakenteen ja sisällön luomiseen, JavaScript on kieli dynaamisen toiminnan lisäämiselle. JavaScript on ohjelmakoodia, jota suoritetaan komento kerrallaan -- ylhäältä alas, vasemmalta oikealle. JavaScript-koodi suoritetaan käyttäjän omassa selaimessa.</p>

	    <p>JavaScript-tiedoston pääte on yleensä <code>.js</code> ja siihen viitataan elementillä <code>script</code>. Elementillä <code>script</code> on attribuutti <code>src</code>, jolla kerrotaan lähdekooditiedoston sijainti. Kun lisäämme Javascript-koodia web-projektiimme, lisätään se tyypillisesti kansion <code>src/main/resources/public/javascript/</code> alle. Kansiossa <code>public</code> olevat tiedostot siirtyvät suoraan näkyville web-maailmaan, joten niitä ei tarvitse käsitellä erikseen esimerkiksi Thymeleaf-moottorin toimesta.</p>

	    <p>Jos lähdekoodi on kansiossa <code>javascript</code> olevassa tiedostossa <code>code.js</code>, käytetään <code>script</code>-elementtiä seuraavasti: <code>&lt;script th:src="@{/javascript/code.js}"&gt;&lt;/script&gt;</code>.</p>

	    <p>Yleinen käytänne JavaScript-lähdekoodien sivulle lisäämiseen on lisätä ne sivun loppuun juuri ennen <code>body</code>-elementin sulkemista. Tämä johtuu mm. siitä, että selain lähtee hakemaan JavaScript-tiedostoa kun se kohtaa sen määrittelyn HTML-dokumentissa, jolloin kaikki muut toiminnot odottavat latausta. Jos lähdekooditiedosto ladataan vasta sivun lopussa, käyttäjälle <em>näytetään</em> sivun sisältöä jo ennen Javascript-lähdekoodin latautumista, sillä selaimet usein näyttävät sivua käyttäjälle sitä mukaa kun se latautuu. Tällä luodaan tunne nopeammin reagoivista ja latautuvista sivuista.</p>

	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Lataamisen siirtäminen sivun loppuun: määre defer</h1>
	      
	      <p>Nykyään <code>script</code>-elementille voi lisätä määreen <code>defer</code>, jonka olemassaolo kertoo että elementin <code>src</code>-attribuutin määrittelemä tiedosto tulee suorittaa vasta kun html-sivu on käsitelty.</p>

  <pre class="sh_html">
...
&lt;th:src="@{/javascript/code.js}" defer&gt;&lt;/script&gt;
...</pre>

	      <p>Defer-määre on kuitenkin uudehko lisä, eikä se toimi kaikissa selaimissa. <a href="http://www.w3schools.com/tags/att_script_defer.asp" target="_blank">Lisätietoa täältä...</a></p>

	    </aside>


	    <p>Luodaan kansioon <code>javascript</code> lähdekooditiedosto <code>code.js</code>. Tiedostossa <code>code.js</code> on funktio <code>sayHello</code>. Funktio luo ponnahdusikkunan, missä on teksti "hello there".</p>


<pre class="sh_javascript_dom">
function sayHello() {
    alert("hello there");
}
</pre>

	    <p>HTML-dokumentti, jossa lähdekooditiedosto ladataan, näyttää seuraavalta. Attribuutille <code>onclick</code> määritellään elementin klikkauksen yhteydessä suoritettava koodi.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä. Alla on nappi,
            jota painamalla kutsutaan funktiota "sayHello".&lt;/p&gt;
            &lt;input type="button" value="Tervehdi" onclick="sayHello();" /&gt;
        &lt;/article&gt;

        &lt;!-- ladataan JavaScript-koodit tiedoston lopussa! --&gt;
        &lt;script th:src="@{javascript/code.js}"&gt;&lt;/script&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p>Alla sama JSFiddlessä -- siellä kuitenkin <code>code.js</code> samassa kansiossa HTML-tiedoston kanssa:</p>
	    
	    <iframe width="100%" height="200" src="//jsfiddle.net/7ntuqtmL/5/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


	    <aside class="info">
	      <br/>
	      <h1>Javascript-oppaita</h1>
	      
	      <p>Jos Javascript ei ole ennalta tuttu kieli, kannattaa tutustua W3Schools-sivuston tarjoamaan <a href="http://www.w3schools.com/js/" target="_blank">Javascript-oppaaseen</a> sekä kurssin <a href="https://web-selainohjelmointi.github.io/" target="_blank">Web-selainohjelmointi</a> materiaaliin.</p>

	    </aside>



	    <h2>Web-sivujen rakenteen muokkaaminen Javascriptin avulla</h2>


	    <p>JavaScriptiä käytetään ennenkaikkea dynaamisen toiminnallisuuden lisäämiseksi web-sivuille. Esimerkiksi web-sivuilla oleviin elementteihin tulee pystyä asettamaan arvoja, ja niitä tulee myös pystyä hakemaan. JavaScriptissä pääsee käsiksi dokumentissa oleviin elementteihin komennolla <code>document.getElementById("tunnus")</code>, joka palauttaa elementin, jonka <code>id</code>-attribuutti on "tunnus". Muita attribuutti- ja elementtityyppejä pääsee käsittelemään esimerkiksi <a href="http://www.w3schools.com/jsref/met_document_queryselector.asp" target="_blank">querySelector</a>-metodin avulla. </p>

	    <p>Alla on tekstikenttä, jonka HTML-koodi on <code>&lt;input type="text" id="tekstikentta"/&gt;</code>. Kentän tunnus on siis <code>tekstikentta</code>. Jos haluamme päästä käsiksi elementtiin, jonka tunnus on "tekstikentta", käytämme komentoa <code>document.getElementById("tekstikentta")</code>. Tekstikenttäelementillä on attribuutti <code>value</code>, joka voidaan tulostaa.</p>

	    <iframe width="100%" height="200" src="//jsfiddle.net/zL0beedq/10/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


	    <p>Tekstikentälle voidaan asettaa arvo kuten muillekin muuttujille. Alla olevassa esimerkissä haetaan edellisen esimerkin tekstikenttä, ja asetetaan sille arvo <code>5</code>.</p>

	    <iframe width="100%" height="200" src="//jsfiddle.net/zL0beedq/11/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

	    <p>Tehdään vielä ohjelma, joka kysyy käyttäjältä syötettä, ja asettaa sen yllä olevan tekstikentän arvoksi.</p>

	    <iframe width="100%" height="200" src="//jsfiddle.net/zL0beedq/12/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


	    <h3>Arvon asettaminen osaksi tekstiä</h3>

	    
	    <p>Yllä tekstikentälle asetettiin arvo sen <code>value</code>-attribuuttiin. Kaikilla elementeillä ei ole <code>value</code>-attribuuttia, vaan joillain näytetään niiden elementin <em>sisällä</em> oleva arvo. Elementin sisälle asetetaan arvo muuttujaan liittyvällä attribuutilla <code>innerHTML</code>.</p>

	    <p>Alla olevassa esimerkissä sivulla on tekstielementti, jossa ei ole lainkaan sisältöä. Jos tekstielementtiin lisätään sisältöä, tulee se näkyville.</p>


	    <iframe width="100%" height="200" src="//jsfiddle.net/zL0beedq/16/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

	    <p>Vastaavasti tekstin keskelle -- sisäelementtiin -- voi asettaa arvoja. Elementti <code>span</code> sopii tähän hyvin.</p>

	    <iframe width="100%" height="200" src="//jsfiddle.net/zL0beedq/17/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

	    <h3>Case: Laskin</h3>
	    
	    
	    <p>Luodaan laskin. Laskimella on kaksi toiminnallisuutta: pluslasku ja kertolasku. Luodaan ensin laskimelle javascriptkoodi, joka on tiedostossa <code>laskin.js</code>. Javascript-koodissa oletetaan, että on olemassa <code>input</code>-tyyppiset elementit tunnuksilla "eka" ja "toka" sekä <code>span</code>-tyyppinen elementti tunnuksella "tulos". Funktiossa <code>plus</code> haetaan elementtien "eka" ja "toka" arvot, ja asetetaan pluslaskun summa elementin "tulos" arvoksi. Kertolaskussa tehdään lähes sama, mutta tulokseen asetetaan kertolaskun tulos. Koodissa on myös apufunktio, jota käytetään sekä arvojen hakemiseen annetuilla tunnuksilla merkityistä kentistä että näiden haettujen arvojen muuttamiseen numeroiksi.</p>

<pre class="sh_javascript_dom">
function haeNumero(tunnus) {
    return parseInt(document.getElementById(tunnus).value);
}

function asetaTulos(tulos) {
    document.getElementById("tulos").innerHTML = tulos;
}

function plus() {
    asetaTulos(haeNumero("eka") + haeNumero("toka"));
}

function kerto() {
    asetaTulos(haeNumero("eka") * haeNumero("toka"));
}
</pre>

	    <p>Laskimen käyttämä HTML-dokumentti näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;
        &lt;title&gt;Laskin&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Plus- ja Kertolaskin&lt;/h1&gt;
        &lt;/header&gt;

        &lt;section&gt;
            &lt;p&gt;
                &lt;input type="text" id="eka" value="0" /&gt;
                &lt;input type="text" id="toka" value="0" /&gt;
            &lt;/p&gt;

            &lt;p&gt;
                &lt;input type="button" value="+" onclick="plus();" /&gt;
                &lt;input type="button" value="*" onclick="kerto();" /&gt;
            &lt;/p&gt;


            &lt;p&gt;Laskimen antama vastaus: &lt;span id="tulos"&gt;&lt/span&gt;&lt;/p&gt;
        &lt;/section&gt;

        &lt;script src="javascript/laskin.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p>Kokonaisuudessaan laskin näyttää seuraavalta:</p>


	    <iframe width="100%" height="300" src="//jsfiddle.net/o8u0fk36/2/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

	    <p>&nbsp;</p>

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1 class="panel-title">
                    <a data-toggle="collapse" class="collapsed" href="#t-omalaskin">
                      Calculator
                    </a>
                  </h1>
                </header>
                <div id="t-omalaskin" class="collapse">
		  

		  <p>Toteuta edellisen esimerkin perusteella laskin, jossa on plus-, miinus-, kerto- ja jakolaskutoiminnallisuus. Keskity vain selainpuolen toiminnallisuuteen: älä muokkaa palvelinpuolen toiminnallisuutta. Varmista myös, että sivu on käytettävä ilman erillistä ohjetekstiä, eli että käyttämäsi napit ja tekstit kertovat käyttäjälle kaiken oleellisen.</p>

                  <p>Tehtävään ei ole TMC:ssä testejä -- kun sovellus toimii oikein, lähetä se palvelimelle.</p>
		  
                </div>
              </div>
            </div>
	    

	    <h3>Elementtien valinta</h3>

	    <p>Käytimme <code>getElementById</code>-kutsua tietyn elementin hakemiseen. Kaikki sivun elementit voi taas hakea esimerkiksi <code>getElementsByTagName("*")</code>-kutsulla. Molemmat ovat kuitenkin hieman kömpelöjä jos tiedämme mitä haluamme hakea.</p>

	    <p>W3C DOM-määrittely sisältää myös paremman ohjelmointirajapinnan elementtien läpikäyntiin. <a href="http://www.w3.org/TR/selectors-api/" target="_blank">Selectors API</a> sisältää mm. <code>querySelector</code>-kutsun, jolla saadaan CSS-valitsinten kaltainen kyselytoiminnallisuus.</p>
	    
	    <p>Selector APIn tarjoamien <code>querySelector</code> (yksittäisen osuman haku) ja <code>querySelectorAll</code> (kaikkien osumien haku) -komentojen avulla kyselyn rajoittaminen vain <code>header</code>-elementissä oleviin <code>a</code>-elementteihin on helppoa.</p>
	    
<pre class="sh_javascript_dom">
var linkit = document.querySelectorAll("nav a");
// linkit-muuttuja sisältää nyt kaikki a-elementit, jotka ovat nav-elementin sisällä
</pre>

	    <p>Vastaavasti <code>header</code>-elementin sisällä olevat linkit voi hakea seuraavanlaisella kyselyllä.</p>

<pre class="sh_javascript_dom">
var linkit = document.querySelectorAll("header a");
// linkit-muuttuja sisältää nyt kaikki a-elementit, jotka ovat header-elementin sisällä
</pre>


	    <h3>Elementtien lisääminen</h3>

	    <p>HTML-dokumenttiin lisätään uusia elementtejä <code>document</code>-olion <code>createElement</code>-metodilla. Esimerkiksi alla luodaan <code>p</code>-elementti (tekstisolmu; <code>createTextNode</code>), joka asetetaan muuttujaan <code>tekstiElementti</code>. Tämän jälkeen luodaan tekstisolmu, joka sisältää tekstin "o-hai". Lopulta tekstisolmun lisätään tekstielementtiin.</p>

<pre class="sh_javascript_dom">
var tekstiElementti = document.createElement("p");
var tekstiSolmu = document.createTextNode("o-hai");

tekstiElementti.appendChild(tekstiSolmu);
</pre>

	    <p>Ylläoleva esimerkki ei luonnollisesti muuta HTML-dokumentin rakennetta sillä uutta elementtiä ei lisätä osaksi HTML-dokumenttia. Olemassaoleviin elementteihin voidaan lisätä sisältöä elementin <code>appendChild</code>-metodilla. Alla olevan tekstialue sisältää <code>article</code>-elementin, jonka tunnus on <code>dom-esim-3</code>. Voimme lisätä siihen elementtejä elementin <code>appendChild</code>-metodilla.</p>


<pre class="sh_javascript_dom">
var tekstiElementti = document.createElement("p");
var tekstiSolmu = document.createTextNode("o-noes!");

tekstiElementti.appendChild(tekstiSolmu);

var alue = document.getElementById("dom-esim-3");
alue.appendChild(tekstiElementti);
</pre>

	    <p>Artikkelielementin sekä sen sisältämien tekstielementtien lisääminen onnistuu vastaavasti. Alla olevassa esimerkissä käytössämme on seuraavanlainen <code>section</code>-elementti.</p>

<pre class="sh_html">
&lt;!-- .. dokumentin alkuosa .. --&gt;
    &lt;section id="osio"&gt;&lt;/section&gt;
&lt;!-- .. dokumentin loppuosa .. --&gt;
</pre>

	    <p>Uusien artikkelien lisääminen onnistuu helposti aiemmin näkemällämme <code>createElement</code>-metodilla.</p>


<pre class="sh_javascript_dom">
var artikkeli = document.createElement("article");

var teksti1 = document.createElement("p");
teksti1.appendChild(document.createTextNode("Lorem ipsum... 1"));
artikkeli.appendChild(teksti1);

var teksti2 = document.createElement("p");
teksti2.appendChild(document.createTextNode("Lorem ipsum... 2"));
artikkeli.appendChild(teksti2);

document.getElementById("osio").appendChild(artikkeli);
</pre>


	    <p>Alla olevassa esimerkissä elementtejä lisätään yksitellen. Mukana on myös laskuri, joka pitää kirjaa elementtien lukumäärästä.</p>

	    <iframe width="100%" height="300" src="//jsfiddle.net/tus22m5y/1/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	    

	    <h2>jQuery</h2>

	    <p><a href="http://jquery.com/" target="_blank">jQuery</a> on JavaScript-kirjasto, jonka tavoitteena on helpottaa selainohjelmistojen toteutusta. Se tarjoaa apuvälineitä mm. DOM-puun muokkaamiseen, tapahtumien käsittelyyn sekä palvelimelle tehtävien kyselyiden toteuttamiseen, ja sen avulla toteutettu toiminnallisuus toimii myös useimmissa selaimissa.</p>

	    <p>Uusimman jQuery-version saa ladattua <a href="http://jquery.com/download/" target="_blank">täältä</a>. Käytännössä jQuery on JavaScript-tiedosto, joka ladataan sivun latautuessa. Tiedoston voi asettaa esimerkiksi <code>head</code>-elementin sisään, tai ennen omia lähdekooditiedostoja.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
     &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sivun sisältö --&gt;

        &lt;script src="https://code.jquery.com/jquery-3.1.0.min.js"&gt;&lt;/script&gt;
        &lt;script src="javascript/koodi.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


	    <h3>Valitsimet</h3>
    
	    <p>Käytimme edellisissä osioissa valmiita JavaScriptin DOM-toiminnallisuuksia. Elementtien etsimiseen on käytetty mm. <code>getElementById</code>-kutsua. JQuery käyttää <a href="http://sizzlejs.com/" target="_blank">Sizzle</a>-kirjastoa elementtien valinnan helpottamiseen. Esimerkiksi elementti, jonka attribuutin "id" arvo on "nimi", löytyy seuraavalla komennolla.</p>

<pre class="sh_javascript_dom">
var elementti = $("#nimi");
</pre>


	    <p>Kyselyt ovat muotoa<code>$("<em>kysely</em>")</code>. Jos elementtia haetaan <code>id</code>-attribuutin perusteella, lisätään kyselyn alkuun risuaita. Jos elementtiä haetaan luokan (<code>class</code>) perusteella, lisätään kyselyn alkuun piste. Jos taas elementtiä halutaan hakea esimerkiksi nimen perusteella, muodostetaan kysely sekä elementin että attribuutin kautta, esim. <code>$("input[name=nimi]")</code> palauttaa kaikki input-tyyppiset elementit, joissa <code>name</code>-attribuutin arvo on <code>nimi</code>.</p> 

	    <aside class="info">
	      <p><strong>jQueryn valitsimet</strong></p>
	      
	      <p>Tarkempi kuvaus jQueryn valitsimista löytyy osoitteesta <a href="http://api.jquery.com/category/selectors/" target="_blank">http://api.jquery.com/category/selectors/</a>.</p>
	    </aside>


	    <h4>Elementtien lisääminen</h4>
	    
	    <p>JQuery tekee elementtien lisäämisestä hieman suoraviivaisempaa. Voimme kutsun <code>document.createElement</code> sijaan määritellä elementin tyypin sanomalla <code>$("&lt;article /&gt;");</code>. Myös tekstielementin luominen on hieman helpompaa: <code>$("&lt;p/&gt;").text("test");</code>. Aiempi koodimme:</p>

<pre class="sh_javascript_dom">
var artikkeli = document.createElement("article");

var teksti1 = document.createElement("p");
teksti1.appendChild(document.createTextNode("Lorem ipsum... 1"));
artikkeli.appendChild(teksti1);

var teksti2 = document.createElement("p");
teksti2.appendChild(document.createTextNode("Lorem ipsum... 2"));
artikkeli.appendChild(teksti2);

document.getElementById("osio").appendChild(artikkeli);
</pre>

	    <p>Voidaan kirjoittaa myös hieman suoraviivaisemmin:</p>

<pre class="sh_javascript_dom">
var artikkeli = $("&lt;article/&gt;");

var teksti1 = $("&lt;p/&gt;");
teksti1.text("Lorem ipsum... 1");
artikkeli.append(teksti1);

var teksti2 = $("&lt;p/&gt;");
teksti2.text("Lorem ipsum... 2");
artikkeli.append(teksti2);

$("#osio").append(artikkeli);
</pre>


	    <aside class="info">
	      <p><strong>DOM-puun muokkaus</strong></p>
	      
	      <p>Tarkempi kuvaus operaatioista DOM-puun muokkaamiseen löytyy osoitteesta <a href="http://api.jquery.com/category/Manipulation/" target="_blank">http://api.jquery.com/category/Manipulation/</a>.</p>
	      <p>&nbsp;</p>
	      
	    </aside>
	    


	    <h3>Tapahtumien käsittely</h3>


	    <p>JQuery rakentaa JavaScriptin valmiiden komponenttien päälle, joten sillä on toiminnallisuus myös tapahtumankäsittelijöiden rekisteröimiseen sivun komponenteille. Eräs hyvin hyödyllinen tapahtumankäsittelijä liittyy sivun latautumiseen: komennolla <code>$(document).ready(function() {});</code> voidaan määritellä funktion runko, joka suoritetaan kun sivun latautuminen on valmis.</p>

	    <p>Kun sivun latautuminen on valmis, voimme olla varmoja siitä, että sivulla on kaikki siihen kuuluvat elementit. Tällöin on näppärää tehdä myös kyselyjä palvelimelle. Jos haluaisimme että id-attribuutin arvolla "osio" määriteltyyn elementtiin lisättäisiin kaksi tekstielementtiä sisältävä artikkelielementti kun sivu on latautunut, olisi tarvittava Javascript-koodi seuraavanlainen:</p>

<pre class="sh_javascript_dom">
$(document).ready(function() {
  var artikkeli = $("&lt;article/&gt;");

  var teksti1 = $("&lt;p/&gt;");
  teksti1.text("Lorem ipsum... 1");
  artikkeli.append(teksti1);

  var teksti2 = $("&lt;p/&gt;");
  teksti2.text("Lorem ipsum... 2");
  artikkeli.append(teksti2);

  $("#osio").append(artikkeli);
});
</pre>


            <iframe width="100%" height="300" src="//jsfiddle.net/1epmnrd2/embedded/js,html,result/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


	    <aside class="info">
	      <br/>
	      <h1>JSON</h1>
	      
	      <p>JSON, eli <code>JavaScript Object Notation</code>, on tiedon esitysmuoto. Olion määrittely alkaa aaltosululla <code>{</code>, jota seuraa muuttujan nimi ja sille annettava arvo. Arvon asetus oliomuuttujalle tapahtuu kaksoispisteellä, esimerkiksi <code>nimi: "Arvo"</code>. Useampia muuttujia voi määritellä pilkulla eroteltuna. Olion määrittely lopetetaan sulkevaan aaltosulkuun <code>}</code>.</p>

<pre class="sh_javascript_dom">
var olio = {nimi: "Arvo", tieto: 2000};
</pre>

	      <p>Olion muuttujiin pääsee käsiksi piste-notaatiolla. Esimerkiksi <code>olio</code>-olion muuttuja <code>nimi</code> löytyy komennolla <code>olio.nimi</code>.</p>

<pre class="sh_javascript_dom">
var olio = {nimi: "Arvo", tieto: 2000};
alert(olio.nimi);
</pre>

	      <p>Myös uusien oliomuuttujien lisääminen on suoraviivaista. Uuden muuttujan lisääminen tapahtuu myös pistenotaatiolla -- harrastuksen lisääminen tapahtuu <code>olio</code>-oliolle sanomalla <code>olio.harrastus = "koodaus";</code>.</p>

<pre class="sh_javascript_dom">
var olio = {nimi: "Arvo", tieto: 2000};
alert(olio.nimi);
olio.harrastus = "koodaus";
alert(olio.harrastus);
</pre>


	      <p>Olioiden rakennetta ei siis ole lyöty ennalta lukkoon.</p>

	    </aside>

	    
	    <h2>Kyselyt palvelimelle</h2>

	    <p>JQuery tarjoaa myös tuen kyselyjen tekemiseen erilliselle palvelinkomponentille.</p>

	    <p>Kyselyt hoituvat kätevästi JQueryn <code><a href="http://api.jquery.com/jQuery.getJSON/" target="_blank">$.getJSON</a></code>-funktiolla. Alla olevassa esimerkissä haemme <a href="http://www.icndb.com/" target="_blank">ICNDb.com</a>ista oleellista dataa.</p>

	    <p>Kyselyn palauttama data ohjataan <code>$.getJSON</code>-funktion toisena parametrina määriteltävään funktioon. Alla olevassa esimerkissä kutsumme vain <code>alert</code>-komentoa kaikelle palautettavalle datalle.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.icndb.com/jokes/random/5",
    function(data) {
        alert(data);
    }
);
</pre>

	    <p>Ylläoleva esimerkki tulostaa vastaukset konsoliin -- huomaa, että jQuery muuntaa merkkijonomuotoiset vastaukset automaattisesti JSON-olioksi. Käytetään JQueryn <code>each</code>-komentoa listassa olevien elementtien iterointiin. Komennolle <code>each</code> voi antaa parametrina iteroitavan listan, sekä funktion, jota kutsutaan jokaisella listassa olevalla oliolla.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.icndb.com/jokes/random/5",
    function(data) {
        $.each(data.value, function(i, item) {
            alert(i);
            alert(item);
            alert("-----");
        });
    }
);
</pre>

	    <p>Nyt ylläoleva komento tulostaa vastauksen value-kentässä olevat oliot yksitellen. Oletetaan, että käytössämme on elementti, jonka tunnus on "vitsit". JQuery tarjoaa myös mahdollisuuden nopeaan tekstielementtien luontiin komennolla <code>$("&lt;p/&gt")</code>. Elementteihin voi asettaa tekstin <code>text</code>-komennolla, ja elementin voi lisätä tietyllä tunnuksella määriteltyyn elementtiin komennolla <code>appendTo("#<em>tunnus</em>")</code>.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.icndb.com/jokes/random/5",
    function(data) {
        $.each(data.value, function(i, item) {
            $("&lt;p/&gt;").text(item.joke).appendTo("#vitsit");
        });
    }
);
</pre>

            <h3>Tiedon lähettäminen palvelimelle</h3>


	    <p>Jos tiedämme, että palvelu palauttaa JSON-dataa, voimme käyttää yllä käsiteltyä lähestymistapaa. Esimerkiksi viestien noutaminen Chat-chat -tehtävän viestipalvelimelta onnistuu seuraavalla komennolla. Tässä tapauksessa lisäämme jokaiseen viestiin liittyvän <code>message</code>-attribuutin "vitsit"-tunnuksella määriteltyyn elementtiin. Osoitteessa <a href="http://bad.herokuapp.com/app/messages" target="_blank">http://bad.herokuapp.com/app/messages</a> on valmiina viestejä tarjoava sovellus.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://bad.herokuapp.com/app/messages", function(data) {
    $.each(data, function(i, item) {
        $("&lt;p/&gt;").text(item.message).appendTo("#vitsit");
    });
});
</pre>

	    <p>Yllä oleva komento on lyhenne alla määritellystä komennosta.</p>

<pre class="sh_javascript_dom">
$.ajax({
    url: "http://bad.herokuapp.com/app/messages",
    dataType: 'json',
    success: parseMessages
});

function parseMessages(messages) {
    $.each(messages, function(i, item) {
        $("&lt;p/&gt;").text(item.message).appendTo("#vitsit");
    });
}
</pre>

	    <p>Komennolle <code><a href="http://api.jquery.com/jQuery.ajax/" target="_blank">$.ajax</a></code> voi lisätä myös dataa, mitä lähetetään palvelimelle. Esimerkiksi seuraavalla komennolla lähetetään osoitteeseen <code>http://bad.herokuapp.com/app/in</code> olio, jonka sisällä on attribuutit <code>name</code> ja <code>details</code>. Lähetettävän datan tyyppi asetetaan attribuutilla <code>contentType</code>, alla ilmoitamme että data on json-muotoista, ja että se käyttää utf-8 -merkistöä. </p>

<pre class="sh_javascript_dom">
var dataToSend = JSON.stringify({
        name: "bob",
        details: "i'm ted"
    });

$.ajax({
    url: "http://bad.herokuapp.com/app/in",
    dataType: 'json',
    contentType:'application/json; charset=utf-8',
    type: 'post',
    data: dataToSend
});
</pre>

	    <p>Pyynnössä voi sekä lähettää että vastaanottaa dataa. Attribuutin <code>success</code> asettaminen ylläolevaan pyyntöön aiheuttaa success-attribuutin arvona olevan funktion kutsun kun pyyntö on onnistunut.</p>


	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1 class="panel-title">
                    <a data-toggle="collapse" class="collapsed" href="#t-tehtavalista">
                      Tasks
                    </a>
                  </h1>
                </header>
                <div id="t-tehtavalista" class="collapse">
		  
		  <p>Tehtävään on hahmoteltu tehtävien hallintaan tarkoitetun sovelluksen palvelinpuolen toiminnallisuutta. Lisää sovellukseen selainpuolen toiminnallisuus, joka mahdollistaa tehtävien lisäämisen sivulle Javascriptin avulla. Uusien tehtävien lisäämisen ei siis pidä aiheuttaa sivun uudelleenlatausta, vaan uusi tehtävä tulee lähettää palvelimelle Javascript-pyyntönä.</p>
		  
		  <p>Kun saat sovelluksen toimimaan, mieti myös sen käytettävyyttä. Sovellukselle ei ole automaattisia testejä.</p>
		  
                </div>
              </div>
            </div>
	    


	    <h2>Rajoitettu pääsy resursseihin</h2>

	    <p>Web-sivun julkisesti näkyvillä oleviin tietoihin kuten kuviin ja videoihin pääsee käsiksi lähes mistä tahansa palvelusta: esimerkiksi sivun lähdekoodissa oleva jQuery-kirjasto voi olla sovelluksesta erillisellä palvelimella. Tämä on hyödyllistä, sillä tällöin resursseja voidaan hajauttaa ympäri verkkoa ja yksittäisen palvelimen ei tarvitse lähettää kaikkea tietoa sivuston käyttäjälle.</p>

	    <p>Javascript-lähdekoodissa tehdyt pyynnöt ovat kuitenkin oletuksena rajoitettuja. Jos palvelimelle ei määritellä erillistä <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cors.html" target="_blank">CORS</a>-tukea, eivät selaimen sovelluksen osoitteen ulkopuolelta tekemät Javascript-pyynnöt sovellukseen onnistu.</p>

	    <p>Yksinkertaisimmillaan CORS-tuen saa lisättyä kontrollerimetodille annotaation <code>@CrossOrigin</code>-avulla, jolle määritellään osoitteet, joissa sijaitsevista osoitteista pyyntöjä saa tehdä.</p>

<pre class="sh_java">
    @CrossOrigin(origins = "/**")
    @RequestMapping(method=RequestMethod.GET)
    @ResponseBody
    public Book getBook() {
        Book book = new Book();
        book.setName("Spring API");
        return book;
    }</pre>


	    <p>Koko sovelluksen tasolla vastaavan määrittelyn voi tehdä erillisen konfiguraatiotiedoston avulla.</p>

<pre class="sh_java">
@Configuration
@EnableWebMvc
public class WebConfig extends WebMvcConfigurerAdapter {

	@Override
	public void addCorsMappings(CorsRegistry registry) {
		registry.addMapping("/**");
	}
}</pre>

	    <p>Nyt sovellukseen voi tehdä Javascript-pyynnön missä tahansa sijaitsevasta sovelluksesta.</p>



	    <h1>Web-sovellusten tietoturva</h1>

<!--
	    <p>Selainpuoli liittyy käytettävyyteen, palvelinpuoli tietoturvaan.</p>


	    <p>tietovuokaavioiden käyttö riskikohtien tunnistamiseen</p>
-->

	    <p>Tutustutaan tässä web-sovellusten tietoturvaan liittyviin teemoihin. Aloita katsomalla Juhani Erosen ARTTech-seminaari aiheesta <a href="https://www.youtube.com/watch?v=-51nIz8pz08" target="_blank">Your privacy is protected by .. what exactly?</a>.</p>


            <h2>Suojattu yhteys</h2>


            <p>Kommunikointi selaimen ja palvelimen välillä halutaan salata käytännössä aina. HTTPS on käytännössä HTTP-pyyntöjen tekemistä SSL (tai TLS)-salauksella höystettynä. HTTPS mahdollistaa sekä käytetyn palvelun verifioinnin sertifikaattien avulla että lähetetyn ja vastaanotetun tiedon salauksen.</p>

            <p>HTTPS-pyynnöissä asiakas ja palvelin sopivat käytettävästä salausmekanismista ennen varsinaista kommunikaatiota. Käytännössä selain ottaa ensiksi yhteyden palvelimen HTTPS-pyyntöjä kuuntelevaan porttiin (yleensä 443), lähettäen palvelimelle listan selaimella käytössä olevista salausmekanismeista. Palvelin valitsee näistä parhaiten sille sopivan (käytännössä vahvimman) salausmekanismin, ja lähettää takaisin salaustunnisteen (palvelimen nimi, sertifikaatti, julkinen salausavain). Selain ottaa mahdollisesti yhteyttä sertifikaatin tarjoajaan -- joka on kolmas osapuoli -- ja tarkistaa onko sertifikaatti kunnossa.</p>

            <p>Selain lähettää tämän jälkeen palvelimelle salauksessa käytettävän satunnaisluvun palvelimen lähettämällä salausavaimella salattuna. Palvelin purkaa viestin ja saa haltuunsa selaimen haluaman satunnaisluvun. Viesti voidaan nyt lähettää salattuna satunnaislukua ja julkista salausavainta käyttäen.</p>

            <p>Käytännössä kaikki web-palvelimet tarjoavat HTTPS-toiminnallisuuden valmiina, joskin se täytyy ottaa palvelimilla käyttöön. Esimerkiksi Herokussa HTTPS on oletuksena käytössä sovelluksissa -- aiemmin mahdollisesti tekemääsi sovellukseen pääsee käsiksi siis myös osoitteen <code>https://sovelluksen-nimi.herokuapp.com</code> kautta. Tämä ei kuitenkaan estä käyttäjiä tekemästä pyyntöjä sovellukselle ilman HTTPS-yhteyttä -- jos haluat, että käyttäjien tulee tehdä kaikki pyynnöt HTTPS-yhteyden yli, lisää tuotantokonfiguraatioon seuraava rivi.</p>

<pre>
security.require-ssl=true
</pre>


            <h3>HSTS</h3>

	    <p>HTTPS-yhteyden pakottaminen ei aina riitä. Jos ilkeämielinen henkilö pääsee käsiksi ensimmäiseen HTTP-pyyntöön, joka ohjaisi käyttäjän tekemään HTTPS-pyyntöjä palvelimelle, ovat HTTPS-pyynnötkin riskialttiita. HSTS-politiikka, missä sovellus kertoo käyttäjälle vaativansa aina HTTPS-protokollan käytön on eräs ratkaisu tähän. Tällöin selaimen muistiin jää tieto siitä, että selaimen tulee käyttää HTTPS-protokollaa sovelluksessa -- jos sovellus yrittää tarjota jotain muuta, tietää selain, että jotain on pielessä. Tästä lisää <a href="https://tools.ietf.org/html/rfc6797" target="_blank">https://tools.ietf.org/html/rfc6797</a>.</p>

	    
	    <aside class="info">
	      <br/>
	      <h1>Muutama sana turvallisesta verkkoyhteydestä</h1>

	      <p>Jos yhteys selaimen ja sovelluksen välissä on kunnossa, on tilanne melko hyvä. Tässä välissä on hyvä kuitenkin mainita myös avointen verkkoyhteyksien käytöstä.</p>

	      <p>Jos selaimen käyttäjä käyttää sovellusta avoimen (salasanattoman) langattoman verkkoyhteyden kautta, voi lähetettyjä viestejä kuunnella (ja muokata) käytännössä kuka tahansa. Avoimissa verkoissa käyttäjä kirjautuu siihen verkkoon, jonka signaali on vahvin. Jos ilkeämielinen henkilö rakentaa samannimisen verkon ja saa verkkoyhteyden signaalin vahvemmaksi kuin olemassaolevassa verkossa, ottaa käyttäjän käyttöjärjestelmä yhteyden ilkeämielisen henkilön verkkoon. Tällöin ilkeämielinen henkilö voi myös kuunnella verkkoliikennettä halutessaan.</p>

	      <p>Tähän liittyvä hieman humoristinen esitys <a href="https://www.youtube.com/watch?v=rJ5jILY1vlw" target="_blank">DEF CON</a>-konferenssissa.</p>

	    </aside>


	    <h2>Syötteiden validointi</h2>

		
            <p>Lomakkeiden ja lähetettävän datan validointi, eli oikeellisuuden tarkistaminen, on tärkeää. Ensimmäinen askel -- jonka olemme jo ottaneet -- on tallennettavan datan esittäminen ohjelmaan liittyvien käsitteiden kautta. Olemme käyttäneet datan tallentamisessa olioita, joihin on määritelty sopivat kenttien tyypit. Tämä helpottaa työtämme jo hieman: esimerkiksi numerokenttiin ei saa asetettua merkkijonoja. Käyttämämme Spring Bootin mukana tulee <a href="http://hibernate.org/" target="_blank">Hibernate</a>-projektin komponentti, joka tarjoaa validointitoiminnallisuuden.</p>

            <p>Validaatiosääntöjen määrittely tapahtuu annotaatioilla. Muokataan alla määriteltyä luokkaa <code>Person</code> siten, että henkilöllä tulee olla henkilötunnus, nimi ja sähköpostiosoite.</p>


            <pre class="sh_java">
// pakkaus jne
public class Person {

    private String socialSecurityNumber;
    private String name;
    private String email;

    // getterit ja setterit
}</pre>


            <p>Sovitaan että henkilötunnus ei saa koskaan olla tyhjä ja sen tulee olla tasan 11 merkkiä pitkä. Nimen tulee olla vähintään 5 merkkiä pitkä, ja korkeintaan 30 merkkiä pitkä, ja sähköpostiosoitteen tulee olla validi sähköpostiosoite. Annotaatio <code>@NotBlank</code> varmistaa ettei annotoitu attribuutti ole tyhjä -- lisätään se kaikkiin kenttiin. Annotaatiolla <code>@Length</code> voidaan määritellä pituusrajoitteita muuttujalle, ja annotaatiolla <code>@Email</code> varmistetaan, että attribuutin arvo on varmasti sähköpostiosoite.</p>


            <pre class="sh_java">
// pakkaus

import org.hibernate.validator.constraints.Email;
import org.hibernate.validator.constraints.Length;
import org.hibernate.validator.constraints.NotBlank;

public class Person {

    @NotBlank
    @Length(min = 11, max = 11)
    private String socialSecurityNumber;

    @NotBlank
    @Length(min = 5, max = 30)
    private String name;

    @NotBlank
    @Email
    private String email;

    // getterit ja setterit</pre>


            <h3>Olion validoinnin päälle kytkeminen tapahtuu kontrollerissa</h3>

            <p>Kontrollerimetodit validoivat olion jos kontrollerimetodissa olevalle <code>@ModelAttribute</code>-annotaatiolla merkatulle oliolle on asetettu myös annotaatio <code>@Valid</code> (<code>javax.validation.Valid</code>).</p>

            <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person) {
        // .. esimerkiksi tallennus ja uudelleenohjaus
    }</pre>

            <p>Spring validoi olion pyynnön vastaanottamisen yhteydessä, mutta validointivirheet eivät ole kovin kaunista luettavaa. Yllä olevalla kontrollerimetodilla virheellisen nimen kohdalla saamme hieman kaoottisen ilmoituksen.</p>

                <pre>
Whitelabel Error Page

This application has no explicit mapping for /error, so you are seeing this as a fallback.

<em>aika</em>
There was an unexpected error (type=Bad Request, status=400).
Validation failed for object='person'. Error count: 1</pre>

	    <p>Virheelle täytyy selvästi tehdä jotain..</p>


            <h3>Validointivirheiden käsittely</h3>


            <p>Validointivirheet aiheuttavat poikkeuksen, joka näkyy ylläolevana virheviestinä, jos niitä ei erikseen käsitellä. Validointivirheiden käsittely tapahtuu luokan <code>BindingResult</code> avulla, joka toimii validointivirheiden tallennuspaikkana. Luokan <code>BindingResult</code> kautta voimme käsitellä virheitä. <code>BindingResult</code>-olio kuvaa aina yksittäisen olion luomisen ja validoinnin onnistumista, ja se tulee asettaa heti validoitavan olion jälkeen. Seuraavassa esimerkki kontrollerista, jossa validoinnin tulos lisätään automaattisesti <code>BindingResult</code>-olioon.</p>

            <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            // validoinnissa virheitä: virheiden käsittely
        }

        // muu toteutus
    }</pre>

            <p>Ylläolevassa esimerkissä kaikki validointivirheet tallennetaan <code>BindingResult</code>-olioon. Oliolla on metodi <code>hasErrors</code>, jonka perusteella päätämme jatketaanko pyynnön prosessointia vai ei. Yleinen muoto lomakedataa tallentaville kontrollereille on seuraavanlainen:</p>

            <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomakesivu";
        }

        // .. esimerkiksi tallennus

        return "redirect:/index";
    }</pre>

            <p>Yllä oletetaan että lomake lähetettiin näkymästä <em>"lomakesivu"</em>: käytännössä validoinnin epäonnistuminen johtaa nyt siihen, että pyyntö ohjataan takaisin lomakesivulle.</p>


            <h3>Thymeleaf-lomakkeet ja BindingResult</h3>


            <p>Lomakkeiden validointivirheet saadaan käyttäjän näkyville Thymeleafin avulla. Lomakkeet määritellään kuten normaalit HTML-lomakkeet, mutta niihin lisätään muutama apuväline. Lomakkeen attribuutti <code>th:object</code> kertoo olion, johon lomakkeen kentät tulee pyrkiä liittämään (huom! tämän tulee olla määriteltynä myös lomakkeen palauttavassa kontrollerimetodissa -- palaamme tähän kohta). Sitä käytetään yhdessä kontrolleriluokan <code>ModelAttribute</code>-annotaation kanssa. Lomakkeen kentät määritellään attribuutin <code>th:field</code> avulla, jossa oleva <code>*{arvo}</code> liitetään lomakkeeseen liittyvään olioon. Oleellisin virheviestin näkymisen kannalta on kuitenkin attribuuttiyhdistelmä <code>th:if="${#fields.hasErrors('arvo')}" th:errors="*{arvo}"</code>, joka näyttää virheviestin jos sellainen on olemassa.</p>

            <p>Luodaan lomake aiemmin nähdyn <code>Person</code>-olion luomiseen.</p>


            <pre class="sh_xml">
&lt;form action="#" th:action="@{/persons}" th:object="${person}" method="POST"&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;SSN: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{socialSecurityNumber}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('socialSecurityNumber')}" th:errors="*{socialSecurityNumber}"&gt;SSN Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Name: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{name}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('name')}" th:errors="*{name}"&gt;Name Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Email: &lt;/td&gt;
            &lt;td&gt;&lt;input type="text" th:field="*{email}" /&gt;&lt;/td&gt;
            &lt;td th:if="${#fields.hasErrors('email')}" th:errors="*{email}"&gt;Email Virheviesti&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;button type="submit"&gt;Submit&lt;/button&gt;&lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;</pre>

            <p>Yllä oleva lomake lähettää lomakkeen tiedot osoitteessa <code>&lt;sovellus&gt;/persons</code> olevalle kontrollerimetodille. Lomakkeelle tullessa tarvitsemme erillisen tiedon käytössä olevasta oliosta. Alla on näytetty sekä kontrollerimetodi, joka ohjaa GET-pyynnöt lomakkeeseen, että kontrollerimetodi, joka käsittelee POST-tyyppiset pyynnöt. Huomaa erityisesti <code>@ModelAttribute</code>-annotaatio kummassakin metodissa. Metodissa <code>view</code> olion nimi on <code>person</code>, joka vastaa lomakkeessa olevaa <code>th:object</code>-attribuuttia. Tämän avulla lomake tietää, mitä oliota käsitellään.</p>

            <pre class="sh_java">
    @RequestMapping(method = RequestMethod.GET)
    public String view(@ModelAttribute Person person) {
        return "lomake";
    }

    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomake";
        }

        // .. tallennus ja uudelleenohjaus
    }</pre>

            <p>Jos lomakkeella lähetetyissä kentissä on virheitä, virheet tallentuvat <code>BindingResult</code>-olioon. Tarkistamme kontrollerimetodissa <code>create</code> ensin virheiden olemassaolon -- jos virheitä on, palataan takaisin lomakkeeseen. Tällöin validointivirheet tuodaan lomakkeen käyttöön <code>BindingResult</code>-oliosta, jonka lomakkeen kentät täytetään <code>@ModelAttribute</code>-annotaatiolla merkitystä oliosta. Huomaa että virheet ovat pyyntökohtaisia, ja uudelleenohjauspyyntö kadottaa virheet.</p>

            <p><strong>Huom!</strong> Springin lomakkeita käytettäessä lomakesivut haluavat käyttöönsä olion, johon data kytketään jo sivua ladattaessa. Yllä lisäsimme pyyntöön <code>Person</code>-olion seuraavasti:</p>

            <pre class="sh_java">
    @RequestMapping(method = RequestMethod.GET)
    public String view(@ModelAttribute Person person) {
        return "lomake";
    }</pre>

            <p>Toinen vaihtoehto on luoda kontrolleriluokkaan erillinen metodi, jonka sisältämä arvo lisätään automaattisesti pyyntöön. Tällöin lomakkeen näyttävä kontrollerimetodi ei tarvitse erikseen ModelAttribute-parametria. Tällöin toteutus olisi esimerkiksi seuraavanlainen:</p>

            <pre class="sh_java">
    @ModelAttribute
    private Person getPerson() {
        return new Person();
    }
        
    @RequestMapping(method = RequestMethod.GET)
    public String view() {
        return "lomake";
    }

    @RequestMapping(method = RequestMethod.POST)
    public String create(@Valid @ModelAttribute Person person, BindingResult bindingResult) {
        if(bindingResult.hasErrors()) {
            return "lomake";
        }

        // .. tallennus ja uudelleenohjaus
    }</pre>


            <p>Thymeleafin avulla tehdyistä lomakkeista ja niiden yhteistyöstä Springin kanssa löytyy lisää osoitteesta <a href="http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#creating-a-form" target="_blank">http://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#creating-a-form</a>.</p>


            <h3>Validointi ja entiteetit</h3>

            <p>Vaikka edellisessä esimerkissä käyttämäämme <code>Person</code>-luokkaa ei oltu merkitty <code>@Entity</code>-annotaatiolla -- eli se ei ollut tallennettavissa JPAn avulla tietokantaan -- mikään ei estä meitä lisäämästä sille <code>@Entity</code>-annotaatiota. Toisaalta, lomakkeet voivat usein sisältää tietoa, joka liittyy useaan eri talletettavaan olioon. Tällöin voi luoda erillisen lomakkeen tietoihin liittyvän <em>lomakeolio</em>, jonka pohjalta luodaan tietokantaan tallennettavat oliot kunhan validointi onnistuu. Erilliseen lomakeobjektiin voi täyttää myös kannasta haettavia listoja ym. ennalta.</p>

            <p>Kun validointisäännöt määritellään entiteetille, tapahtuu validointi kontrollerin lisäksi myös tietokantatallennusten yhteydessä.</p>

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1 class="panel-title">
                    <a data-toggle="collapse" class="collapsed" href="#t-ilmoittautuminen">
                      Registration
                    </a>
                  </h1>
                </header>
                <div id="t-ilmoittautuminen" class="collapse">
		  
                  <p>Tehtävän mukana tulee sovellus, jota käytetään ilmoittatumiseen. Tällä hetkellä käyttäjä voi ilmoittautua juhliin oikeastaan minkälaisilla tiedoilla tahansa. Tehtävänäsi on toteuttaa parametreille seuraavanlainen validointi:</p>
		  
                  <ol>
                    <li>Nimen (<code>name</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 30 merkkiä pitkä.</li>
                    <li>Osoitteen (<code>address</code>) tulee olla vähintään 4 merkkiä pitkä ja enintään 50 merkkiä pitkä.</li>
                    <li>Sähköpostiosoitteen (<code>email</code>) tulee olla validi sähköpostiosoite.</li>
                  </ol>
		  
		  
                  <p>Tehtäväpohjan mukana tuleviin sivuihin on toteutettu valmiiksi lomake. Tehtävänäsi on toteuttaa validointitoiminnallisuus pakkauksessa <code>wad.domain</code> olevaan luokkaan <code>Registration</code>.</p>
		  
                  <p>Jos yksikin tarkastuksista epäonnistuu, tulee käyttäjälle näyttää rekisteröitymislomake uudelleen. Muista lisätä kontrolleriin validoitavalle parametrille annotaatio <code>@Valid</code>. Virheviestien ei tule näkyä vastauksessa jos lomakkeessa ei ole virhettä. Käyttöliittymä on tehtävässä valmiina.</p>
		  
                </div>
              </div>
            </div>
	    

	    
	    <h2>Käyttäjätunnukset ja pääsynvalvonta</h2>

	    <p>Tutustuimme aiemmin käyttäjän tunnistamiseen eli autentikointiin. Autentikoinnin lisäksi sovelluksissa on tärkeää varmistaa, että käyttäjä saa tehdä asioita, joita hän yrittää tehdä: autorisointi. Jos käyttäjän tunnistaminen toimii mutta sovellus ei tarkista oikeuksia tarkemmin, on mahdollista päätyä esimerkiksi tilanteeseen, missä <a href="http://www.telegraph.co.uk/technology/facebook/10251869/Mark-Zuckerberg-Facebook-profile-page-hacked.html" target="_blank">käyttäjä pääsee tekemään epätoivottuja asioita</a>. </p>


	    <h3>Muutama sana salasanoista</h3>

	    <p>Salasanoja ei tule tallentaa selväkielisenä tietokantaan. Salasanoja ei tule -- myöskään -- tallentaa salattuna tietokantaan ilman, että niihin on lisätty erillinen "suola", eli satunnainen merkkijono, joka tekee salasanasta hieman vaikeammin tunnistettavan.</p>

	    <p>Vuonna 2010 tehty tutkimus vihjasi, että noin 75&#37; ihmisistä käyttää samaa salasanaa sähköpostissa ja sosiaalisen median palveluissa. Jos käyttäjän sosiaalisen median salasana vuodetaan selkokielisenä, on siis mahdollista, että samalla myös hänen salasana esimerkiksi Facebookiin tai Google Driveen on päätynyt julkiseksi tiedoksi. Jos ilman "suolausta" salattu salasana vuodetaan, voi se mahdollisesti löytyä verkossa olevista valmiista salasanalistoista, mitkä sisältävät salasana-salaus -pareja. <a href="http://wpengine.com/unmasked/" target="_blank">Jostain syystä salasanat ovat myös usein ennustettavissa.</a></p>

	    <p>Suolan lisääminen salasanaan ei auta tilanteissa, missä salasanat ovat ennustettavissa, koska salasanojen koneellinen läpikäynti on melko nopeaa. Salausmenetelmänä kannattaakin käyttää sekä salasanan suolausta, että algoritmia, joka on hidas laskea. Eräs tällainen on jo valmiiksi Springin kautta käyttämämme <a href="https://en.wikipedia.org/wiki/Bcrypt" target="_blank">BCrypt</a>-algoritmi.</p>


	    <figure>

	      <img src="http://imgs.xkcd.com/comics/password_strength.png">

	      <figcaption>https://xkcd.com/936/ -- xkcd: Password strength. </figcaption>
	      
	    </figure>


            <h3>Näkymätason autorisointi</h3>

	    <p>Määrittelimme aiemmin oikeuksia sovelluksen polkuihin liittyen. Tämä ei kuitenkaan aina riitä, vaan käyttöliitymissä halutaan usein rajoittaa toiminta esimerkiksi käyttäjäroolien perusteella. Thymeleaf-projektiin löytyy liitännäinen, jonka avulla voimme lisätä tarkistuksia HTML-sivuille. Liitännäisen saa käyttöön lisäämällä seuraavan riippuvuuden <code>pom.xml</code>-tiedostoon.</p>

            <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.thymeleaf.extras&lt;/groupId&gt;
    &lt;artifactId&gt;thymeleaf-extras-springsecurity4&lt;/artifactId&gt;
&lt;/dependency&gt;   
            </pre>                            

	    <p>Kun näkymiien <code>html</code>-elementtiin lisätään <code>sec:</code>-nimiavaruuden määrittely, voidaan sivulle määritellä elementtejä, joiden sisältö näytetään vain esimerkiksi tietyllä roolilla kirjautuneelle käyttäjälle. Seuraavassa esimerkissä teksti "salaisuus" näkyy vain käyttäjälle, jolla on rooli "ADMIN".</p>

            <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" 
    xmlns:th="http://www.thymeleaf.org" 
    xmlns:sec="http://www.springframework.org/security/tags"&gt;

...
&lt;div sec:authorize="hasAuthority('ADMIN')"&gt;
    &lt;p&gt;salaisuus&lt;/p&gt;
&lt;/div&gt;
...
            </pre>                            
	    
            <p>Attribuutilla <code>sec:authorize</code> määritellään säännöt, joita tarkistuksessa käytetään. Attribuutille käy mm. arvot <code>isAuthenticated()</code>, <code>hasAuthority('...')</code> ja <code>hasAnyAuthority('...')</code>. Lisää sääntöjä löytyy Spring Securityn <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/el-access.html" target="_blank">dokumentaatiosta</a>.</p>

	    <aside class="info">
	      <br/>
	      <h1>Näkymän muutokset liittyvät käytettävyyteen</h1>

	      <p>Edellä lisätty toiminnallisuus liittyy sovelluksen käytettävyyteen. Vaikka linkkiä ei näytettäisi osana sivua, kuka tahansa voi muokata sivun rakennetta selaimellaan. Tällöin pyynnön voi myös tehdä osoitteeseen, jota sivulla ei aluksi näy. </p>

	      <p>Tämä pätee oikeastaan kaikkeen selainpuolen toiminnallisuuteen. Web-sivuilla Javascriptin avulla toteutettu dynaaminen toiminnallisuus on hyödyllistä käytettävyyden kannalta, mutta se ei millään tavalla takaa, että sovellus olisi turvallinen käyttää. Tietoturva toteutetaan suurelta osin palvelinpäässä.</p>

	    </aside>


            <h3>Metoditason autorisointi</h3>

            <p>Pelkän näkymätason autorisoinnin ongelmana on se, että usein toimintaa halutaan rajoittaa tarkemmin -- esimerkiksi siten, että tietyt operaatiot (esim. poisto tai lisäys) mahdollistetaan vain tietyille käyttäjille tai käyttäjien oikeuksille. Käyttöliittymän näkymää rajoittamalla ei voida rajoittaa kutsuja polkuihin, ja aiemmin luotu polkuihin tehtävien kutsujen rajoitus ei auta esimerkiksi REST-tyyppisissä osoitteissa, varsinkin jos GET-pyyntöihin halutaan oikeus kaikille.</p>

            <p>Saamme sovellukseemme käyttöön myös metoditason autorisoinnin. Lisäämällä tietoturvakonfiguraatiotiedostoon luokkatason annotaation <code>@EnableGlobalMethodSecurity(securedEnabled = true, proxyTargetClass = true)</code>, Spring Security etsii metodeja, joissa käytetään sopivia annotaatioita ja suojaa ne. Suojaus tapahtuu käytännössä siten, että metodeihin luodaan proxy-metodit; aina kun metodia kutsutaan, kutsutaan ensin tietoturvakomponenttia, joka tarkistaa onko käyttäjä kirjautunut.</p>

            <p>Kun konfiguraatiotiedostoon on lisätty annotaatio, on käytössämme muunmuassa annotaatio <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/jc.html#jc-method" target="_blank">@Secured</a>. Alla olevassa esimerkissä <code>post</code>-metodin käyttöön vaaditaan "ADMIN"-oikeudet.</p>

            <pre class="sh_java">
    @Secured("ADMIN")
    @RequestMapping(method = RequestMethod.POST)
    public String post() {
        // ..
        return "redirect:/posts";
    }
            </pre>                            

	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hiddenfields">
                      Hidden fields
                    </a>
                  </h1>
                </header>
                <div id="t-hiddenfields" class="collapse">
		  
                  <p>Tehtävässä on hahmoteltu viestien näyttämiseen tarkoitettua sovellusta.</p>
		  
                  <p>Luo sovellukseen tietoturvakonfiguraatio, missä määritellään kaksi käyttäjää. Ensimmäisellä käyttäjällä "user", jonka salasana on "password" on "USER"-oikeus. Toisella käyttäjällä "postman", jonka salasana on "pat", on "POSTER"-oikeus.</p>
		  
                  <p>Muokkaa näkymää <code>messages.html</code> siten, että vain käyttäjät, joilla on "POSTER"-oikeus näkee lomakkeen, jolla voi lisätä uusia viestejä.</p>
		  
                  <p>Muokkaa lisäksi konfiguraatiota siten, että käyttäjä voi kirjautua ulos osoitteesta <code>/logout</code>. Voit käyttää seuraavaa koodia (joutunet lisäämään konfiguraatioon muutakin..). </p>

                  <pre class="sh_java">
http.formLogin()
    .permitAll()
    .and()
    .logout()
    .logoutUrl("/logout")
    .logoutSuccessUrl("/login");</pre>                                            


                  <p>Lisää tämän jälkeen sovellukseen metoditason suojaus millä rajoitat POST-pyyntöjen tekemisen osoitteeseen <code>/message</code> vain käyttäjille, joilla on "POSTER"-oikeus. Vaikka testit päästäisivät sinut läpi jo ennen tämän toteutusta, tee se silti.</p>

                </div>
              </div>
            </div>
	    

            <p>Käyttäjän identiteetin varmistaminen vaatii käyttäjälistan, joka taas yleensä ottaen tarkoittaa käyttäjän rekisteröintiä jonkinlaiseen palveluun. Käyttäjän rekisteröitymisen vaatiminen heti sovellusta käynnistettäessä voi rajoittaa käyttäjien määrää huomattavasti, joten rekisteröitymistä kannattaa pyytää vasta kun siihen on tarve.</p>

            <p>Erillinen rekisteröityminen ja uuden salasanan keksiminen ei ole aina tarpeen. Web-sovelluksille on käytössä useita kolmannen osapuolen tarjoamia keskitettyjä identiteetinhallintapalveluita. Esimerkiksi <a href="http://oauth.net/2/" target="_blank">OAuth2</a>:n avulla sovelluskehittäjä voi antaa käyttäjilleen mahdollisuuden käyttää jo olemassaolevia tunnuksia. Myös erilaiset sosiaalisen median palveluihin perustuvat autentikointimekanismit ovat yleistyneet viime aikoina.</p>



            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-extauth">
                      External auth
                    </a>
                  </h1>
                </header>
                <div id="t-extauth" class="collapse">
		  
                  <p>Osoitteessa <a href="http://authebin.herokuapp.com/authenticate">http://authebin.herokuapp.com/</a> on rajapinta tunnistautumista varten. Rajapinta olettaa, että sille lähetetään JSON-tyyppinen käyttäjätunnuksen ja salasanan sisältävä pyyntö. Olion muoto on seuraavanlainen:</p>

<pre>
{"username":"tunnus","password":"salasana"}
</pre>

		  
                  <p>Tutustu tehtäväpohjassa olevaan luokkaan <code>CustomAuthenticationProvider</code> sekä sen käyttöön <code>SecurityConfiguration</code>-luokassa. Toteuta toiminnallisuus, minkä avulla käyttäjä voi kirjautua osoitteessa http://authebin.herokuapp.com olevan palvelun avulla. Tässä tehtävässä lienee hyötyä sekä RestTemplate-luokasta että HttpEntity-oliosta.</p>

                  <p>Tehtävässä ei ole testejä. Palauttamalla tehtävän, olet testannut että se toimii toivotusti ja tunnistautuminen kolmannen osapuolen rajapinnan kautta onnistuu.</p>
		  
                </div>
              </div>
            </div>




 
	    <h2>Tietokannan käyttö ja muut kolmannen osapuolen palvelut</h2>

	    <p>Kolmannen osapuolen palveluissa kuten tietokannoissa ja muissa sovelluksissa tulee kiinnittää huomiota yhteyteen sekä tietokannan salasanaan ja konfiguraatioon. Yhteyden tietokantaan kannattaa olla salattu, ja tietokantaa käyttävien käyttäjien oikeudet rajattu niin, että heillä on oikeudet vain tarvitsemiinsa operaatioihin.</p>

	    <p>Esimerkiksi tietokantaan voidaan määritellä yksi käyttäjä, jolla on vain lukuoikeudet tiettyihin tauluihin, ja toinen käyttäjä, joka voi myös kirjoittaa näihin tauluihin. Kaikkia oikeuksia ei kannata antaa kaikille käyttäjille, sillä sovellukseen voi eksyä SQL-injektiomahdollisuus. Tämä tarkoittaa tilannetta, missä sovelluksen käyttäjä pääsee syöttämään tietoa tietokantaan tehtäviin kyselyihin, mikä mahdollistaa esimerkiksi tietokannan tuhoamisen.</p>

	    
	    <figure>

	      <img src="http://imgs.xkcd.com/comics/exploits_of_a_mom.png" alt="School: Hi, this is your son's school. We're having some computer trouble.

Mom: Oh, dear -- Did he break something?

School: In a way. Did you really name your son Robert'); DROP TABLE Students;--?

Mom: Oh. Yes. Little Bobby Tables we call him.

School: Well, we've lost this year's student records. I hope you're happy.

Mom: And I hope you've learned to sanitize your database inputs.">

	      <figcaption>http://xkcd.com/327/ -- Exploits of a Mom. </figcaption>

	    </figure>

	    <p>&nbsp;</p>

	    <p>Spring Data JPA:ta sekä parameterisoituja kyselyitä käytettäessä tämä on onneksi melko vaikeaa.</p>

	    <p>Tietokannanhallintajärjestelmän sisältävään koneeseen tulee muutenkin kiinnittää huomiota. Hyvin toteutettu sovellus, oikein konfiguroitu tietokanta sekä turvallinen yhteys ei auta, jos tietokannanhallintajärjestelmän sisältävässä koneessa on esimerkiksi vanhentunut käyttöjärjestelmä tai toinen sovellus, joiden kautta koneelle pystyy murtautumaan.</p>

	    <h2>Tyypillisimpiä tietoturvauhkia</h2>

            <p>OWASP (<em>Open Web Application Security Project</em>) on verkkosovellusten tietoturvaan keskittynyt kansainvälinen järjestö, jonka tavoitteena on tiedottaa tietoturvariskeistä ja sitä kautta edesauttaa turvallisten web-sovellusten kehitystä. OWASP-yhteisö pitää myös yllä listaa merkittävimmistä web-tietoturvariskeistä. Vuoden 2013 lista on seuraava:</p>

            <ol>
              <li>Injection -- sovellukseen jääneet aukot, jotka mahdollistavat esimerkiksi SQL-injektioiden tekemisen.</li><br/>
              <li>Broken Authentication and Session Management -- autentikaatio esimerkiksi siten, että evästeisiin on helppo päästä käsiksi tai siten, että tieto autentikaatiosta kulkee osoitteessa.</li><br/>
              <li>Cross-Site Scripting (XSS) -- Mahdollisuus syöttää sivulle Javascript-koodia esimerkiksi tekstikentän kautta. Tämä mahdollistaa mm. toisella koneella  olevan Javascript-koodin suorittamisen, tai lomaketietojen lähettämisen kolmannen osapuolen palveluun. </li><br/>
              <li>Insecure Direct Object References -- mahdollisuus päästä käsiksi esimerkiksi palvelimella sijaitseviin tiedostoihin muokkaamalla polkua tai lähettämällä palvelimelle sopivaa dataa. Yksinkertaisin kokeilu lienee <code>../</code>-merkkijonon kokeilemista sovelluksen polussa.</li><br/>
              <li>Security Misconfiguration -- huonosti tehdyt tietoturvakonfiguraatiot.</li><br/>
              <li>Sensitive Data Exposure -- yhteyksien tulee olla suojattu.</li><br/>
              <li>Missing Function Level Access Control -- autorisaatiota ei tapahdu metoditasolla.</li><br/>
              <li>Cross-Site Request Forgery (CSRF) -- sovelluksessa XSS-aukko, joka mahdollistaa epätoivotun pyynnön lähettämisen toiselle palvelimelle. Lomakkeisiin voidaan myös määritellä <a href="http://docs.spring.io/spring-security/site/docs/current/reference/html/csrf.html" target="_blank">erillinen otsaketieto</a>, joka on uniikki ja luodaan sivun latauksen yhteydessä.</li><br/>
              <li>Using Components with Known Vulnerabilities -- sovelluksessa käytetään osia, joissa on tunnettuja tietoturvariskejä. </li><br/>
              <li>Unvalidated Redirects and Forwards -- älä käytä parametreja uudelleenohjauksissa. Riskinä on väärien parametrien syöttäminen ja sitä kautta epätoivottuun tietoon pääseminen.</li><br/>
            </ol>
	    
            <p>Tutustu listaan tarkemmin osoitteessa <a href="https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project">https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project</a>. He tarjoavat dokumentaatiossaan kuvaukset riskeistä, sekä esimerkkejä hyökkäyksistä; <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank">Tässä</a> esimerkki XSS-filtterien kiertämisestä.</p>
	    



	    <aside class="info">
	      <br/>
	      <h1>Palvelinten fyysinen tietoturva</h1>

	      <p>Tietoturvaan keskityttäessä on hyvä muistaa myös fyysinen tietoturva. Jos palvelinsaliin pääsee helposti, voi kuka tahansa kävellä sinne ja ottaa palvelimen kainaloonsa. Tällöin sovellukseen toteutetun tietoturvan hyöty on melko pieni.</p>

	    </aside>



	  </section>

	  <!-- END OSA5 -->


          <!-- BEGIN OSA6 --->
          <section class="weeklimit" data-week-id="6">
	    
            <header>
              <h1 id="osa6">Osa 6</h1>
            </header>

	    <p>Kurssin kuudes osio alkaa edellisen osion sisältöä kertaavalla tehtävällä, missä korjataan erään verkkokauppasovelluksen tietoturvaongelmia. Tämän jälkeen tutustumme skaalautuvien sovellusten rakentamiseen sekä palveluperustaisiin arkkitehtuureihin.</p>





	    <h2>Uhkamallinnus</h2>

	    <p>Uhkamallinnus on lähestymistapa sovelluksen tietoturvan analysointiin. Uhkamallinnuksen voi jakaa kolmeen korkean tason askeleeseen: (1) Sovelluksen komponenttien ja niiden välisen kommunikaation analysointi, (2) Tietoturvariskien tunnistaminen ja niiden priorisointi, sekä (3) Suojamenetelmien tunnistaminen.</p>

	    <p>Sovelluksen komponenttien tunnistamisella sekä niiden välisen kommunikaation analysoinnilla selvitetään sovellukseen liittyvät kirjastot, palvelut sekä kommunikaatiomenetelmät. Tässä tarkastellaan olemassaolevia käyttötapauksia, sekä luodaan myös uusia käyttötapauksia, joiden perusteella päätellään miten järjestelmää käytetään. Samalla tunnistetaan kohdat, joiden kautta hyökkääjä voi päästä järjestelmään käsiksi ja tunnistetaan resurssit, joista hyökkääjä voisi olla kiinnostunut. Askeleen tuloksena on lista sovellukseen liittyvistä kirjastoista, palveluista, kommunikaatiomenetelmistä sekä resursseista, jonka lisäksi jokaisesta järjestelmään pääsyn mahdollistavasta kohdasta sekä järjestelmän resurssista kirjataan mahdolliset käyttäjätasot ja niiden mahdollistamat oikeudet.</p>

	    <p>Tietoturvariskien tunnistamisessa ja priorisoinnissa määritellään mahdollisia uhkia. Näitä lähestytään potentiaalisen hyökkääjän näkökulmasta, ja työhön liittyy valmiita kategorisointeja, joita voidaan käyttää muistilistana. Eräs kategorisaatio uhkille on <a href="https://msdn.microsoft.com/en-us/library/ee823878(v=cs.20).aspx" target="_blank">STRIDE</a>. STRIDE tulee sanoista Spoofing (hyökkääjä haluaa uskotella olevansa joku toinen), Tampering (hyökkääjä haluaa muokata dataa, tuloksia tai verkkoliikennettä, tai yleisesti häiritä järjestelmän toimintaa), Repudiation (hyökkääjä haluaa suorittaa järjestelmässä toimintoja, joista hän ei jää kiinni, ja joihin hänellä ei ole oikeuksia), Information Disclosure (hyökkääjä haluaa päästä käsiksi salaiseen tietoon, esim. tiedosto tai verkkoliikenne), Denial of Service (hyökkääjä haluaa estää muita käyttäjiä pääsemästä järjestelmään käsiksi), Elevation of Privilege (hyökkääjä haluaa järjestelmään tai järjestelmän resursseihin paremmat oikeudet, joiden avulla hänestä tulee luotettu käyttäjä, ja hän pääsee tekemään epätoivottuja toimintoja). Vaiheen tuloksena on lista uhkista: uhkiin liittyy myös sovelluskehittäjän kannalta vaikeat tapaukset kuten tilanne, missä sovelluksen käyttäjä käyttää järjestelmää esimerkiksi kirjastosta ja unohtaa kirjautua järjestelmästä ulos. Jokaiseen uhkaan liitetään myös riski, joka sisältää tiedon uhkaan toteutumiseen liittyvästä vaikutuksesta, todennäköisyydestä ja sen vähentämisestä sekä uhkan helppoudesta (mm. löydettävyys). Priorisointi perustuu näiden tekijöiden yhteisvaikutukseen: eräs priorisointimenetelmä on <a href="https://en.wikipedia.org/wiki/DREAD_(risk_assessment_model)" target="_blank">DREAD</a>.</p>

	    <p>Kolmanteen vaiheeseen liittyy tietoturvariskeiltä suojautumiseen liittyvien menetelmien tunnistaminen. Tutustu teemaan tarkemmin osoitteessa <a href="https://www.owasp.org/index.php/Application_Threat_Modeling" target="_blank">https://www.owasp.org/index.php/Application_Threat_Modeling</a>.</p>

	    <p>Huomaa, että uhkamallinnuksessa ei aina tarkastella sovelluksen sisäistä rakennetta. Tämä on kuitenkin tärkeää, sillä sovelluksen sisäinen logiikka sisältää usein virheitä, jotka saattavat myös johtaa ongelmiin. Alla olevassa tehtävässä tutustutaan tähän ja edellisen viikon teemoihin tarkemmin.</p>

	    

            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa5-kertaus-ex" data-count="52">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa5-kertaus">
                      Osa 5, kertaus: OnlineShop
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa5-kertaus" class="collapse">

		  <p>Tehtävässä on mukana verkkokauppasovellus, jonka kautta käyttäjät voivat tilata itselleen verkkokaupan tuotteita. Sovellukseen liittyy kuitenkin muutama tietoturvariski. Tässä kertaustehtävässä tehtävänäsi on tunnistaa nämä tietoturvariskit sekä korjata ne, joiden korjaaminen on mahdollista sovelluksesta.</p>

		  <p>Keskity tehtävässä käyttäjien oikeuksiin (autentikaatio), oikeuksien varmistamiseen (autorisaatio) sekä verkkokaupan sovelluslogiikan toimivuuteen verkkokaupan jatkuvuuden kannalta. Tehtävässä ei toistaiseksi ole automaattisia testejä.</p>
		  
                </div>
              </div>
	    </div>

	    
	    <aside class="info">
	      
	      <br/>
	      <h1>Palvelunestohyökkäykset</h1>

	      <p>Eräs STRIDE-kategorian riskeistä on palvelunestohyökkäys (Denial of Service), jonka tavoitteena on estää muiden käyttäjien pääsy sovellukseen. Tätä voidaan käyttää esimerkiksi siten, että hyökkääjä ajaa palvelun alas ja vaatii lunnaita hyökkäyksen lopettamisesta. Palvelunestohyökkäykset toteutetaan tyypillisesti siten, että hyökkääjällä on merkittävä määrä tietokoneita ja verkkoliikennekaistaa, ja hyökkääjä tekee jatkuvasti pyyntöjä palveluun. Uhka realisoitui myös kesän 2016 olympialaisissa Yle Areenan käyttämässä palvelussa, jonka takia Ylen Rio Areena -palvelua ei juurikaan päästy käyttämään olympialaisten alussa.</p>

	      <p>Palvelunestohyökkäyksiltä suojautuminen on mahdollista. Tutustu osoitteessa <a href="http://www.networkworld.com/article/2170051/tech-primers/tech-primers-four-ways-to-defend-against-ddos-attacks.html" target="_blank">http://www.networkworld.com/article/2170051/tech-primers/tech-primers-four-ways-to-defend-against-ddos-attacks.html</a> olevaan artikkeliin.</p>

	    </aside>
	    
	    

	    
            
	    <h1 data-count="12">Sovellusten skaalautuminen</h1>
	    

            <p>Kun sovellukseen liittyvä liikenne ja tiedon määrä kasvaa niin isoksi, että sovelluksen käyttö takkuilee, tulee asialle tehdä jotain.</p>
	    	    
            <aside class="info">
	      <br/>
              <h1>Hitausongelmat</h1>
	      
              <p>Vaikka tässä kappaleessa puhummekin skaalautuvuudesta, sovelluksen hitausongelmat liittyvät usein myös konfiguraatio-ongelmiin. Tyypillisiä ongelmia ovat esimerkiksi toistuvat tietokantakyselyt tauluihin, joiden kenttiin ei ole määritelty hakuoperaatioita tehostavia indeksejä. Esimerkiksi yksittäisen käyttäjän etsiminen tietokantataulusta nimen perusteella vaatii pahimmassa tapauksessa kaikkien rivien läpikäynnin ilman indeksien käyttöä; indeksillä hakuja on vain muutama.</p>

	      <p>Sovelluksen ongelmakohdat löytyvät usein sovelluksen toimintaa profiloimalla. Spring-sovellusten profilointi onnistuu esimerkiksi <a href="https://www.appdynamics.com/java/spring/" target="_blank">AppDynamicsin</a> ja <a href="https://www.yourkit.com/" target="_blank">YourKit</a>in avulla. Spring Boot-projekteihin voi lisätää myös <a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-actuator" target="_blank">Actuator</a>-komponentin, jonka avulla <a href="http://kielczewski.eu/2015/01/application-metrics-with-spring-boot-actuator/" target="_blank">sovellukseen voi lisätä tilastojen keruutoiminnallisuutta</a>.</p>
            </aside>
	    
            <p>Olettaen, että sovelluksen konfiguraatio on kunnossa, sovelluksen skaalautumiseen on useampia lähtökohtia: (1) olemassaolevien resurssien käytön tehostaminen esimerkiksi välimuistitoteutusten ja palvelintehon kasvattamisen avulla, (2) resurssien määrän kasvattaminen esimerkiksi uusia palvelimia hankkimalla, (3) toiminnallisuuden jakaminen pienempiin vastuualueisiin ja palveluihin sekä näiden määrän kasvattaminen.</p>
	    
            <p>Sovellukset eivät tyypillisesti skaalaannu lineaarisesti, ja skaalautumiseen liittyy paljon muutakin kuin resurssien lisääminen. Jos yksi palvelin pystyy käsittelemään tuhat pyyntöä sekunnissa, emme voi olettaa, että kahdeksan palvelinta pystyy käsittelemään kahdeksantuhatta pyyntöä sekunnissa, sillä tehoon vaikuttavat myös muut käytetyt komponentit sekä verkkokapasiteetti. Skaalautumiseen ei ole olemassa yhtä oikeaa lähestymistapaa. Joskus tehokkaamman palvelimen hankkiminen on nopeampaa ja kustannustehokkaampaa kuin sovelluksen muokkaaminen -- esimerkiksi hitaasti toimiva tietokanta tehostuu tyypillisesti huomattavasti lisäämällä käytössä olevaa muistia, joskus taas käytetyn tietokantakomponentin vaihtaminen tehostaa sovellusta merkittävästi. Oleellista sovelluskehityksen kannalta on kuitenkin lähestyä ongelmaa pragmaattisesti ja optimoida käytettyjä henkilöresursseja; jos sovellus ei tule olemaan laajassa käytössä, ei sen skaalautumista kannata pitää tärkeimpänä sovelluksen ominaisuutena.</p>



            <h2>Palvelinpuolen välimuistit</h2>
	    

            <p>Tyypillisissä web-palvelinohjelmistoissa huomattava osa kyselyistä on GET-tyyppisiä pyyntöjä. GET-tyyppiset pyynnöt eivät muokkaa palvelimella olevaa dataa, vaan pyytävät tietoa. Esimerkiksi tietokannasta dataa hakevat GET-tyyppiset pyynnöt luovat yhteyden tietokantasovellukseen, josta data haetaan. Jos näitä pyyntöjä on useita, eikä tietokannassa oleva data juurikaan muutu, kannattaa turhat tietokantakyselyt karsia.</p>
	    
            <p>Spring Bootia käytettäessä palvelimessa käytettävän <a href="http://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html" target="_blank">välimuistin konfigurointi</a> tapahtuu lisäämällä konfiguraatiotiedostoon annotaatio <code>@EnableCaching</code>. Oman välimuistitoteutuksen toteuttaminen tapahtuu luomalla <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/CacheManager.html" target="_blank">CacheManager</a>-rajapinnan toteuttava luokka sovellukseen. Jos taas omaa välimuistitoteutusta ei tee, etsii sovellus käynnistyessään välimuistitoteutusten (<a href="http://www.ehcache.org/" target="_blank">Ehcache</a>, <a href="https://hazelcast.com/" target="_blank">Hazelcast</a>, <a href="http://www.couchbase.com/" target="_blank">Couchbase</a>...) konfiguraatiotiedostoja. Jos näitä ei löydy, välimuistina käytetään yksinkertaista hajautustaulua.</p>
	    
            <p>Kun välimuisti on konfiguroitu, voimme lisätä välimuistitoiminnallisuuden palvelumetodeille <code>@Cacheable</code>-annotaation avulla. Alla olevassa esimerkissä metodin <code>read</code> palauttama tulos asetetaan välimuistiin.</p>

                <pre class="sh_java">
@Service
public class MyService {

    @Autowired
    private MyRepository myRepository;

    @Cacheable("my-cache-key")
    public My read(Long id) {
        return myRepository.findOne(id);
    }

    // ...</pre>

            <p>Käytännössä annotaatio <code>@Cacheable</code> luo metodille <code>read</code> proxy-metodin, joka ensin tarkistaa onko haettavaa tulosta välimuistissa -- proxy-metodit ovat käytössä vain jos metodia kutsutaan luokan ulkopuolelta. Jos tulos on välimuistissa, palautetaan se sieltä, muuten tulos haetaan tietokannasta ja se tallennetaan välimuistiin. Metodin parametrina annettavia arvoja hyödynnetään cacheavaimen toteuttamisessa, eli jokaista haettavaa oliota kohden voidaan luoda oma tietue välimuistiin. Tutustu seuraavaksi Springin <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/cache.html" target="_blank">cache</a>-dokumentaatioon.</p>

            <p>Välimuistitoteutuksen vastuulla ei ole pitää kirjaa tietokantaan tehtävistä muutoksista, jolloin välimuistin tyhjentäminen muutoksen yhteydessä on sovelluskehittäjän vastuulla. Dataa muuttavat metodit tulee annotoida sopivasti annotaatiolla <code>@CacheEvict</code>, jotta välimuistista poistetaan muuttuneet tiedot.</p>


            <div class="tehtavat">
              <div class="tehtava" id="t-weatherservice">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-weatherservice">
                      Weather Service
                    </a>
                  </h1>
                </header>
		
                <div id="t-weatherservice" class="collapse">
		  
                  <p>Kumpulan kampuksella majaileva ilmatieteen laitos kaipailee pientä viritystä omaan sääpalveluunsa. Tällä hetkellä palvelussa on toiminnallisuus sijaintien hakemiseen ja lisäämiseen. Ilmatieteen laitos on lisäksi toteuttanut säähavaintojen lisäämisen suoraan tuotantotietokantaan, mihin ei tässä palvelussa päästä käsiksi. Palvelussa halutaan kuitenkin muutama lisätoiminnallisuus:</p>
		  
                  <p>Lisää sovellukseen välimuistitoiminnallisuus. Osoitteisiin <code>/locations</code> ja <code>/locations/{id}</code> tehtyjen hakujen tulee toimia siten, että jos haettava sijainti ei ole välimuistissa, se haetaan tietokannasta ja tallennetaan välimuistiin. Jos sijainti taas on välimuistissa, tulee se palauttaa sieltä ilman tietokantahakua.</p>
		  
                  <p>Lisää tämän jälkeen sovellukseen toiminnallisuus, missä käytössä oleva välimuisti tyhjennetään kun käyttäjä lisää uuden sijainnin tai tekee GET-tyyppisen pyynnön osoitteeseen <code>/flushcaches</code>. Erityisesti jälkimmäinen on tärkeä asiakkaalle, sillä se lisää tietokantaan tietoa myös palvelinohjelmiston ulkopuolelta.</p>
		  
                </div>
              </div>
            </div>
	    

	    <aside class="info">
	      <br/>
	      <h1>Välimuistit selainpuolella</h1>


              <p>Tiedostoja jaettaessa dataa ei kannata siirtää uudestaan jos se on jo käyttäjällä. Voimme määritellä HTTP-pyynnön vastauksen otsaketietoihin tietoa datan vanhentumisesta, jonka perusteella selain osaa päätellä milloin näytettävä tieto on vanhentunutta ja se pitäisi hakea uudestaan. Hieman uudempi tapa on <a href="http://en.wikipedia.org/wiki/HTTP_ETag" target="_blank">entiteettitagin</a> käyttö pyynnön vastauksessa. Kun resurssiin liittyvään vastaukseen lisätään ETag-otsake, lähettää selain tiedostoa seuraavalla kerralla haettaessa aiemmin annetun arvon osana <code>"If-None-Match"</code>-otsaketta. Käytännössä palvelimella voidaan tällöin tarkistaa onko tiedosto muuttunut -- jos ei, vastaukseksi riittää pelkkä statuskoodi 304 -- NOT MODIFIED.</p>
	    </aside>

            <h2>Palvelinmäärän kasvattaminen</h2>
	    
            <p>Skaalautumisesta puhuttaessa puhutaan käytännössä lähes aina horisontaalisesta skaalautumisesta, jossa käyttöön hankitaan esimerkiksi lisää palvelimia. Vertikaalinen skaalautumisen harkinta on mahdollista tietyissä tapauksissa, esimerkiksi tietokantapalvelimen ja -kyselyiden toimintaa suunniteltaessa, mutta yleisesti ottaen horisontaalinen skaalautuminen on kustannustehokkaampaa. Käytännöllisesti ajatellen kahden viikon ohjelmointityö kymmenen prosentin tehonparannukseen on tyypillisesti kalliimpaa kuin muutaman päivän konfiguraatiotyö ja uuden palvelimen hankkiminen. Käyttäjien määrän kasvaessa uusien palvelinten hankkiminen on joka tapauksessa vastassa.</p>
	    
            <p>Pyyntöjen määrän kasvaessa yksinkertainen ratkaisu on palvelinmäärän eli käytössä olevan raudan kasvattaminen. Tällöin pyyntöjen jakaminen palvelinten kesken hoidetaan erillisellä kuormantasaajalla (<em><a href="http://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank">load balancer</a></em>), joka ohjaa pyyntöjä palvelimille.</p>
	    
            <p>Jos sovellukseen ei liity tilaa (esimerkiksi käyttäjän tunnistaminen tai ostoskori), kuormantasaaja voi ohjata pyyntöjä käytössä oleville palvelimille round-robin -tekniikalla. Jos sovellukseen liittyy tila, tulee tietyn asiakkaan tekemät pyynnöt ohjata aina samalle palvelimelle, sillä evästeet tallennetaan oletuksena palvelinkohtaisesti. Tämän voi toteuttaa esimerkiksi siten, että kuormantasaaja lisää pyyntöön evästeen, jonka avulla käyttäjä identifioidaan ja ohjataan oikealle palvelimelle. Tätä lähestymistapaa kutsutaan termillä (<em>sticky session</em>).</p>
	    
            <p>Pelkkä palvelinmäärän kasvattaminen ja kuormantasaus ei kuitenkaan aina riitä. Kuormantasaus helpottaa verkon kuormaa, mutta ei ota kantaa palvelinten kuormaan. Jos yksittäinen palvelin käsittelee pitkään kestävää laskentaintensiivistä kyselyä, voi kuormantasaaja ohjata tälle palvelimelle lisää kyselyjä "koska eihän se ole vähään aikaan saanut mitään töitä".  Käytännössä tällöin entisestään paljon laskentaa tekevä palvelimen saa lisää kuormaa. On kuitenkin mahdollista käyttää kuormantasaajaa, joka lisäksi pitää kirjaa palvelinten tilasta, mutta käytännössä kuorma vaihtuu usein hyvin nopeasti, ja reagointi ei aina ole nopeaa.</p>
	    
            <p>Parempi ratkaisu palvelinmäärän kasvattamiselle on palvelinmäärän kasvattaminen <em>ja</em> sovelluksen suunnittelu siten, että laskentaintensiiviset operaatiot käsitellään erillisillä palvelimilla. Tällöin käytetään käytännössä erillistä laskentaklusteria aikaa vievien laskentaoperaatioiden käsittelyyn, jolloin käyttäjän pyyntöjä kuuntelevan palvelimen kuorma pysyy alhaisena.</p>
	    
            <p>Riippuen pyyntöjen määrästä, palvelinkonfiguraatio voidaan toteuttaa jopa siten, että staattiset tiedostot (esim. kuvat) löytyvät erillisiltä palvelimilta, GET-pyynnöt käsitellään erillisillä pyyntöjä vastaanottavilla palvelimilla, ja datan muokkaamista tai prosessointia vaativat kyselyt (esim POST) ohjataan asiakkaan pyyntöjä vastaanottavien palvelinten toimesta laskentaklusterille.</p>
	    
            <aside class="info">
	      <br/>
              <h1>Rajoitettu määrä samanaikaisia pyyntöjä osoitetta kohden</h1>
	      
              <p>Staattisten resurssien kuten kuvien ja tyylitiedostojen hajauttaminen eri palvelimille on oikeastaan fiksua. <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html" target="_blank">HTTP 1.1-spesifikaation</a> yhteyksiin liittyvässä osissa suositellaan tiettyyn osoitteeseen tehtävien samanaikaisten pyyntöjen määrän rajoittamista kahteen.</p>
	      
              <p><em>Clients that use persistent connections SHOULD limit the number of simultaneous connections that they maintain to a given server. A single-user client SHOULD NOT maintain more than 2 connections with any server or proxy. A proxy SHOULD use up to 2*N connections to another server or proxy, where N is the number of simultaneously active users. These guidelines are intended to improve HTTP response times and avoid congestion.</em></p>
	      
              <p>Käytännössä suurin osa selaimista tekee enemmän kuin 2 kyselyä kerrallaan samaan osoitteeseen. Jos web-sivusto sisältää paljon erilaisia staattisita resursseja, ja ne sijaitsevat kaikki samalla palvelimella, saadaan resursseja korkeintaan selaimeen rajoitettu määrä kerrallaan. Toisaalta, jos resurssit jaetaan useamman sijainnin kesken, ei tätä rajoitetta ole.</p>
	      
              <p>Resurssien jakaminen useampaan sijantiin mahdollistaa myös maantieteellisen hajauttamisen, missä käyttäjä saa sivun sisällön lähellä olevilta palvelimilta, mikä nopeuttaa vasteaikaa. Sama resurssi voi olla myös useammalla palvelimella.</p>
	      
              <p>Tutustu aiheeseen tarkemmin lukemalla Wikipedian artikkeli <a href="http://en.wikipedia.org/wiki/Content_delivery_network" target="_blank">Content delivery network</a>.</p>
	      
            </aside>


	    <p>Palvelinmäärän kasvattaminen onnistuu myös tietokantapuolella. Tällöin käyttöön tulevat tyypillisesti hajautetut tietokantapalvelut kuten <a href="http://cassandra.apache.org/" target="_blank">Apache Cassandra</a> ja <a href="http://geode.apache.org/" target="_blank">Apache Geode</a>. Riippumatta käyttöön valitusta teknologiasta, aiemmin käyttämämme Spring Data JPA:n ohjelmointimalli sopii myös näihin tietokantoihin: esimerkiksi Cassandran käyttöönottoon löytyy ohjeistusta osoitteesta <a href="http://projects.spring.io/spring-data-cassandra/" target="_blank">http://projects.spring.io/spring-data-cassandra/</a>. </p>

	    
            <aside class="info">
	      <br/>

              <h1>Teknologiahype</h1>
	      
              <p>Tietokantamoottoreiden ympärillä on viime vuosikymmenen lopusta lähtien ollut NoSQL-tietokantoihin liittyvää hypeen verrattavaa keskustelua. Nyt kun tuosta on mennyt hetki, on hyvä tarkastella keskustelua ja siihen liittyviä jälkiviisauksia.</p>

	      <p>Eräs merkittävistä NoSQL-buumin aloittajista oli Twitterin noin 2010 tekemä <a href="http://www.computerworld.com/article/2520084/database-administration/twitter-growth-prompts-switch-from-mysql-to--nosql--database.html" target="_blank">päätös siirtyä MySQL-relaatiotietokannan käytöstä NoSQL-tietokantaan</a>; taustasyynä muutokselle oli "relaatiotietokantojen hitaus". Keskustelua seurasi <a href="http://www.mysql.com/" target="_blank">MySQL</a>:n ja <a href="https://mariadb.org/" target="_blank">MariaDB</a>:n kehittäjän Monty Wideniuksen <a href="http://blog.jelastic.com/2013/01/21/are-nosql-and-big-data-just-hype/" target="_blank">pohdintaa</a> teemaan liittyen: <em>The main reason Twitter had problems with MySQL back then, was that they were using it incorrectly. The strange thing was that the solution they suggested for solving their problems could be done just as easily in MySQL as in Cassandra.</em></p>

	      <p>Käytännössä Widenius vihjasi, että Twitter vain käytti MySQL:ää huonosti. Nykyään Twitterkin on tosin rakentanut itselleen sopivampaa tietokannanhallintajärjestelmää, tästä lisää osoitteessa <a href="https://gigaom.com/2014/05/12/3-lessons-in-database-design-from-the-team-behind-twitters-manhattan/" target="_blank">https://gigaom.com/2014/05/12/3-lessons-in-database-design-from-the-team-behind-twitters-manhattan/</a>.</p>

	    </aside>


	    
            <h2>Tiedostojen jakaminen ja tietokannat</h2>
	
            <p>Kun sovelluksen kasvu saavuttaa pisteen, missä yksittäisestä tietokantapalvelimesta siirrytään useamman palvelimen käyttöön, on hyvä hetki miettiä sovelluksen tietokantarakennetta. Tietokantojen määrän kasvaessa numeeristen tunnusten (esim <code>Long</code>) käyttäminen tunnisteena on ongelmallista. Jos tietokantataulussa on numeerinen tunnus ja useampi sovellus luo uusia tietokantarivejä, tarvitaan erillinen palvelu tunnusten antamiselle -- tämän palvelun kaatuessa koko sovellus voi kaatua. Toisaalta, jos palvelua ei ole toteutettu hyvin, on tunnusten törmäykset mahdollisia, mikä johtaa helposti tiedon katoamiseen. Numeeristen avainten käyttö erityisesti osoitteiden yhteydessä tekee niistä myös helposti arvattavia, mikä voi myös luoda tietoturvariskejä yhdessä huonosti toteutetun pääsynvalvonnan kanssa.  Yhtenä vaihtoehtona numeerisille tunnuksille on ehdotettu <a href="http://docs.oracle.com/javase/7/docs/api/java/util/UUID.html" target="_blank">UUID</a>-pohjaisia merkkijonotunnuksia, jotka voidaan luoda ennen olion tallentamista tietokantaan.</p>
	    
            <p>Spring Data JPAn tapauksessa tämä tarkoittaa sitä, että <code>AbstractPersistable</code>-luokan periminen ei onnistu kuten ennen. Voimme kuitenkin toteuttaa oman UUIDPersistable-luokan, joka luo tunnuksen automaattisesti. </p>
	    
            <pre class="sh_java">
@MappedSuperclass
public abstract class UUIDPersistable implements Persistable&lt;String&gt; {

    @Id
    private String id;

    public UUIDPersistable() {
        this.id = UUID.randomUUID().toString();
    }

    public String getId() {
        return this.id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @JsonIgnore
    @Override
    public boolean isNew() {
        return false;
    }

    // muuta mahdollista
}</pre>

            <p>Ylläoleva toteutus luo uuden id-avaimen olion luontivaiheessa, jolloin se on käytössä jo ennen olion tallentamista tietokantaan. Rajapinta <a href="http://docs.spring.io/spring-data/data-commons/docs/current/api/org/springframework/data/domain/Persistable.html" target="_blank">Persistable</a> on rajapinta, jota Spring Data -projektit käyttävät olioiden tallennuksessa erilaisiin tietokantoihin.</p>

            <p>Nyt voimme luoda merkkijonotunnusta käyttävän entiteetin seuraavasti:</p>

            <pre class="sh_java">
@Entity
public class Person extends UUIDPersistable {

    private String name;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</pre>


            
	    
            <div class="tehtavat">
              <div class="tehtava" id="t-imageservice">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-imageservice">
                      Image Service
                    </a>
                  </h1>
                </header>
		
                <div id="t-imageservice" class="collapse">
		  
                  <p>Tehtäväpohjassa on kuvapalvelu, joka tarjoaa toiminnallisuutta kuvien listaukseen ja pienennykseen.</p>
		  
                  <p>Tällä hetkellä kuvan lisääminen ohjaa käyttäjän suoraan <code>/images</code>-osoitteeseen, eli palvelun juureen. Muuta sovellusta siten, että käyttäjä ohjataan uuteen osoitteeseen <code>/images/{id}</code>, missä <code>id</code> on juuri luodun kuvan merkkijonoavain. Toteuta myös sopiva kontrolleri, joka toimii yhteistyössä <code>index.html</code>-näkymässä olevan koodin kanssa.</p>
		  
                  <p>Kun käyttäjä hakee kuvaa, tällä hetkellä kuva haetaan aina tietokannasta. Muokkaa kuvien lähettämistä siten, että käyttäjälle palautetaan kuvan mukana myös ETag-otsake, jonka arvoksi on asetettu kyseisen kuvan <code>id</code>-kentän arvo (huom! alkuperäisillä kuvilla ja thumbnaileilla on eri arvot.). Seuraavan kerran kun käyttäjä pyytää samaa kuvaa, hän lähettää pyynnön mukana myös <code>If-None-Match</code>-otsakkeen, joka sisältää aiemmin lähetetyn ETag-otsakkeen arvon. Tässä lienee apua annotaatiosta <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestHeader.html" target="_blank">@RequestHeader</a>.</p>
		  
                  <p>Riippumatta otsakkeen <code>If-None-Match</code> arvosta, palauta vastauksena vain statuskoodi <code>304</code>, eli ei muokattu. Huom! Älä lähetä kuvaa tällöin vastauksessa -- käytä vain statuskoodia.</p>
		  
                </div>
              </div>
            </div>


	    <h3>Evästeet ja useampi palvelin</h3>
	    
		

            <p>Kun käyttäjä kirjautuu palvelinohjelmistoon, tieto käyttäjästä pidetään tyypillisesti yllä sessiossa. Sessiot toimivat evästeiden avulla, jotka palvelin asettaa pyynnön vastaukseen, ja selain lähettää aina palvelimelle. Sessiotiedot ovat oletuksena yksittäisellä palvelimella, mikä aiheuttaa ongelmia palvelinmäärän kasvaessa. Edellä erääksi ratkaisuksi mainittiin kuormantasaajien (load balancer) käyttö siten, että käyttäjät ohjataan aina samalle koneelle. Tämä ei kuitenkaan ole aina mahdollista -- kuormantasaajat eivät aina tue sticky session -tekniikkaa -- eikä kannattavaa -- kun palvelinmäärää säädellään dynaamisesti, uusi palvelin käynnistetään tyypillisesti vasta silloin, kun havaitaan ruuhkaa -- olemassaolevat käyttäjät ohjataan ruuhkaantuneelle palvelimelle uudesta palvelimesta riippumatta.</p>

            <p>Yksi vaihtoehto on tunnistautumisongelman siirtäminen tietokantaan -- skaalautumista helpottaa tietokannan hajauttaminen esimerkiksi käyttäjätunnusten perusteella. Sen sijaan, että käytetään palvelimen hallinnoimia sessioita, pidetään käyttäjätunnus ja kirjautumistieto salattuna evästeessä. Eväste lähetetään kaikissa tiettyyn osoitteeseen tehtävissä kutsuissa; palvelin voi tarvittaessa purkaa evästeessä olevan viestin ja hakea käyttäjään liittyvät tiedot tietokannasta.</p>

            <div class="tehtavat">
              <div class="tehtava" id="t-cookieauth">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-cookieauth">
                      Cookie-based authentication
                    </a>
                  </h1>
                </header>
		
                <div id="t-cookieauth" class="collapse">
		  
                  <p>Tässä tehtävässä hiotaan Springin <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html" target="_blank">PersistentTokenBasedRememberMeServices</a>-komponenttia luomalla siihen JPA:ta käyttävä tietokantatoiminnallisuus. PersistentTokenBasedRememberMeServices-komponentti tarjoaa evästeisiin perustuvan autentikaation, joka perustuu seuraaviin askeleisiin:</p>
		  
                  <ol>
                    <li>Kun käyttäjä kirjautuu siten, että hän valitsee <code>Remember Me</code>-vaihtoehdon, käyttäjälle annetaan eväste.</li>
                    <li>Eväste sisältää käyttäjän käyttäjätunnuksen, evästeen sarjanumeron, sekä viestin. Sarjanumero ja viesti ovat satunnaisesti generoituja ja ne tallennetaan tietokantaan.</li>
                    <li>Kun käyttäjä vierailee sivulla, hän lähettää pyynnössä evästeen. Tällöin käyttäjätunnus, sarjanumero ja viesti haetaan tietokannasta.</li>
                    <li>Jos kaikki edellämainitut löytyvät tietokannasta, oletetaan että käyttäjä on kirjautunut sivulle. Samalla käytetty viesti poistetaan tietokannasta, ja tietokantaan luodaan uusi satunnainen viesti aiemmin käytettyjen sarjanumeron ja käyttäjätunnuksen pariksi. Käyttäjälle palautetaan uusi eväste, missä on uudet tiedot.</li>
                    <li>Jos käyttäjätunnus ja sarjanumero on oikein, mutta viesti on väärin, oletetaan että joku on yrittänyt ryövätä käyttäjän tunnuksen ja pyydetään käyttäjää kirjautumaan. Samalla kaikki käyttäjään liittyvät aiemmat evästetiedot / kirjautumisdatat poistetaan tietokannasta.</li>
                    <li>Jos käyttäjätunnusta ja sarjanumeroa ei ole olemassa, pyydetään käyttäjää kirjautumaan.</li>
                  </ol>
		  
                  <p>Ylläolevan toteutuksen etuna on se, että se skaalautuu melko hyvin. Palvelinten määrää voi kasvattaa niin pitkään kuin tietokantatason toiminta toimii hyväksyttävällä tasolla.</p>
		  
                  <p>Projektiin on toteutettu valmiiksi entiteettiluokka <code>CustomPersistentToken</code> sekä <code>PersistentTokenBasedRememberMeServices</code>-palvelun tarvitseman <a href="http://docs.spring.io/autorepo/docs/spring-security/current/apidocs/org/springframework/security/web/authentication/rememberme/PersistentTokenRepository.html" target="_blank">PersistentTokenRepository</a>-rajapinnan toteuttavan luokan runko, joka löytyy sijainnista <code>wad.auth.CustomPersistentTokenService</code>.</p>
		  
                  <p><strong>Toteuta tarvittava toiminnallisuus JPA-tuen aikaansaamiseksi.</strong> Tarvitset ainakin palvelun CustomPersistentToken-entiteetin tallentamiseen, jonka lisäksi tarvitset sopivaa logiikkaa <code>CustomPersistentTokenService</code>-luokkaan; voit ottaa mallia esimerkiksi Springin vastaavasta JDBC-rajapintaa käyttävästä <a href="https://github.com/spring-projects/spring-security/blob/master/web/src/main/java/org/springframework/security/web/authentication/rememberme/JdbcTokenRepositoryImpl.java" target="_blank">JdbcTokenRepositoryImpl</a>-luokasta, missä vastaava toteutus on tehty ilman JPA:ta -- voit käytännössä hyödyntää samaa toimintaideaa omassa koodissasi. Lue siis JdbcTokenRepositoryImpl-luokan toteutus, ja kopioi sen logiikka omaan JPA-pohjaiseen toteutukseesi. </p>
		  
                </div>
              </div>
            </div>
	    

            <h2>Asynkroniset metodikutsut ja rinnakkaisuus</h2>
	    
            <p>Jokaiselle palvelimelle tulevalle pyynnölle määrätään säie, joka on varattuna pyynnön käsittelyn loppuun asti. Jokaisen pyynnön käsittelyyn kuuluu ainakin seuraavat askeleet: (1) pyyntö lähetetään palvelimelle, (2) palvelin vastaanottaa pyynnön ja ohjaa pyynnön oikealle kontrollerille, (3) kontrolleri vastaanottaa pyynnön ja ohjaa pyynnön oikealle palvelulle tai palveluille, (4) palvelu vastaanottaa pyynnön, suorittaa pyyntöön liittyvät operaatiot muiden palveluiden kanssa, ja palauttaa lopulta vastauksen metodin suorituksen lopussa, (5) kontrolleri ohjaa pyynnön sopivalle näkymälle, ja (6) vastaus palautetaan käyttäjälle. Pyyntöä varten on palvelimella varattuna säie kohdissa 2-6. Jos jonkun kohdan suoritus kestää pitkään -- esimerkiksi palvelu tekee pyynnön toiselle palvelimelle, joka on hidas -- on säie odotustilassa.</p>

	    <p>Palvelukutsun suorituksen odottaminen ei kuitenkaan aina ole tarpeen. Jos sovelluksemme suorittaa esimerkiksi raskaampaa laskentaa, tai tekee pitkiä tietokantaoperaatioita joiden tuloksia käyttäjän ei tarvitse nähdä heti, kannattaa pyyntö suorittaa asynkronisesti. Asynkronisella metodikutsulla tarkoitetaan sitä, että asynkronista metodia kutsuva metodi ei jää odottamaan metodin tuloksen valmistumista. Jos edellisissä askeleissa kohta 4 suoritetaan asynkronisesti, ei sen suoritusta tarvitse odottaa loppuun.</p>
	    	    
            <p>Ohjelmistokehykset toteuttavat asynkroniset metodikutsut luomalla palvelukutsusta erillisen säikeen, jossa pyyntö käsitellään. Spring Bootin tapauksessa asynkroniset metodikutsut saa käyttöön lisäämällä sovelluksen konfiguraatioon (tapauksessamme usein <code>Application</code>-luokassa) rivi <code>@EnableAsync</code>. Kun konfiguraatio on paikallaan, voimme suorittaa metodeja asynkronisesti. Jotta metodisuoritus olisi asynkroninen, tulee metodin olla <code>void</code>-tyyppinen, sekä sillä tulee olla annotaatio <code>@Async</code>.</p>
	    
            <p>Tutkitaan tapausta, jossa tallennetaan <code>Item</code>-tyyppisiä olioita. Item-olion sisäinen muoto ei ole niin tärkeä.</p>
	    
            <pre class="sh_java">
    @RequestMapping(method = RequestMethod.POST)
    public String create(@ModelAttribute Item item) {
        itemService.create(item);
        return "redirect:/items";
    }</pre>

            <p>Oletetaan että <code>ItemService</code>-olion metodi <code>create</code> on void-tyyppinen, ja näyttää seuraavalta:</p>

            <pre class="sh_java">
    public void create(Item item) {
        // koodia.. 
    }</pre>
		
            <p>Metodin muuttaminen asynkroniseksi vaatii <code>@Async</code>-annotaation ItemService-luokkaan.</p>
	    
            <pre class="sh_java">
    @Async
    public void create(Item item) {
        // koodia.. 
    }</pre>

            <p>Käytännössä asynkroniset metodikutsut toteutetaan asettamalla metodikutsu suoritusjonoon, josta se suoritetaan kun sovelluksella on siihen mahdollisuus.</p>


            <div class="tehtavat">
              <div class="tehtava" id="t-calculations">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-calculations">
                      Calculations
                    </a>
                  </h1>
                </header>
		
                <div id="t-calculations" class="collapse">
		  
                  <p>Tehtäväpohjassa on sovellus, joka tekee raskasta laskentaa (nukkuu kuin tutkijat). Tällä hetkellä käyttäjä joutuu odottamaan laskentapyynnön suoritusta pitkään, mutta olisi hienoa jos käyttäjälle kerrottaisiin laskennan tilasta jo laskentavaiheessa.</p>
		  
                  <p>Muokkaa sovellusta siten, että laskenta tallennetaan kertaalleen jo ennen laskentaa -- näin siihen saadaan viite; aseta oliolle myös status "PROCESSING". Muokkaa tämän jälkeen luokkaa <code>CalculationService</code> siten, että laskenta tapahtuu asynkronisesti.</p>
		  
                  <p>Huom! Älä poista <code>CalculationService</code>-luokasta koodia</p>
		  
                  <pre class="sh_java">
        try {
            Thread.sleep(2000);
        } catch (InterruptedException ex) {
            Logger.getLogger(CalculationService.class.getName()).log(Level.SEVERE, null, ex);
        }</pre>                            

		  
                  <p>Kun sovelluksesi toimii oikein, laskennan lisäyksen pitäisi olla nopeaa ja käyttäjä näkee lisäyksen jälkeen laskentakohtaisen sivun, missä on laskentaan liittyvää tietoa. Kun sivu ladataan uudestaan noin 2 sekunnin kuluttua, on laskenta valmistunut.</p>
		  
                </div>
              </div>
            </div>
	    

            <h3>Rinnakkain suoritettavat metodikutsut</h3>

            <p>Koostepalvelut, eli palvelut jotka keräävät tietoa useammasta palvelusta ja yhdistävät tietoja käyttäjälle, tyypillisesti haluavat näyttää käyttäjälle vastauksen.</p>
	    
            <p>Näissä tilanne on usein se, että palveluita on useita, ja niiden peräkkäinen suorittaminen on tyypillisesti hidasta. Suoritusta voi nopeuttaa ottamalla käyttöön rinnakkaisen suorituksen, joka onnistuu esimerkiksi Javan <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html" target="_blank">ExecutorService</a>-luokan avulla. Voimme käytännössä lisätä tehtäviä niitä suorittavalle palvelulle, jolta saamme viitteen tulevaa vastausta varten.</p>

            <p>Spring tarjoaa myös tähän apuvälineitä. Kun lisäämme sovellukselle <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/task/AsyncTaskExecutor.html">AsyncTaskExecutor</a>-rajapinnan toteuttaman olion (esimerkiksi <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html" target="_blank">ThreadPoolTaskExecutor</a>), voimme injektoida sen sovelluksemme käyttöön tarvittaessa. Tietynlaisen olion sovellukseen tapahtuu luomalla <code>@Bean</code>-annotaatiolla merkitty olio konfiguraatiotiedostossa. Alla esimerkiksi luodaan edellämainitut oliot.</p>

	    
            <pre class="sh_java">
// konfiguraatiotiedosto
    @Bean
    public AsyncTaskExecutor asyncTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(8);
        return executor;
    }</pre>

            <p>Nyt voimme ottaa käyttöön sovelluksessa <code>AsyncTaskExecutor</code>-rajapinnan toteuttavan olion.</p>

            <pre class="sh_java">
    @Autowired
    private AsyncTaskExecutor taskExecutor;</pre>

            <p>Käytännössä tehtävien lisääminen rinnakkaissuorittajalle tapahtuu esimerkiksi seuraavasti. Alla luodaan kolme <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html" target="_blank">Callable</a>-rajapinnan toteuttavaa oliota, annetaan ne <code>taskExecutor</code>-ilmentymälle, ja otetaan jokaisen kohdalla talteen <a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" target="_blank">Future</a>-viite, mihin suorituksen tulos asetetaan kun suoritus on loppunut. Future-oliosta saa tuloksen <code>get</code>-metodilla.</p>

            <pre class="sh_java">
    // käytössä myös ylläoleva taskExecutor
    List&lt;Future&lt;TuloksenTyyppi&gt;&gt; results = new ArrayList&lt;&gt;();

    results.add(taskExecutor.submit(new Callable&lt;TuloksenTyyppi&gt;() {
        @Override
        public TuloksenTyyppi call() {
            // laskentaa.. -- tulos voi olla käytännössä mitä tahansa
            return new TuloksenTyyppi();
        }
    }));
    
    for (Future&lt;TuloksenTyyppi&gt; result: results) {
        TuloksenTyyppi t = result.get();

        // tee jotain tällä..
    }</pre>


            <div class="tehtavat">
              <div class="tehtava" id="t-lowestprice">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-lowestprice">
                      Lowest Prices
                    </a>
                  </h1>
                </header>
		
                <div id="t-lowestprice" class="collapse">
		  
                  <p>Tehtäväpohjaan on lähdetty toteuttamaan sovellusta, joka etsii eri palveluiden rajapinnoista halutun esineen hintaa ja palauttaa halvimman. Palvelusta on toteutettu ensimmäinen versio, mutta se on liian hidas.</p>
		  
                  <p>Ennenkuin sovelluskehittäjät juoksevat hakemaan uutta rautaa, muokkaa palvelun <code>QuoteService</code>-toiminnallisuutta siten, että se suorittaa hintakyselyt rinnakkain nykyisen peräkkäissuorituksen sijaan.</p>
		  
                </div>
              </div>
            </div>
	    
            <aside class="info">
	      <br/>
              <h1>Java 8 ja kokoelmien rinnakkainen läpikäynti</h1>
	      
              <p>Java 8 tarjoaa kehittyneemmän välineistön kokoelmien läpikäyntiin. Tutustu näihin osoitteessa <a href="http://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html" target="_blank">http://docs.oracle.com/javase/tutorial/collections/streams/parallelism.html</a>.</p>
	      
            </aside>
	    
	    
            <h3>Viestijonot</h3>
	    
            <p>Kun palvelinohjelmistoja skaalataan siten, että osa laskennasta siirretään erillisille palvelimille, on oleellista että palveluiden välillä kulkevat viestit (pyynnöt ja vastaukset) eivät katoa, ja että käyttäjän pyyntöjä vastaanottavan palvelimen ei tarvitse huolehtia toisille palvelimille lähetettyjen pyyntöjen perille menemisestä tai lähetettyjen viestien vastausten käsittelystä. Eniten käytetty lähestymistapa viestien säilymisen varmentamiseen on viestijonot (<em>messaging</em>, <em>message queues</em>), joiden tehtävänä on toimia viestien väliaikaisena säilytyspisteenä. Käytännössä viestijonot ovat erillisiä palveluita, joihin viestien tuottajat (<em>producer</em>) voivat lisätä viestejä, joita viestejä käyttävät palvelut kuluttavat (<em>consumer</em>).</p>
	    
            <p>Viestijonoja käyttävät sovellukset kommunikoivat viestijonon välityksellä. Tuottaja lisää viestejä viestijonoon, josta käyttäjä niitä hakee. Kun viestin sisältämän datan käsittely on valmis, prosessoija lähettää viestin takaisin. Viestijonoissa on yleensä varmistustoiminnallisuus: jos viestille ei ole vastaanottajaa, jää viesti viestijonoon ja se tallennetaan esimerkiksi viestijonopalvelimen levykkeelle. Viestijonojen konkreettinen toiminnallisuus riippuu viestijonon toteuttajasta.</p>
	    
            <p>Viestijonosovelluksia on useita, esimerkiksi <a href="http://activemq.apache.org/" target="_blank">ActiveMQ</a> ja <a href="http://www.rabbitmq.com/" target="_blank">RabbitMQ</a>. Viestijonoille on myös useita standardeja, joilla pyritään varmistamaan sovellusten yhteensopivuus. Esimerkiksi Javan melko pitkään käytössä ollut <a href="http://en.wikipedia.org/wiki/Java_Message_Service" target="_blank">JMS</a>-standardi määrittelee viestijonoille rajapinnan, jonka viestijonosovelluksen tarjoajat voivat toteuttaa. Nykyään myös <a href="http://www.amqp.org/" target="_blank">AMQP</a>-protokolla on kasvattanut suosiotaan. Myös Spring tarjoaa komponentteja viestijonojen käsittelyyn, tutustu lisää aiheeseen <a href="http://spring.io/guides/gs/messaging-jms/" target="_blank">täällä</a>.</p>
	    
	    
	    
            <h2>Palvelukeskeiset arkkitehtuurit</h2>
	    
	    
            <p>Monoliittisten "minä sisällän kaiken mahdollisen"-sovellusten ylläpitokustannukset kasvavat niitä kehitettäessä, sillä uuden toiminnallisuuden lisääminen vaatii olemassaolevan sovelluksen muokkaamista sekä testaamista. Olemassaoleva sovellus voi olla kirjoitettu hyvin vähäisesssä käytössä olevalla kielellä (vrt. pankkijärjestelmät ja COBOL) ja esimerkiksi kehitystä tukevat automaattiset testit voivat puuttua siitä täysin. Samalla myös uusien työntekijöiden tuominen ohjelmistokehitystiimiin on vaikeaa, sillä sovellus voi hoitaa montaa vastuualuetta samaan aikaan. </p>

            <p>Yrityksen toiminta-alueiden laajentuessa sekä uusien sovellustarpeiden ilmentyessä aiemmin toteutettuihin toiminnallisuuksiin olisi hyvä päästä käsiksi, mutta siten, että toiminnallisuuden käyttäminen ei vaadi juurikaan olemassaolevan muokkausta. Koostamalla sovellus erillisistä palveluista saadaan luotua tilanne, missä palvelut ovat tarvittaessa myös uusien sovellusten käytössä. Palvelut tarjoavat rajapinnan (esim. REST) minkä kautta niitä voi käyttää. Samalla rajapinta kapseloi palvelun toiminnan, jolloin muiden palvelua käyttävien sovellusten ei tarvitse tietää sen toteutukseen liittyvistä yksityiskohdista. Oleellista on, että yksikään palvelu ei yritä tehdä kaikkea. Tämä johtaa myös siihen, että yksittäisen palvelun toteutuskieli tai muut teknologiset valinnat ei vaikuta muiden komponenttien toimintaan -- oleellista on vain se, että palvelu tarjoaa rajapinnan jota voi käyttää ja joka löydetään.</p>

            <p>Yrityksen kasvaessa sen sisäiset toiminnat ja rakennettavat ohjelmistot sisältävät helposti päällekkäisyyksiä. Tällöin tilanne on käytännössä se, että aikaa käytetään samankaltaisten toimintojen ylläpitoon useammassa sovelluksessa -- pyörä keksitään yhä uudestaan ja uudestaan uudestaan uusia sovelluksia kehitettäessä.</p>


            <p>SOA (<em><a href="http://en.wikipedia.org/wiki/Service-oriented_architecture" target="_blank">Service Oriented Architecture</a></em>), eli palvelukeskeinen arkkitehtuuri, on suunnittelutapa, jossa eri sovelluksen komponentit on suunniteltu toimimaan itsenäisinä avoimen rajapinnan tarjoavina palveluina. Pilkkomalla sovellukset erillisiin palveluihin luodaan tilanne, missä palveluita voidaan käyttää myös tulevaisuudessa kehitettävien sovellusten toimesta. Palveluita käyttävät esimerkiksi toiset palvelut tai selainohjelmistot. Selainohjelmistot voivat hakea palvelusta JSON-muotoista dataa Javascriptin avulla ilman tarvetta omalle palvelinkomponentille. SOA-arkkitehtuurin avulla voidaan helpottaa myös ikääntyvien sovellusten jatkokäyttöä: ikääntyvät sovellukset voidaan kapseloida rajapinnan taakse, jonka kautta sovelluksen käyttö onnistuu myös jatkossa.</p>

            <aside class="info">
	      <br/>
              <h1>Case: Amazon</h1>
	      
              <p>Amazon on hyvä esimerkki yrityksestä, joka on menestynyt osittain sen takia, että se on toteuttanut tarjoamansa toiminnallisuudet palveluina. Siirtymä ei kuitenkaan ollut yksinkertainen, allaoleva viesti on katkelma Amazonin toimitusjohtajan, Jeff Bezosin, noin vuonna 2002 kirjoittamasta viestistä yritykselle (<a href="https://plus.google.com/+RipRowan/posts/eVeouesvaVX" target="_blank">lähde</a>).</p>

              <pre>
1) All teams will henceforth expose their data and functionality 
   through service interfaces.

2) Teams must communicate with each other through these interfaces.

3) There will be no other form of interprocess communication allowed: 
   no direct linking, no direct reads of another team's data store, 
   no shared-memory model, no back-doors whatsoever. The only communication 
   allowed is via service interface calls over the network.

4) It doesn't matter what technology they use. HTTP, Corba, Pubsub, 
   custom protocols — doesn't matter.

5) All service interfaces, without exception, must be designed from the 
   ground up to be externalizable. That is to say, the team must plan 
   and design to be able to expose the interface to developers in the 
   outside world. No exceptions.

6) Anyone who doesn't do this will be fired.</pre>

              <p>Oikeastaan, hyvin suuri syy sille, että Amazon tarjoaa nykyään erilaisia pilvipalveluita (kts. <a href="http://aws.amazon.com/" target="_blank">Amazon Web Services</a>) liittyy siihen kokemukseen, mitä yrityksen työntekijät sekä yritys on kerännyt kun yrityksen sisäistä toimintaa kehitettiin kohti palveluja tarjoavia ohjelmistotiimejä.</p>

            </aside>

	    <p>Rakennetaan seuraavaksi muutama palvelu, joiden toiminnallisuus yhdistetään lopulta.</p>


            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-huoneistot">
                      Apartments
                    </a>
                  </h1>
                </header>
                <div id="t-huoneistot" class="collapse">
		  
                  <p>Toteuta Spring Data RESTin avulla REST-rajapinta huoneistojen hallintaan.</p>
		  
                  <p>Jokaisella huoneistolla tulee olla uniikki nimi (<code>name</code>), joka ei saa olla tyhjä. Huoneistojen lisäys tapahtuu tekemällä JSON-muotoinen POST-pyyntö osoitteeseen <code>/api/apartments</code> (esim. <code>{"name":"The Cupboard Under the Stairs"}</code>). Vastaavasti <code>GET</code>-pyyntö osoitteeseen <code>/api/apartments</code> palauttaa <code>HAL</code>-spesifikaatiota seuraavan JSON-vastauksen, missä huoneet on listattu.</p>
		  
                  <p>yksittäisen huoneiston haku ja poisto tapahtuu osoitteessa <code>/api/apartments/{id}</code>, missä <code>id</code> on huoneiston uniikki tunnus.</p>
		  
                  <p>Käytä huoneiston tunnuksena (<code>id</code>) <code>Long</code>-tyyppistä muuttujaa.</p>
		  
                </div>
              </div>
	      
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-henkilot">
                      Authentication
                    </a>
                  </h1>
                </header>
                <div id="t-henkilot" class="collapse">
		  
                  <p>Toteutetaan sovellus henkilöiden luomiseen.</p>
		  
                  <p>Toteuta Spring Data RESTin avulla REST-rajapinta henkilöiden hallintaan.</p>
		  
                  <p>Jokaisella henkilöllä tulee olla uniikki nimi (<code>name</code>), uniikki käyttäjätunnus (<code>username</code>) sekä salasana (<code>password</code>), joista yksikään ei saa olla tyhjä.</p>
		  
                  <p>Henkilöiden lisäys tapahtuu tekemällä JSON-muotoinen POST-pyyntö osoitteeseen <code>/api/persons</code> (esim. <code>{"name":"Harry Potter", "username":"hedwig", "password":"nimbus2000"}</code>).</p>
		  
                  <p>Vastaavasti <code>GET</code>-pyyntö osoitteeseen <code>/api/persons</code> palauttaa <code>HAL</code>-spesifikaatiota seuraavan JSON-vastauksen, missä henkilöt on listattu.</p>
		  
                  <p>Yksittäinen henkilö voidaan hakea tunnuksen perusteella osoitteesta <code>/api/persons/{id}</code>, missä <code>id</code> on henkilön uniikki tunnus. Poistamisen ei kuitenkaan tule onnistua.</p>
		  
                  <p>Käytä henkilön tunnuksena (<code>id</code>) <code>Long</code>-tyyppistä muuttujaa.</p>
		  
                  <p><strong>Huom!</strong> Toteuta toiminnallisuus siten, että GET-pyynnön yhteydessä henkilön salasanaa ei palauteta. Vastauksen tulee siis sisältää aina vain nimi ja käyttäjätunnus. Etsi apua Googlesta, avainsanoja ovat ainakin <code>@JsonProperty</code>, <code>@JsonIgnore</code> sekä esimerkiksi haku "json ignore property on deserialization but allow on serialization".</p> 
		  
		  
                  <p>Lisää tämän jälkeen sovellukseen rajapinta <code>/authenticate</code>, jonka avulla voidaan tarkistaa löytyykö käyttäjärekisteristä sopiva käyttäjätunnus-salasana -pari. Rajapinnalle voidaan tehdä <code>POST</code>-tyyppinen pyyntö JSON-muodossa. JSON-data sisältää käyttäjätunnus-salasana -parin (<code>{"username":"tunnus","password":"jackbauer"}</code>). Jos tietokannasta löytyy käyttäjä annetulla käyttäjätunnuksella ja salasanalla, metodin tulee palauttaa statuskoodi <code>200</code> eli "OK", sekä käyttäjän nimi vastauksen rungossa. Jos käyttäjää ei löydy, palautettavan arvon tulee olla <code>401</code> eli "Unauthorized".</p>
		  
                  <p>Toteuta vastaus siten että autentikointiin käytettävä kontrollerimetodi palauttaa <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/ResponseEntity.html" target="_blank">ResponseEntity</a></code>-olion. ResponseEntitylle voi määritellä vastauksen statuskoodin sekä rungon. Alla oleva ResponseEntity-olion runko sisältää merkkijonon <code>"jack bauer"</code> ja palauttaa statuskoodin <code>200</code> eli "OK".</p>
		  
                  <pre class="sh_java">
		    ResponseEntity&lt;String&gt; vastaus = new ResponseEntity&lt;&gt;("jack bauer", HttpStatus.OK);</pre>
                </div>
              </div>
	      
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-varauspalvelu">
                      Reservations
                    </a>
                  </h1>
                </header>
                <div id="t-varauspalvelu" class="collapse">
		  
                  <p>Jatkokehitetään sovellusta huoneistojen varaamiseen ja varaustilanteen tarkasteluun. Käytössäsi on huoneistojen käsittelyyn tarvittava rajapinta, jonka palveluntarjoaja on toteuttanut sinua varten. Rajapintaa käytetään <code>ApartmentService</code>-luokan avulla, joka löytyy pakkauksesta <code>wad.ext.apartments</code>.</p>
		  
                  <p>Voit käyttää Huoneistot tehtävän vastausta osana tätä tehtävää:</p>
		  
                  <ol>
                    <li>Paketoi tehtävä Huoneistot komennolla <code>mvn clean package</code></li>
                    <li>Käynnistä huoneistot-sovellus komennolla <code>java -Dserver.port=12345 -jar target/Huoneistot-1.0-SNAPSHOT.jar</code></li>
                    <li>Tämä käynnistää Huoneistot sovelluksen paikallisen koneesi porttiin 12345 -- sovellus siis osoitteessa <code>http://localhost:12345</code> ja sen tarjoamaa rajapintaa voi hyödyntää osoitteesta <code>http://localhost:12345/api</code>.</li>
                  </ol>
		  
		  
                  <p>Tällä hetkellä sovelluksen tarjoama polussa <code>/api/reservations</code> oleva rajapinta mahdollistaa uusien varausten tekemisen sekä varausten poistamisen. Muokkaa rajapintaa siten, että sen kautta voi vain hakea tämänhetkisen varaustilanteen, mutta ei voi tehdä muutoksia siihen.</p>
		  
                  <p>Lisää tämän jälkeen sovellukseen kontrolleri, joka kuuntelee osoitteeseen <code>/reservations</code>-tehtäviä pyyntöjä. Kun osoitteeseen tehdään GET-tyyppinen pyyntö, tulee pyynnön modeliin lisätä sekä kaikki olemassaolevat varaukset että kaikki asunnot.</p>
		  
                  <p>Lisää asunnot modeliin parametrin nimellä "apartments" -- huoneistoihin pääset käsiksi <code>ApartmentService</code>-toteutuksen avulla. Varausten tulee olla modelissa parametrilla "reservations". Näytä käyttäjälle polussa <code>/src/main/resources/templates/reservations.html</code> olevasta näkymästä luotu sivu.</p>
		  
                  <p>Tämän lisäksi, kun osoitteeseen <code>/reservations</code> tehdään POST-pyyntö, missä on varauksen tiedot, varaus tulee tallentaa tietokantaan. POST-pyynnön mukana tulee muuttujat <code>reservationStart</code>, <code>reservationEnd</code> sekä <code>apartmentId</code> -- voit todennäköisesti hyödyntää luokkaa <code>Reservation</code> tässä. Kun otat pyynnön vastaan, lisää varaukseen varattavan huoneiston nimi -- voit hakea yksittäisen huoneiston tiedot huoneiston tunnuksen perusteella <code>ApartmentService</code>-palvelusta. Muistathan että POST-pyynnön jälkeen pyyntö tulee aina uudelleenohjata.</p>
		  
                  <p>Huom! Lisää kontrollerille lisäksi <code>@PostConstruct</code>-annotaatiolla merkitty metodi, joka suoritetaan kun kontrolleri on ladattu. Aseta siinä <code>ApartmentService</code>-palvelulle osoite -- käytä aiempaa huoneistotehtävän vastausta testaukseen.</p>
		  
                  <hr/>

                  <p>Muokkaa tämän jälkeen varaustoiminnallisuutta siten, että päällekkäisten varausten tekeminen ei onnistu. Samaa huoneistoa ei siis tule voida varata kahdesti samalle aikajaksolle tai osittain päällekkäiselle aikajaksolle.</p>

		  <p>Kun varausten rajaus toimii, muokkaa vielä varauksen maksuun liittyvää toiminnallisuutta. Jokaiseen varaukseen liittyy muuttuja <code>paymentStatus</code>, joka asetetaan varauksen luonnin yhteydessä <code>"UNPAID"</code>-tilaan, eli maksamattomaksi. Lisää sovellukseen toiminto, joka muuttaa varauksen maksutilaksi <code>"PAID"</code>. Tilan tulee muuttua jos osoitteeseen <code>/reservations/{id}/payment</code> tehdään POST-tyyppinen pyyntö -- tässä <code>id</code> on varauksen uniikki tunnus (<code>id</code>).</p>
		  
                  <p>Nyt varausten maksu voitaisiin periaatteessa hoitaa erillisessä palvelussa, joka päivittäisi varauksen tilan maksun yhteydessä.</p>
		  
                </div>
              </div>
            </div>
	    
	    

            <aside class="info">
	      <br/>
	      
              <h1>Lisää aiheesta</h1>
	      
              <p>Tutustu Microsoftin <a href="http://msdn.microsoft.com/en-us/library/bb833022.aspx" target="_blank">SOA-johdatukseen</a> ja katso Youtube-video <a href="https://www.youtube.com/watch?v=OY7QGDg93Ic" target="_blank">Decomposing Applications for Deployability and Scalability</a>.</p>
	      
            </aside>
	    

	    
          </section>
          <!-- END OSA6 --->


          <!-- BEGIN OSA7 --->
          <section class="weeklimit" data-week-id="7">
	    	    
            <header>
              <h1 id="osa7">Osa 7</h1>
            </header>
	    
	    <p>Kurssin seitsemäs osio alkaa laajemmalla kertaavalla tehtävällä, missä rakennetaan kolmannen osapuolen vitsejä tarjoavaan palveluun arviointitoiminnallisuus. Tämän jälkeen tutustutaan reaktiiviseen ohjelmointiin sekä web socket-teknologiaan. Viimeisen osion tehtävät ovat kaikki testittömiä: osassa toivotaan, että päätät itse lisättävän toiminnallisuuden, osassa taas toivottu toiminnallisuus on kuvattu.</p>

            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa6-kertaus-ex" data-count="61">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa6-kertaus">
                      Osa 6, kertaus: JokeVotes
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa6-kertaus" class="collapse">
		  
		  <p>Kertaustehtävässä on toteutettuna kolmannen osapuolen palvelusta vitsejä noutava sovellus. Vitseille on lisätty arviointimahdollisuus (tykkää / en tykkää). Muokkaa sovellusta siten, että käyttäjälle tarjotaan linkki eniten tykättyyn vitsiin -- linkkiä klikkaamalla kyseisen vitsin pääsee näkemään ja arvioimaan. Hyödynnä arvioita eniten tykätyn vitsin päättelyyn: jos arviot omat samat, voit päättää miten toimit.</p>
		  
                </div>
              </div>
	    </div>
	    
	    
            <aside class="info">
	      <br/>
	      
              <h1>Palveluiden löytäminen</h1>
	      
              <p>Palveluorientoituneiden arkkitehtuurien yleistyessä markkinoille on myös ilmestynyt ESB (<a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_blank">enterprise service bus</a>)-sovelluksia, joiden tehtävä on toimia viestinvälittäjänä palveluiden välillä. Viestinvälityspalveluiden käyttäminen johtaa siihen, että palvelut ovat paremmin eriytettynä toisistaan -- palvelua A käyttävä palvelu B tietää vain viestinvälittäjän sekä palvelun A tunnisteen. Palvelun A tunniste ja kuvaus voidaan saada viestinvälittäjältä, ja palvelu voi kuvata itsensä esimerkiksi RAML (<a href="http://raml.org/" target="_blank">RESTful API Modeling Language</a>)-kuvauksen tai <a href="https://helloreverb.com/developers/swagger" target="_blank">Swagger</a>in avulla.</p>
	      
              <p>Kantamme tällä kurssilla ESB-sovelluksiin on kuitenkin melko sama kuin Martin Fowlerilla ja Jim Webberillä; liika ylimääräinen toiminnallisuus voi vaikeuttaa palveluiden käyttöä ja kankeuttaa organisaatiota. Katso esitys <a href="http://www.infoq.com/presentations/soa-without-esb" target="_blank">Does My Bus Look Big in This?</a>.</p>
	      
            </aside>
	    
	    
	    <h2>Tyylitiedostot</h2>

	    <p>Olet ehkäpä huomannut, että tähän mennessä tekemämme web-sovellukset eivät ole kovin kaunista katsottavaa. Kurssilla pääpaino on palvelinpään toiminnallisuuden toteuttamisessa, joten emme jatkossakaan keskity sivustojen ulkoasuun. Sivujen ulkoasun muokkaaminen on kuitenkin melko suoraviivaista. Verkosta löytyy iso kasa oppaita sivun ulkoasun määrittelyyn -- <a href="http://www.w3schools.com/css/" target="_blank">tässä yksi</a>.</p>

	    <p>Ulkoasun määrittelyssä käytetään usein apuna valmista <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> -kirjastoa. Ulkoasun määrittely tapahtuu lisäämällä sivun <code>head</code>-osioon oleelliset kirjastot -- tässä kirjastot haetaan <a href="https://www.bootstrapcdn.com/" target="_blank">https://www.bootstrapcdn.com/</a>-palvelusta, joka tarjoaa kirjastojen ylläpito- ja latauspalvelun, jonka lisäksi elementteihin voi lisätä luokkamäärittelyjä, jotka kertovat niiden tyyleistä.</p>
	    
	    <p>Alla on esimerkki HTML-sivusta, jossa Twitter Bootstrap on otettu käyttöön. Sivulla on lisäksi määritelty <code>body</code>-elementin luokaksi (class) "container", mikä tekee sivusta päätelaitteen leveyteen reagoivan. Elementillä <code>table</code> oleva luokka "table" lisää elementtiin tyylittelyn. Erilaisiin Twitter Bootstrapin tyyleihin voi tutustua tarkemmin <a href="http://getbootstrap.com/css/" target="_blank">täällä</a>.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Blank&lt;/title&gt;
        &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/&gt;
        &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"/&gt;
        &lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body class="container"&gt;

        &lt;table class="table"&gt;
            &lt;tr&gt;
                &lt;th&gt;An&lt;/th&gt;
                &lt;th&gt;important&lt;/th&gt;
                &lt;th&gt;header&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellocss">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellocss">
                      Hello CSS
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellocss" class="collapse">
		  
		  <p>Tässä tehtävässä tavoitteena on lähinnä kokeilla sovelluksessa olevaa sivua ilman tyylitiedostoja sekä tyylitiedostojen kanssa. Käynnistä palvelin ja katso miltä juuripolussa toimiva sovellus näyttää.</p>
		  
		  <p>Sammuta tämän jälkeen palvelin ja muokkaa sovellukseen liittyvää <code>index.html</code>-tiedostoa siten, että poistat kommenttimerkit <code>head</code>-elementissä olevien Twitter Bootstrap -kirjaston linkkien ympäriltä. Käynnistä tämän jälkeen palvelin uudestaan ja katso miltä sivu tämän jälkeen näyttää. Oleellista tässä on se, että sivun ulkoasun muuttamiseen tarvittiin käytännössä vain tyylitiedostojen lisääminen.</p>
		  
		  <p>Tehtävässä ei ole testejä -- voit palauttaa sen kun olet kokeillut ylläolevaa muutosta.</p>
		  
                </div>
              </div>
            </div>
	    

	    <h1 data-count="13">Reaktiivisen sovelluksen ohjelmointi</h1>

	    <p>Tarkastellaan seuraavaksi lyhyesti reaktiivisten sovellusten ohjelmointia. Tutustumme ensin pikaisesti funktionaaliseen ohjelmointiin sekä reaktiiviseen ohjelmointiin, jonka jälkeen nämä yhdistetään. Lopuksi katsotaan erästä tapaa lisätä palvelimen ja selaimen välistä vuorovaikutusta.</p>

	    <h2>Funktionaalinen ohjelmointi</h2>


	    <p>Funktionaalisen ohjelmoinnin ydinajatuksena on ohjelmakoodin suorituksesta johtuvien sivuvaikutusten minimointi. Sivuvaikutuksilla tarkoitetaan ohjelman tai ympäristön tilaan vaikuttavia epätoivottuja muutoksia. Sivuvaikutuksia ovat esimerkiksi muuttujan arvon muuttuminen, tiedon tallentaminen tietokantaan tai esimerkiksi käyttöliittymän näkymän muuttaminen.</p>

	    <p>Keskiössä ovat puhtaat ja epäpuhtaat funktiot. Puhtaat funktiot noudattavat seuraavia periaatteita: (1) funktio ei muuta ohjelman sisäistä tilaa ja sen ainoa tuotos on funktion palauttama arvo, (2) funktion palauttama arvo määräytyy funktiolle parametrina annettavien arvojen perusteella, eikä samat parametrien arvot voi johtaa eri palautettaviin arvoihin, ja (3) funktiolle parametrina annettavat arvot on määritelty ennen funktion arvon palauttamista.</p>

	    <p>Epäpuhtaat funktiot taas voivat palauttaa arvoja, joihin vaikuttavat myös muutkin asiat kuin funktiolle annettavat parametrit, jonka lisäksi epäpuhtaat funktiot voivat muuttaa ohjelman tilaa. Tällaisia ovat esimerkiksi tietokantaa käyttävät funktiot, joiden toiminta vaikuttaa myös tietokannan sisältöön tai jotka hakevat tietokannasta tietoa.</p>


	    <p>Funktionaaliset ohjelmointikielet tarjoavat välineitä ja käytänteitä jotka "pakottavat" ohjelmistokehittäjää ohjelmoimaan funktionaalisen ohjelmoinnin periaatteita noudattaen. Tällaisia kieliä ovat esimerkiksi <a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)" target="_blank">Haskell</a>, joka on puhdas funktionaalinen ohjelmointikieli eli siinä ei ole mahdollista toteuttaa epäpuhtaita funktioita. Toinen esimerkki on <a href="https://en.wikipedia.org/wiki/Clojure" target="_blank">Clojure</a>, jossa on mahdollista toteuttaa myös epäpuhtaita funktiota -- Clojureen löytyy myös erillinen Helsingin yliopiston tarjoama MOOC (<a href="http://mooc.fi/courses/2014/clojure/" target="_blank">Functional programming with Clojure</a>).</p>

	    <p>Funktionaalisen ohjelmoinnin hyötyihin liittyy muunmuassa testattavuus. Alla on annettuna esimerkki metodista, joka palauttaa nykyisenä ajanhetkenä tietyllä kanavalla näkyvän ohjelman.</p>

	    <pre class="sh_java">
public TvOhjelma annaTvOhjelma(Opas opas, Kanava kanava) {
    Aikataulu aikataulu = opas.annaAikataulu(kanava);
    return aikataulu.annaTvOhjelma(new Date());
}
</pre>

	    <p>Ylläolevan metodin palauttamaan arvoon vaikuttaa aika, eli sen arvo ei määräydy vain annettujen parametrien perusteella. Metodin testaaminen on vaikeaa, sillä aika muuttuu jatkuvasti. Jos määrittelemme myös ajna metodin parametriksi, paranee testattavuus huomattavasti.</p>

	    <pre class="sh_java">
public TvOhjelma annaTvOhjelma(Opas opas, Kanava kanava, Date aika) {
    Aikataulu aikataulu = opas.annaAikataulu(kanava);
    return aikataulu.annaTvOhjelma(aika);
}
</pre>

	    <p>Funktionaalisessa ohjelmoinnissa käytetään alkioiden käsittelyyn työvälineitä kuten <code>map</code> ja <code>filter</code>, joista ensimmäistä käytetään arvon muuntamiseen ja jälkimmäistä arvojen rajaamiseen. Alla olevassa esimerkissä käydään läpi henkilölista ja valitaan sieltä vain Maija-nimiset henkilöt. Lopulta heiltä valitaan iät ja ne tulostetaan.</p>

<pre class="sh_java">
List&lt;Henkilo&gt; henkilot = // .. henkilo-lista saatu muualta

henkilot.stream()
        .filter(h -&gt; h.getNimi().equals("Maija"))
        .map(h -> h.getIka())
        .forEach(System.out::println);
</pre>

	    <p>Ylläolevassa esimerkissä henkilot-listan sisältö ei muutu ohjelmakoodin suorituksen aikana. Periaatteessa -- jos useampi sovellus haluaisi listaan liittyvät tiedot -- kutsun <code>System.out::println</code> voisi vaihtaa esimerkiksi tiedon lähettämiseen liittyvällä kutsulla.</p>


	    <h2>Reaktiivinen ohjelmointi</h2>

	    <p>Reaktiivisella ohjelmoinnilla tarkoitetaan ohjelmointiparadigmaa, missä ohjelman tila voidaan nähdä verkkona, missä muutokset muuttujiin vaikuttavat myös kaikkiin niistä riippuviin muuttujiin. Perinteisessä imperatiivisessa ohjelmoinnissa alla olevan ohjelman tulostus on 5.</p>

	    <pre class="sh_java">
int a = 3;
int b = 2;
int c = a + b;
a = 7;

System.out.println(c);
</pre>

	    <p>Reaktiivisessa ohjelmoinnissa asia ei kuitenkaan ole näin, vaan ohjelman tulostus olisi 9. Lauseke <code>int c = a + b;</code> määrittelee muuttujan <code>c</code> arvon riippuvaiseksi muuttujista a ja b, jolloin kaikki muutokset muuttujiin a tai b vaikuttavat myös muuttujan c arvoon.</p>

	    <p>Reaktiivista ohjelmointia hyödynnetään esimerkiksi taulukkolaskentaohjelmistoissa, missä muutokset yhteen soluun voivat vaikuttaa myös muiden solujen sisältöihin, mitkä taas mahdollisesti päivittävät muita soluja jne. Yleisemmin ajatellen reaktiivinen ohjelmointiparadigma on kätevä tapahtumaohjatussa ohjelmoinnissa; käyttöliittymässä tehtyjen toimintojen aiheuttamat muutokset johtavat myös käyttöliittymässä näkyvän tiedon päivittymisen. </p> 

	    <aside class="info">
	      <br/>
	      <h1>Aiheesta tarkemmin</h1>

	      <p>Tutustu osoitteessa <a href="http://soft.vub.ac.be/Publications/2012/vub-soft-tr-12-13.pdf" target="_blank">http://soft.vub.ac.be/Publications/2012/vub-soft-tr-12-13.pdf</a> olevaan Survey-artikkeliin, joka käsittelee reaktiivisen ohjelmoinnin kehitystä. Myös Andre Staltzin kirjoittama osoitteessa <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754" target="_blank">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a> löytyvä johdanto kannattaa lukea.</p> 
	    </aside>


	    <p>Termi reaktiivinen ohjelmointi (reactive programming) on kuormittunut, ja sillä on myös toinen yleisesti käytössä oleva merkitys. Reaktiivisella ohjelmoinnilla tarkoitetaan myös reaktiivisten sovellusten kehittämistä. </p>

	    <aside class="info">
	      <br/>
	      <h1>Reactive Manifesto</h1>
	      
	      <p>Tutustu <a href="http://www.reactivemanifesto.org/" target="_blank">Reaktiivisen sovelluskehityksen manifestiin</a>, joka ohjeistaa ohjelmistokehittäjiä luomaan sovelluksia, jotka vastaavat pyyntöön nopeasti (responsive), kestävät virhetilanteita (resilient), mukautuvat erilaisiin kuormiin (elastic) ja välittävät viestejä eri järjestelmän osa-alueiden välillä (message driven): </p>
	      
	      <p><em>Responsive: The system responds in a timely manner if at all possible. Responsiveness is the cornerstone of usability and utility, but more than that, responsiveness means that problems may be detected quickly and dealt with effectively. Responsive systems focus on providing rapid and consistent response times, establishing reliable upper bounds so they deliver a consistent quality of service. This consistent behaviour in turn simplifies error handling, builds end user confidence, and encourages further interaction.</em></p>


	      <p><em>Resilient: The system stays responsive in the face of failure. This applies not only to highly-available, mission critical systems — any system that is not resilient will be unresponsive after a failure. Resilience is achieved by replication, containment, isolation and delegation. Failures are contained within each component, isolating components from each other and thereby ensuring that parts of the system can fail and recover without compromising the system as a whole. Recovery of each component is delegated to another (external) component and high-availability is ensured by replication where necessary. The client of a component is not burdened with handling its failures.</em></p>


	      <p><em>Elastic: The system stays responsive under varying workload. Reactive Systems can react to changes in the input rate by increasing or decreasing the resources allocated to service these inputs. This implies designs that have no contention points or central bottlenecks, resulting in the ability to shard or replicate components and distribute inputs among them. Reactive Systems support predictive, as well as Reactive, scaling algorithms by providing relevant live performance measures. They achieve elasticity in a cost-effective way on commodity hardware and software platforms.</em></p>

	      <p><em>Message Driven: Reactive Systems rely on asynchronous message-passing to establish a boundary between components that ensures loose coupling, isolation and location transparency. This boundary also provides the means to delegate failures as messages. Employing explicit message-passing enables load management, elasticity, and flow control by shaping and monitoring the message queues in the system and applying back-pressure when necessary. Location transparent messaging as a means of communication makes it possible for the management of failure to work with the same constructs and semantics across a cluster or within a single host. Non-blocking communication allows recipients to only consume resources while active, leading to less system overhead.</em></p>

	      <p>Lainattu: <a href="http://www.reactivemanifesto.org/" target="_blank">http://www.reactivemanifesto.org/</a></p>

	    </aside>


	    <h2>Funktionaalinen reaktiivinen ohjelmointi</h2>


	    <p>Funktionaalinen reaktiivinen ohjelmointi on funktionaalista ohjelmointia ja reaktiivista ohjelmointia yhdistävä ohjelmointiparadigma. Järjestelmiä on karkeasti jakaen kahta tyyppiä, joista toinen perustuu viestien lähettämiseen (viestejä välitetään verkon läpi kunnes tulos saavutettu) ja toinen viestien odottamiseen (odotetaan kunnes tulokselle on tarvetta, ja tuotetaan tulos).</p>

	    <p>Materiaalin edellisessä osassa olleessa verkkokauppojen hintavertailuohjelmassa (tehtävä LowestPrices) käytettiin esimerkiksi seuraavaa lähdekoodia kaikkien verkkokauppojen läpikäyntiin:</p>

<pre class="sh_java">
// services on lista hintatietoja tarjoavia palveluita
// ja taskExecutor on Javan AsyncTaskExecutor-luokan ilmentymä
BaseService bestService = services.stream().parallel()
                .map(s -&gt; taskExecutor.submit(() -&gt; {
                            s.getLowestPrice(item);
                            return s;
                        })
                ).map(f -&gt; {
                    try {
                        return f.get();
                    } catch (Throwable t) {
                        // käsittele virhe
                        return null;
                    }
                })
                .min((s1, s2) -&gt; Double.compare(s1.getLowestPrice(item), s2.getLowestPrice(item)))
                .get();
</pre>


	    <p>Esimerkissä etsitään edullisin vaihtoehto kaikista vaihtoehdoista, jolle tehdään lopuksi jotain. Esimerkissä on kuitenkin ongelma: metodin <code>get</code>-kutsuminen <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html" target="_blank">Future</a>-rajapinnan toteuttavalle oliolle jää odottamaan tuloksen valmistumista. Samalla myös pyyntöä käsittelevä säie on odotustilassa.</p>

	    <p>Ohjelman voisi rakentaa fiksummin. Entä jos sovellus lähettäisikin vastauksen selaimelle kun laskenta on valmis, mutta ei pakottaisi säiettä odottamaan vastausta? Eräs mahdollisuus on <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank">CompletableFuture</a>-luokan käyttö, jonka avulla työn alla oleville tehtäville voidaan kertoa <em>mitä pitää tehdä sitten kun laskenta on valmis</em>. Tutustu aiheeseen tarkemmin osoitteessa <a href="http://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/" target="_blank">http://www.deadcoderising.com/java8-writing-asynchronous-code-with-completablefuture/</a>. Springin <a href="http://docs.spring.io/spring-integration/reference/html/messaging-endpoints-chapter.html#gw-completable-future" target="_blank">dokumentaatiossa</a> löytyy myös aiheeseen liittyvää sisältöä.</p>


	    <h2>Web Socketit</h2>

            <p><a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank">WebSocketit</a> ovat tapa toteuttaa palvelimen ja selaimen välinen kommunikointi siten, että selain rekisteröityy palveluun, jonka jälkeen palvelin voi lähettää selaimelle dataa ilman uutta pyyntöä selaimelta. Rekisteröityminen tapahtuu sivulla olevan Javascriptin avulla, jonka jälkeen Javascriptiä käytetään myös palvelimelta tulevan tiedon käsittelyyn.</p>

            <p>Spring tarjoaa komponentit Websockettien käyttöön. Määritellään ensin riippuvuudet projekteihin <code>spring-boot-starter-websocket</code> ja <code>spring-messaging</code>, jonka jälkeen luodaan tarvittavat konfiguraatiotiedostot.</p>

                <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-messaging&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

                <pre class="sh_java">
import org.springframework.context.annotation.Configuration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;

@Configuration
@EnableWebSocketMessageBroker
public class WebSocketConfiguration extends AbstractWebSocketMessageBrokerConfigurer {

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // osoite, johon selain ottaa yhteyttä rekisteröityäkseen
        registry.addEndpoint("/register").withSockJS();
    }

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // osoite, jonka alla websocket-kommunikaatio tapahtuu
        registry.setApplicationDestinationPrefixes("/ws");
        // osoite, jonka kautta viestit kuljetetaan
        registry.enableSimpleBroker("/channel");
    }
}</pre>

            <p>Ylläolevan konfiguraation oleellisimmat osat ovat annotaatio <code>@EnableWebSocketMessageBroker</code>, joka mahdollistaa websocketien käytön sekä luo viestinvälittäjän. Konfiguraation osa <code>registry.enableSimpleBroker("/channel");</code> luo polun, jota pitkin vastaukset lähetetään käyttäjälle ja <code>registry.setApplicationDestinationPrefixes("/ws");</code> kertoo että sovelluksen polkuun <code>/ws</code> päätyvät viestit ohjataan viestinvälittäjälle. Näiden lisäksi rivi <code>registry.addEndpoint("/register").withSockJS();</code> määrittelee <a href="http://en.wikipedia.org/wiki/Streaming_Text_Oriented_Messaging_Protocol" target="_blank">STOMP</a>-protokollalle osoitteen, mitä kautta palveluun voi rekisteröityä. Tässä lisäksi määritellään <a href="https://github.com/sockjs" target="_blank">SockJS</a> fallback-tuki, jota käytetään jos käyttäjän selain ei tue Websocketteja.</p>

            <p>Selainpuolella käyttäjä tarvitsee sekä SockJS- että StompJS-kirjastot. Hyödynnämme <a href="http://en.wikipedia.org/wiki/Content_delivery_network" target="_blank">CDN</a>-verkostoja, jotka tarjoavat staattista sisältöä sivuille ilman tarvetta niiden omalla palvelimella säilyttämiselle. Esimerkiksi <a href="http://cdnjs.com/" target="_blank">CDNJS</a>-palvelu ehdottaa edellämainituille kirjastoille olemassaolevia osoitteita -- kirjastot voi luononllisesti pitää myös osana omaa sovellusta.</p>

            <p>Kokonaisuudessaan selainpuolen toiminnallisuus on esimerkiksi seuraava -- alla body-elementin sisältö:</p>
	    
            <pre class="sh_xml">
&lt;p&gt;&lt;input type="button" onclick="send();" value="Say Wut!"/&gt;&lt;/p&gt;

&lt;script src="//cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.1.1/sockjs.min.js"&gt;&lt;/script&gt;
&lt;script src="//cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"&gt;&lt;/script&gt;

&lt;script&gt;
// luodaan asiakasohjelmisto, joka rekisteröityy osoitteeseen "/register"
var client = Stomp.over(new SockJS('/register'));

// kun käyttäjä painaa sivulla olevaa nappia, lähetetään osoitteeseen
// "/ws/messages" viesti "hello world!"
function send() {
    client.send("/ws/messages", {}, JSON.stringify({'message': 'hello world!'}));
}

// otetaan yhteys sovellukseen ja kuunnellaan "channel"-nimistä kanavaa
// -- jos kanavalta tulee viesti, näytetään JavaScript-alert ikkuna
client.connect({}, function (frame) {    
    client.subscribe('channel', function (response) {
        alert(response);
    });
});

// kun sivu suljetaan, yritetään sulkea yhteys palvelimelle
window.onbeforeunload = function () {
    client.disconnect();
}
&lt;/script&gt;</pre>

            <p>Palvelinpuolella ohjelmistomme toimii esimerkiksi seuraavasti. Kuunnellaan osoitteeseen <code>/ws/messages</code>-tulevia pyyntöjä -- allaoleva esimerkki yrittää muuntaa automaattisesti pyynnössä tulevan JSON-datan <code>Message</code>-olioksi. Toisin kuin aiemmin, käytämme nyt <code>@MessageMapping</code>-annotaatiota, joka on viestinvälityksen vastine <code>@RequestMapping</code>-annotaatiolle.</p>

            <pre class="sh_java">
@Controller
public class MessageController {
    
    // koska konfiguraatiossa määritelty "/ws"-juuripoluksi, vastaanottaa
    // tämä kontrollerimetodi osoitteeseen /ws/messages tulevat viestit
    @MessageMapping("/messages")
    public void handleMessage(Message message) throws Exception {
        // tee jotain
    }
}</pre>

            <p>Voimme lisäksi toteuttaa esimerkiksi palvelun, joka lähettää viestejä <em>kaikille</em> tiettyyn polkuun rekisteröityneille käyttäjille. Allaoleva palvelu lähettää viestin kerran kymmenessä sekunnissa.</p>

            <pre class="sh_java">
@Service
public class MessageService {

    @Autowired
    private SimpMessagingTemplate template;

    @Scheduled(fixedDelay = 10000)
    public void addMessage() {
        Message message = new Message();
        // aseta viestin sisältö
        this.template.convertAndSend("/vastauskanava", message);
    }
}
            </pre>          

            <p>Yllä käytetty <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/messaging/simp/SimpMessagingTemplate.html" target="_blank">SimpMessagingTemplate</a> on hieman kuin aiemmin käyttämämme RestTemplate, mutta eri käyttötarkoitukseen.</p>



            <div class="tehtavat">
              <div class="tehtava" id="t-chat2010">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-chat2010">
                      Chat 2010
                    </a>
                  </h1>
                </header>
		
                <div id="t-chat2010" class="collapse">
		  
                  <p>Tutustu osoitteessa <a href="http://spring.io/guides/gs/messaging-stomp-websocket/" target="_blank">http://spring.io/guides/gs/messaging-stomp-websocket/</a> olevaan oppaaseen.</p>
		  
                  <p>Tehtävässä on hahmoteltu chat-palvelua, jossa käyttäjä voi kirjautuessaan valita kanavan, mihin hän kirjoittaa viestejä. Tehtävään on hahmoteltu yksinkertainen kirjautuminen sekä käyttöliittymä, missä on toiminnallisuus yhteyden ottamiseen palvelimelle. Oletuskanavalla on myös jo yksi käyttäjä, joka lähettelee kanavalle viestejä.</p>

		  <p>Tutustu sovelluksen toimintaan, ja toteuta sovellukseen yksi uusi haluamasi toiminnallisuus. Se voi olla vaikkapa uusi viestejä lähettävä palvelu (helpohko), tai chatissa olevien henkilöiden listaaminen (haastava). Kerro tehtävän palautuksen yhteydessä kuvaus toteuttamastasi toiminnallisuudesta.</p>
		  		  
                </div>
              </div>
            </div>
	    
	    
	    <h1>Kertausta</h1>
	    

            <p>Kertauksen teemana on hieman isomman sovelluksen toteuttaminen alusta lähtien. Sovelluksen teemana on miniyhteisöpalvelu, missä käyttäjät näkevät kaveriensa viestejä; kavereiden viesteistä voidaan myös tykätä. Käytämme ulkoasupohjana netistä valmiiksi löytyvää ulkoasua. Tässä tapauksessa ulkoasumme on <a href="http://w3layouts.com/" target="_blank">w3layouts</a>-palvelun tarjoama <a href="https://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported</a>-lisenssillä varustettu <a href="http://w3layouts.com/cyan-flat-ui-kit-responsive-mobile-web-template/" target="_blank">Cyan Flat UI KIT Responsive mobile web template</a>. Käytännössä pohja tarjoaa nipun komponentteja, joita voimme hyödyntää osana sivumme rakentamista. Pohja käyttää myös valmiita Javascript- ja CSS-komponentteja, kuten <a href="http://jquery.com/" target="_blank">jQuery</a> ja <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Termi "responsive" tarkoittaa sitä, että käyttöliittymä mukautuu sitä käyttävän laitteen näytön kokoon.</p>

            <p>Ensimmäinen askel käyttöliittymän käyttöönotossa on valmiin paketin purkaminen siten, että sivun katsominen onnistuu kun palvelin käynnistetään. Ensimmäisessä tehtäväpohjassa tämä on tehty valmiiksi -- sivuun liittyvät erilaiset resurssit kuten Javascript-tiedostot ja kuvat on siirretty kansion <code>static</code>-alle, näkymän linkit on korjattu osoittamaan oikeisiin sijainteihin, ja näkymästä on luotu erillinen tiedosto <code>template.html</code>. Tämän lisäksi palvelinohjelmiston oletuskontrolleri ohjaa käyttäjän näkymään, missä tiedoston <code>template.html</code> sisältö näytetään.</p>

            <p>Seuraavat tehtäväpohjat sisältävät aina edellisen tehtävän ratkaisun, jolloin voit hypätä joidenkin kohtien yli tarvittaessa. Tehtävissä ei ole testejä; palauta tehtävä aina kun saat sen onnistuneesti valmiiksi.</p>
	    
            <div class="tehtavat">
              <div class="tehtava" id="t-henkilot-ja-viestit-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-henkilot-ja-viestit">
                      Users and Messages
                    </a>
                  </h1>
                </header>
		
                <div id="t-henkilot-ja-viestit" class="collapse">
		  
                  <p>Lisätään tässä sivulle toiminnallisuus viestien listaamiseen ja lähettämiseen. Henkilöiden luomista tai kirjautumista ei vielä toteuteta. Palauttaessasi tehtävän vakuutat että toteutuksesi toimii tehtävänannon mukaisesti.</p>
		  
                  <img src="img/exercises/w7e01-uml.png" alt="[Person|name (String)]1-*[Post|date (Date);title (String);content (String)]"/>
		  
                  <p>Luo tehtävään ylläolevassa UML-kaaviossa kuvatut entiteetit <code>Person</code> ja <code>Post</code>, sekä niille sopivat <code>Repository</code>-rajapinnat. Lisää tämän jälkeen profiiliin <code>DevProfile</code> koodi, jolla saat sovellukseen sovelluksen käynnistyessä muutaman käyttäjän sekä heille viestejä (<code>@PostConstruct</code>-annotaatiosta on tässä hyötyä!).</p>
		  
                  <p>Kun testidata on käytössä, luo <code>template.html</code>-tiedostosta kopio nimeltä <code>index.html</code>. Muokkaa luokkaa <code>DefaultController</code> siten, että pyyntö mihin tahansa osoitteeseen näyttää sivun <code>index.html</code>; lisää modeliin myös 10 uusinta viestiä, uusin ensimmäisenä.</p>
		  
                  <p>Muokkaa tämän jälkeen sivua <code>index.html</code> siten, että viestit näkyvät siinä. Löytänet oikean alueen hakemalla tekstiä <em>"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec dapibus dui id libero auctor cursus."</em>. Kun saat toteutuksen toimimaan, sinun pitäisi nähdä templaten sijaan lisäämäsi tekstit; viestialue voi näyttää esimerkiksi seuraavalta:</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-post-anonymous-sorted.png" alt="Kolme viestiä listattuna. Ensimmäisessä Anonymous -henkilö sanoo 'asdsada', toisessa Anonymous -henkilö ei sano mitään, ja kolmannessa Jack Reacher sanoo 'I'm not a vagrant. I'm a hobo. Big difference'. Viesteissä näkyy myös kellonajat."/>
                  <p>&nbsp;</p>
		  
                  <p>Lisää tämän jälkeen erillinen kontrolleri, joka kuuntelee osoitteeseen <code>/posts</code> tulevia POST-tyyppisiä pyyntöjä. Kun kontrolleri vastaanottaa pyynnön, se tallentaa viestin ja ohjaa käyttäjän oletusnäkymään (missä haetaan kymmenen uusinta viestiä). Voit hakea esimerkiksi tietokannasta satunnaisen henkilön viestin lähettäjäksi.</p>
		  
                  <p>Kun POST-pyyntöjä osoitteeseen <code>/posts</code> kuunteleva kontrolleri toimii, muokkaa <code>index.html</code>-tiedostossa olevaa viestikenttää seuraavanlaisesta</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-post-message-pre.png" alt="Lomake, missä otsikkona 'GET IN TOUCH', ja kenttinä nimi (Name), sähköposti (Email), puhelinnumero (Phone) ja viesti (Message). Lomakkeen lähetysnapissa teksti 'Send Message'."/>
                  <p>&nbsp;</p>
		  
                  <p>seuraavanlaiseksi</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-post-message-post.png" alt="Lomake, missä otsikkona 'WHAT'S GOING ON?', jonka lisäksi näkyy iso tekstialue, johon voi kirjoittaa viestin. Lomakkeen lähetysnapissa teksti 'Let 'Em Know!'."/>
                  <p>&nbsp;</p>
		  
                  <p>Kun laatikkoon kirjoitetaan viesti ja "Let 'Em Know!"-nappia painetaan, tulee viesti lähettää POST-tyyppisellä pyynnöllä osoitteeseen <code>/posts</code>. Huomaa että tarvitset lomakkeen tietojen lähettämiseen -- jos palvelin valittaa jotain CORS-teemaista, varmista, että osa lomakkeesta tehdään Thymeleafin avulla (esim <code>th:action="@{/posts}"</code>).</p>
		  
                </div>
              </div>
	      
              <div class="tehtava" id="t-profiilit-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-profiilit">
                      Profiilit
                    </a>
                  </h1>
                </header>
		
                <div id="t-profiilit" class="collapse">
		  
                  <p>Lisätään tässä sivulle toiminnallisuus henkilöiden listaamiseen. Palauttaessasi tehtävän vakuutat että toteutuksesi toimii tehtävänannon mukaisesti.</p>
		  
                  <img src="img/exercises/w7e02-uml.png" alt="[Person|name (String);slogan (String); lastUpdated (Date)]1-*[Post|date (Date);title (String);content (String)]"/>
		  
                  <p>Lisää luokalle <code>Person</code> kentät <code>lastUpdated</code> ja <code>slogan</code>. Lastupdated pitää kirjaa viimeisimmästä muutoksesta; slogan taas on -- noh -- henkilön slogan.</p>
		  
                  <p>Muokkaa tämän jälkeen oletuskontrolleria siten, että se lisää 10 viimeksi tietojaan päivittänyttä käyttäjää modeliin. Muokkaa sivua <code>index.html</code> siten, että sivulla oletuksena ollut henkilö "Zach Dunes" vaihtuu käyttäjälistaan.</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-profiilit-pre.png" alt="Kuva, missä näkyy yksittäinen Henkilö 'Zach Dunes', teksti 'Lorem ipsum dolor sit amet, (jne)' ja nappi 'Profile'" />
                  <p>&nbsp;</p>
		  
                  <p>Kun tehtävä on valmis, sivulla näkyy viimeisimmät käyttäjät ja heidän sloganit.</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-profiilit-post.png" alt="Kuva, missä kaksi henkilöä listattuna. Ensimmäisenä 'Jack Reacher', sloganina 'I know I'm smarter than an armadillo'. Toisena 'Jack Bauer', sloganina 'I'm federal agent Jack Bauer. This is the longest day of my life' Kummallekin on myös nappi, jossa lukee 'Profile'."/>
                  <p>&nbsp;</p>
		  
		  
                </div>
              </div>
	      
              <div class="tehtava" id="t-uusia-henkiloita-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-uusia-henkiloita">
                      Uusia henkilöitä
                    </a>
                  </h1>
                </header>
		
                <div id="t-uusia-henkiloita" class="collapse">
		  
                  <p>Tässä tehtävässä toteutetaan ensimmäinen versio uusien henkilöiden lisäämisestä. </p>
		  
                  <p>Muokkaa tiedostoa <code>index.html</code> siten, että kopioit nykyisen kirjautumislomakkeen ja luot siitä erillisen "Sign up"-lomakkeen, minkä avulla voi luoda uuden käyttäjän. Lomake voi näyttää esimerkiksi seuraavanlaiselta</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-sign-up.png" alt="Kirjautumislomake. Otsikkona 'Not a member? Sign Up Now', jota seuraa kaksi tekstikenttää -- yksi nimelle ja yksi sloganille. Näitä seuraa nappi 'Sign up'."/>
                  <p>&nbsp;</p>
		  
		  
                  <p>Lisää tämän jälkeen sovellukseen erillinen kontrolleri, joka kuuntelee <code>POST</code>-tyyppisiä pyyntöjä osoitteeseen <code>/persons</code>; pyynnön pohjalta luodaan uusi käyttäjä. Muokkaa kontrolleria ja juuri luomaasi lomaketta siten, että niiden avulla voidaan luoda uusia käyttäjiä. Uuden käyttäjän lisäämisen tulee onnistua kirjoittamalla käyttäjän nimi ja slogan; käyttäjien lisäämiseen erikoistunut kontrolleri tallentaa käyttäjän ja ohjaa pyynnön oletuskontrollerille.</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-signing-up.png" alt="Kirjautumislomake. Otsikkona 'Not a member? Sign Up Now', jota seuraa kaksi tekstikenttää -- yksi nimelle ja yksi sloganille. Näitä seuraa nappi 'Sign up'. Tällä kertaa nimi-kenttään on täytetty esimerkin vuoksi nimi 'Horst von der Goltz' ja slogan 'Oldies but goodies!'"/>
                  <p>&nbsp;</p>
		  
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7-signed-up.png" alt="Tässä kuvalla vinkataan, että Horst olisi luotu järjestelmään. Edellisestä tehtävästä tuttu listaus henkilöitä, mutta tässä yksi henkilöistä 'Horst von der Goltz'."/>
                  <p>&nbsp;</p>
		  
                </div>
              </div>
	      
	      
              <div class="tehtava" id="t-kirjautuminen-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-kirjautuminen">
                      Kirjautuminen
                    </a>
                  </h1>
                </header>
		
                <div id="t-kirjautuminen" class="collapse">
		  
                  <p>Tässä tehtävässä sovellukseen lisätään autorisointi- ja autentikointitoiminnallisuus. Tämän lisäksi kirjautumissivu ja uuden käyttäjän luomiseen tarkoitettu sivu muokataan erillisiksi sivuiksi, sekä asetetaan viestien lähetys niin, että niillä on oikeat kirjoittajat. </p>
		  
                  <img src="img/exercises/w7e04-uml.png" alt="[Person| name (String); slogan (String); lastUpdated (Date); username (String); password (String); salt (String)]1-*[Post|date (Date);title (String);content (String)]"/>
		  
                  <p>Ennen alkua, lisää <code>Person</code>-entiteetille kentät username, password ja salt. Käyttäjätunnuksen tulee olla uniikki.</p>
		  
                  <h1>Sivujen eriyttäminen</h1>
		  
                  <p>Kopioi <code>index.html</code>-tiedostosta kaksi uutta versiota, toisen nimeksi tulee <code>login.html</code> ja toisen nimeksi <code>signup.html</code>. Luo tämän jälkeen oletuskontrolleriin kaksi kontrollerimetodia. Pyyntö osoitteeseen <code>/login</code> näyttää sivun <code>login.html</code>. Pyyntö osoitteeseen <code>/signup</code> näyttää sivun <code>signup.html</code>.</p>
		  
                  <p>Muokkaa sivuja siten, että <code>login.html</code> näyttää seuraavalta:</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7e04-signin.png" alt="Kirjautumislomake. Otsikkona 'Sign in', jonka lisäksi lomakkeessa kaksi kenttää: 'username' ja 'password'. Näiden lisäksi lomakkeeseen liittyvä nappi 'Sign in'. Lomakkeen alapuolella on teksti 'Sign Up Now -&gt;', joka on linkki."/>
                  <p>&nbsp;</p>
		  
                  <p>Kun sivulla klikkaa linkkiä "Sign up now", pääsee osoitetta <code>/signup</code> kuuntelevan kontrollerin kautta sivulle <code>signup.html</code>, joka näyttää seuraavalta:</p>
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7e04-signup.png" alt="Rekisteröitymislomake. Otsikkona 'Sign Up Form', jonka lisäksi lomakkeessa neljä kenttää: 'name', 'slogan', 'username' ja 'password'. Näiden lisäksi lomakkeeseen liittyvä nappi 'Sign up'."/>
                  <p>&nbsp;</p>
		  
                  <p>Kirjautumissivun tulee vieläkin lähettää lomakkeelle syötettävät tiedot palvelimelle.</p>
		  
                  <h1>Tietoturvakonffit</h1>
		  
                  <p>Lue tässä välissä seuraavat sivut <a href="http://www.javacodegeeks.com/2012/08/bcrypt-salt-its-bare-minimum.html" target="_blank">http://www.javacodegeeks.com/2012/08/bcrypt-salt-its-bare-minimum.html</a> ja <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html" target="_blank">http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/crypto/bcrypt/BCrypt.html</a>.</p>
		  
                  <p>Muokkaa Person-luokan <code>setPassword</code>-metodi seuraavanlaiseksi:</p>
                  <pre class="sh_java">
    public void setPassword(String password) {
        this.salt = BCrypt.gensalt();
        this.password = BCrypt.hashpw(password, this.salt);
    }</pre>

                  <p>Jos et muista mitään <code>salt</code>-termistä tai miksi ylläoleva tehdään, lue esimerksi Wikipedian artikkeli <a href="http://en.wikipedia.org/wiki/Salt_(cryptography)" target="_blank">Salt (cryptography)</a>.</p>
		  
                  <p>Lisää tämän jälkeen projektiin Spring Security-riippuvuus, ja konfiguroi siihen liittyvä <code>SecurityConfiguration</code>-komponentti seuraavasti:</p>
		  
                  <ul>

                    <li>Kuka tahansa saa tehdä pyynnön osoitteisiin <code>/login</code>, <code>/signup</code> ja <code>/static</code> (sekä kaikkiin sen alla oleviin resursseihin). Kuka tahansa saa myös lähettää POST-tyyppisen pyynnön osoitteeseen <code>/persons</code>.</li>

                    <li>Sovelluksessa on kirjautumislomake, joka on osoitteessa <code>/login</code> -- kun kirjautuminen onnistuu, käyttäjä ohjataan oletuskontrollerin kuuntelemaan osoitteeseen.</li>

                    <li>Sovelluksessa on logout-toiminnallisuus, joka on osoitteessa <code>/logout</code> -- kun kirjautuminen onnistuu, käyttäjä ohjataan <code>/login</code>-osoitteeseen.</li>

		    <li>Kirjautumiseen käytetään alla annettua <code>JpaAuthenticationProvider</code>-luokkaa.</li>
		  </ul>

<pre class="sh_java">
@Component
public class JpaAuthenticationProvider implements AuthenticationProvider {

    @Autowired
    private PersonRepository personRepository;

    @Override
    public Authentication authenticate(Authentication a) throws AuthenticationException {
        String username = a.getPrincipal().toString();
        String password = a.getCredentials().toString();

        Person person = personRepository.findByUsername(username);

        if (person == null) {
            throw new AuthenticationException("Unable to authenticate user " + username) {
            };
        }

        if (!BCrypt.hashpw(password, person.getSalt()).equals(person.getPassword())) {
            throw new AuthenticationException("Unable to authenticate user " + username) {
            };
        }

        List&lt;GrantedAuthority&gt; grantedAuths = new ArrayList&lt;&gt;();
        grantedAuths.add(new SimpleGrantedAuthority("USER"));

        return new UsernamePasswordAuthenticationToken(person.getUsername(), password, grantedAuths);
    }

    @Override
    public boolean supports(Class&lt;?&gt; type) {
        return true;
    }
}</pre>                            

		  <p>Nyt sekä kirjautuminen käyttäjänä että käyttäjän luomisen pitäisi toimia.</p>

		  <h1>Uloskirjautuminen</h1>

		  <p>Spring Security olettaa, että uloskirjautumispyynnön mukana annetaan edellisen pyynnön vastaukseen generoitu satunnainen tunnus. Pelkkä GET-pyyntö osoitteeseen <code>/logout</code> ei toimi, sillä haluamme estää mahdollisia <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)" target="_blank">CSRF</a>-hyökkäyksiä.</p>

                  <p>Haluamme kuitenkin että logout-nappi on linkki, joten teemme erillisen piilossa olevan lomakkeen, joka lähetetään linkkiä painamalla.</p>

                  <p>Muokkaa sivun oikeassa ylälaidassa olevaa logout-nappia siten, että se lähettää piilossa generoidun lomakkeen palvelimelle. Allaolevasta koodista lienee sinulle hyötyä.</p>
		  
                  <pre class="sh_java">
&lt;ul class="logout list-unstyled"&gt;
    &lt;li&gt;&lt;a href="#" onclick="document.getElementById('logout-form').submit();"&gt;&lt;span&gt; &lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;form style="visibility: hidden" id ="logout-form" method="post" action="#" th:action="@{/logout}"&gt;&lt;input type="submit" value="Logout"/&gt;&lt;/form&gt;</pre>

                  <p>Nyt myös uloskirjautumisen pitäisi toimia.</p>
		  
		  
                  <h1>Viestien lähetys oikealla nimellä</h1>
		  
                  <p>Kun käyttäjä on sivulla, hän on kirjautunut. Käyttäjätunnukseen pääsee käsiksi <a href="http://docs.spring.io/spring-security/site/docs/current/apidocs/org/springframework/security/core/context/SecurityContextHolder.html" target="_blank">SecurityContextHolder</a>-luokan kautta, joka pitää kirjaa kirjautuneesta käyttäjästä. Luokkaa käytetään seuraavasti:</p>

                  <pre class="sh_java">
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
System.out.println(authentication.getName()); // tulostaa käyttäjätunnuksen</pre>                            

                  <p>Toteuta palvelu, jonka voi injektoida <code>@Autowired</code>-annotaation avulla mihin tahansa sovellukseen, ja jolta saa tällä hetkellä kirjautuneen käyttäjän tiedot <em>Person</em>-oliona.</p>
		  
                  <p>Lisää tämän jälkeen osoitteeseen <code>/posts</code>-tehtäviä pyyntöjä kuuntelevaan kontrolleriin toiminnallisuus, missä uutta viestiä lisättäessä sille lisätään myös oikea kirjoittaja.</p>
		  
                  <p>Nyt kun kirjaudut sovellukseen, voit kirjoittaa viestin siten, että viestin kirjoittajana näkyy käyttäjäsi nimi.</p>
                </div>
              </div>
	      


              <div class="tehtava" id="t-tykkaaminen-ex">

                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-tykkaaminen">
                      Tykkääminen
                    </a>
                  </h1>
                </header>
		
                <div id="t-tykkaaminen" class="collapse">
                  
		  <p>Tässä tehtävässä lisätään tykkäystoiminnallisuus viesteihin. </p>
		  
                  <img src="img/exercises/w7e05-uml.png" alt="[Person]-*[Post]
[Person]-*[Like]
[Like]*-[Post]"/>

                  <p>Muokkaa ensin <code>Post</code>-entiteettiä siten, että sille luodaan satunnaisesti generoitu merkkijonotunnus. Luo tämän jälkeen entiteetti <code>Like</code> (kannattanee nimetä se jotenkin ettei tietokanta hermostu :)), joka kuvaa resurssiin liittyvää tykkäystä. Pidä resurssina merkkijonoa, joka viittaa esimerkiksi postin tunnukseen; jokainen tykkäys liittyy myös käyttäjään.</p>

                  <p>Tee tämän jälkeen kontrolleri, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/likes</code>. Pyynnön mukana tulee parametri <code>resourceId</code>, joka viittaa tykättävään resurssiin -- lisää myös jokaiseen tykkäykseen <em>nykyinen</em> käyttäjä, jonka saat edellisessä tehtävässä toteutetusta palvelusta. Uudelleenohjaa käyttäjä oletuskontrollerille tykkäyksen lisäämisen jälkeen.</p>

                  <p>Muokkaa tämän jälkeen oletuskontrolleria siten, että tietokannasta haetaan sivulla näytettäviin viesteihin liittyvät tykkäykset. Lisää tykkäykset modelin attribuutiksi nimeltä <code>likes</code> -- tykkäysten tulee olla <code>Map</code>, missä avain on resurssin tunnus ja arvo tykkäysten lukumäärä.</p>

                  <p>Toteuta tämän jälkeen käyttöliittymään <em>viestikohtainen</em> tykkäyslinkki -- alla olevasta koodista lienee hyötyä.</p>

                  <pre class="sh_xml">
&lt;form style="visibility: hidden" th:id="@{like-{id}(id=${post.id})}" method="post" action="#" th:action="@{/likes}"&gt;
    &lt;input type="text" name="resourceId" th:value="${post.id}"&gt;&lt;/input&gt;
    &lt;input type="submit" value="Like"/&gt;
&lt;/form&gt;
&lt;p&gt;
    &lt;a href="#" th:onclick="@{document.getElementById('like-{id}').submit();(id=${post.id})}"&gt;+1 like&lt;/a&gt; 
    &lt;span th:if="${likes[post.id] != null}"&gt;
        &lt;span th:text="${likes[post.id]}"&gt;num&lt;/span&gt; like&lt;span th:if="${likes[post.id] &gt; 1}"&gt;s&lt;/span&gt;
    &lt;/span&gt;
&lt;/p&gt;</pre>

                  <p>Kun tehtävä toimii, sivuilla näkyy tykkäysnapit sekä tehtyjen tykkäysten määrät.</p>
		  
                  <p>&nbsp;</p>
                  
		  <img src="img/exercises/w7e05-likes.png" alt="Kuva, missä kaksi viestiä listattuna. Kummankin viestin yhteydessä on nyt linkki '+1 like', jota klikkaamalla viestistä voi tykätä. Tämän lisäksi viestissä, jota on tykätty, lukee tykkäysten lukumäärä (tykkäyslinkin vieressä)."/>
		  
		  <p>&nbsp;</p>
		  
                  <p>Huom! Jos teet tulevaisuudessa tykkäystoiminnallisuutta, joskus puhdas selainpuolen toteutus on tarpeeksi -- tutustu esimerkiksi <a href="http://socialitejs.com/" target="_blank">SocialiteJS</a>-kirjastoon.</p>
		  
                </div>
              </div>
	      
	      
              <div class="tehtava" id="t-kaverit-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-kaverit">
                      Kaverit
                    </a>
                  </h1>
                </header>
		
                <div id="t-kaverit" class="collapse">
                  
		  <p>Tässä tehtävässä lisätään mahdollisuus kaverien lisäämiseen. Palauta se taas kokonaisuutena.</p>

                  <img src="img/exercises/w7e06-uml.png" alt="[Person]-*[Post]
[Person]-*[Like]
[Like]*-[Post]
[FriendshipRequest|status (Status)]-2[Person]
--pyyntöön kuuluu sekä pyynnön lähettäjä (source) ja pyynnön vastaanottaja (target)"/>
                  <h1>Entiteetti ja kaveripyynnön lisäys</h1>
		  
                  <p>Luo entiteetti <code>FriendshipRequest</code>, jossa on <code>Person</code>-olio sekä lähteenä että kohteena (source & target). Tämän lisäksi entiteetillä on status, joka voi saada arvot <code>Requested</code>, <code>Accepted</code>, <code>Rejected</code>.</p>
		  
                  <p>Kun entiteetti on olemassa, luo uusi kontrolleri, joka kuuntelee POST-tyyppisiä pyyntöjä osoitteeseen <code>/friends</code>. POST-tyyppinen pyyntö saa parametrina kentän muuttujan <code>personId</code>, joka on sen käyttäjän tunnus, kenelle kaveripyyntö tehdään. Tallenna pyyntö tietokantaan jos tietokannassa ei ole jo samaa pyyntöä tai vastaavaa pyyntöä, siten, että lähde ja kohde ovat vaihtuneet päittäin.</p>
		  
                  <p>Muokkaa vielä käyttöliittymää siten, että käyttäjäprofiili näyttää seuraavalta -- listassa tulee näkyä vain ne käyttäjät, jotka eivät ole nykyisen käyttäjän kavereita.</p>
		  
		  
                  <p>&nbsp;</p>
		  
                  <img src="img/exercises/w7e06-friendem.png" alt="Käyttäjän listaus, sama kuin profiileissa. Nyt käyttäjän 'Profile' -napin sijaan näkyy teksti 'Friend 'Em!', mitä klikkaamalla kirjautunut käyttäjä lähettää kohteelle kaveripyynnön."/>
		  
                  <p>&nbsp;</p>
		  
                  <p>Allaolevasta koodista lienee hyötyä.</p>
		  
                  <pre class="sh_xml">
&lt;form method="POST" th:action="@{/friends}"&gt;
    &lt;input type="hidden" name="personId" th:value="${user.id}"/&gt;
    &lt;input type="submit" class="p-btn" value="Friend 'em!"/&gt;
&lt;/form&gt;</pre>


                  <h1>Kaveripyyntöjen näyttäminen</h1>
		  
                  <p>Muokkaa oletuskontrolleria siten, että vastaukseen lisätään niiden kaveripyyntöjen lukumäärä, joiden status on <code>Requested</code> ja kohde nykyinen käyttäjä. Muokkaa tämän jälkeen sivua <code>index.html</code> siten, että sivun oikeassa ylälaidassa näytetään notifikaatio, vain jos käyttäjälle on kaveripyyntöjä.</p> 
		  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7e06-notif.png" alt="Tässä näkyy (1) kuva pienellä -- nyt joku valmis kuva, ei siis tartte toteuttaa kuvatoiminnallisuutta, (2) notifikaatiokuva 'kello', ja (3) logout-nappi. Enpä oikein osaa selittää tätä paremmin.." />
                  <p>&nbsp;</p>
                  
                  <p>Muokkaa notifikaatiota siten, että kun notifikaatiota klikataan, niin käyttäjä tekee GET-pyynnön osoitteeseen <code>/friends</code>.</p>
		  
                  
                  <h1>Kaveripyyntöjen hyväksyminen</h1>
		  
                  <p>Muokkaa <code>/friends</code>-osoitetta kuuntelevaa kontrolleria siten, että se palauttaa käyttäjälle tehdyt kaveripyynnöt ja näyttää sivun <code>friends.html</code></p>
		  
                  <p>Tee tämän jälkeen sivusta <code>index.html</code> kopio <code>friends.html</code> ja muokkaa sitä siten, että se näyttää vain listan käyttäjiä. Muokkaa käyttäjälistaa siten, että jokaiselle käyttäjälle on nappi "Ok! I Like 'im!".</p>
                  
                  <p>&nbsp;</p>
                  <img src="img/exercises/w7e06-notif.png" alt="Täsmälleen sama kuva kuin aiemmin."/>
                  <p>&nbsp;</p>
                  
                  <p>Kun nappia painetaan, käyttäjän pitäisi olla toisen käyttäjän kaveri.</p>
                  
                </div>
              </div>
              
              
              <div class="tehtava" id="t-omafeature-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-omafeature">
                      Oma feature
                    </a>
                  </h1>
                </header>
		
                <div id="t-omafeature" class="collapse">
                  <p>Lisää tässä tehtävässä oma feature sovellukseen -- esimerkiksi mahdollisuus profiilikuvien tai muiden kuvien lisääminen.</p>
                </div>
              </div>
            </div>
	    
            <p>Kuten huomaat, yhteisöpalvelumme on vielä kaukana valmiista -- ensiaskeleet on kuitenkin tehty. Ennenpitkää sovellus pilkottaisiin pienempiin palasiin, ja sovelluksen toiminta rakennettaisiin niin, että sivulle toteutettava JavaScript-komponentti hakisi sivun sisällön useammasta eri palvelusta. Palaamme tähän <em>myöhemmin..</em>.</p>
	    
	    
          </section>
          <!-- END OSA7 --->



          <!-- BEGIN OSAX --->
          <section class="weeklimit" data-week-id="X">


            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-twiitberg">
                      Twiitberg
                    </a>
                  </h1>
                </header>
                <div id="t-twiitberg" class="collapse">
		  
                  <p>Tehtäväpohjaan on hahmoteltu palvelua, minne käyttäjä voi lisätä lyhyitä viestejä ja kuvia. Kuten huomaat, sovellus on jäänyt kesken, eikä edes autentikointi toimi. Tehtävänäsi tässä on (1) tutustua palveluun, (2) korjata autentikaatio, ja (3) keksiä toiminnallisuus tai kaksi, mitä palvelussa ei vielä ole, ja mitä siellä pitäisi olla. Toteuta keksimäsi toiminnallisuudet, ja palauta tehtävä.</p>
		  
                </div>
              </div>
            </div>


	    
            <header>
              <h1 id="osaX">Osa X</h1>
            </header>


                <aside class="info">
		  
                  <h1>Palveluiden löytäminen</h1>
		  
                  <p>Palveluorientoituneiden arkkitehtuurien yleistyessä markkinoille on myös ilmestynyt ESB (<a href="http://en.wikipedia.org/wiki/Enterprise_service_bus" target="_blank">enterprise service bus</a>)-sovelluksia, joiden tehtävä on toimia viestinvälittäjänä palveluiden välillä. Viestinvälityspalveluiden käyttäminen johtaa siihen, että palvelut ovat paremmin eriytettynä toisistaan -- palvelua A käyttävä palvelu B tietää vain viestinvälittäjän sekä palvelun A tunnisteen. Palvelun A tunniste ja kuvaus voidaan saada viestinvälittäjältä, ja palvelu voi kuvata itsensä esimerkiksi RAML (<a href="http://raml.org/" target="_blank">RESTful API Modeling Language</a>)-kuvauksen tai <a href="https://helloreverb.com/developers/swagger" target="_blank">Swagger</a>in avulla.</p>
		  
                  <p>Kantamme tällä kurssilla ESB-sovelluksiin on kuitenkin melko sama kuin Martin Fowlerilla ja Jim Webberillä; liika ylimääräinen toiminnallisuus voi vaikeuttaa palveluiden käyttöä ja kankeuttaa organisaatiota. Katso esitys <a href="http://www.infoq.com/presentations/soa-without-esb" target="_blank">Does My Bus Look Big in This?</a>.</p>
		  
                </aside>

	    <p>palveluihin jakaminen hajauttaa myös työtä; tiimeille vastuut komponenteista, helppo outsourcata</p>

	    <p>TODO: Modular, polyglot, multi-framework applications</p>

	    <p>arkkitehtuuri: system-level arkkitehtuuri, mitkä palat koko sovelluksessa, miten muuttuvat -- palvelutason arkkitehtuuri, kussakin palvelussa omat toteutukset, omat menetelmät, omat ... muuttuvat nopeasti</p>

	    <p>regular rewrite; Case Viro, jos pieniä palveluita, uudelleenkirjoittaminen myös helpompaa -- välillä tilanne vaan on se, että joku kirjasto tekee osan siitä työstä mitä on itse tehnyt; hyvä koodari uskaltaa heittää oman koodinsa menemään.</p>

	    <p>säikeiden kanssa eläminen: jos toinen palvelu alhaalla, omakin palvelu voi kaatua jos kaikki venaavat toista palvelua</p>

	    <p>http://martinfowler.com/bliki/CircuitBreaker.html</p>

	    <p>http://geode.apache.org/</p>

	    <p>http://www.planetcassandra.org/nosql-performance-benchmarks/</p>




	    <p>pari sanaa dockerista, mutta, onko järkevä? https://springframework.guru/running-spring-boot-in-a-docker-container/</p>
	    <p>https://valdhaus.co/writings/docker-misconceptions/</p>

	    <p>https://www.youtube.com/watch?v=OY7QGDg93Ic</p>
	    <p>https://www.youtube.com/watch?v=1mMDl-0Scmc</p>
	    
	    
	    
            <p><em>Kts. <a href="http://en.wikipedia.org/wiki/Scalability" target="_blank">Wikipedian määritelmä skaalautuvuudelle</a></em></p>
	    
	    

	    <p>https://www.youtube.com/watch?v=IGS-rqSjmFk</p>


	    <h2>Uhkamallinnus</h2>

	    <p>https://www.owasp.org/index.php/Application_Threat_Modeling</p>


	    <h2>react</h2>

	    <p>https://www.youtube.com/watch?v=fec9nEIybp0</p>

	    <p>reactive manifesto</p>

	    <aside class="info">

	      <br/>
	      <h1>Palvelunestohyökkäykset</h1>

	      <p>
http://www.networkworld.com/article/2170051/tech-primers/tech-primers-four-ways-to-defend-against-ddos-attacks.html</p>

	      <p>https://www.heroku.com/policy/security</p>

	      <p>pilvipalveluiden käyttö, skaalautuminen</p>

	    </aside>
	    
	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-twiitberg">
                      Twiitberg
                    </a>
                  </h1>
                </header>
                <div id="t-twiitberg" class="collapse">
		  
                  <p>Tehtäväpohjaan on hahmoteltu palvelua, minne käyttäjä voi lisätä lyhyitä viestejä ja kuvia. Kuten huomaat, sovellus on jäänyt kesken, eikä edes autentikointi toimi. Tehtävänäsi tässä on (1) tutustua palveluun, (2) korjata autentikaatio, ja (3) keksiä toiminnallisuus tai kaksi, mitä palvelussa ei vielä ole, ja mitä siellä pitäisi olla. Toteuta keksimäsi toiminnallisuudet, ja palauta tehtävä.</p>
		  
                  <p>Kirjoita tehtävän palautuksen yhteyteen toteuttamasi ominaisuudet -- tehtävä on kolmen kurssipisteen arvoinen.</p>
		  
                </div>
              </div>
            </div>


            <p>Jos palvelua haluaa käyttää selainohjelmistosta, onnistuu se esimerkiksi <a href="http://jquery.com/" target="_blank">jQuery</a>-projektin avulla. Yksittäisen kirjan tietojen hakeminen ja nimen näyttäminen käyttäjälle onnistuu yksinkertaisimmillaan seuraavasti:</p>

            <pre class="sh_java">
$.get("<em>osoite</em>/books/5", function( data ) {
  alert( "Tunnuksella 5 löytyi kirja nimeltä: " + data.name );
});</pre>



	    <p>https://crackstation.net/hashing-security.htm</p>

	    
            <div class="tehtavat">
              <div class="tehtava" id="t-readinglist-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-readinglist">
                      Reading List
                    </a>
                  </h1>
                </header>
		
                <div id="t-readinglist" class="collapse">
		  
		  <p>Lukulistasovellus tarjoaa käyttäjälle mahdollisuuden lisätä uusia kirjoja lukulistalle, sekä päivittää jo listalla olevien kirjojen lukustatusta. Kukin kirja voi olla tilassa "unread" (lukematon), "reading" (lukemassa) tai "read" (luettu).</p>
		  
		  <p>Kirjan tilan vaihtaminen tapahtuu käyttöliittymässä olevaa nappia painamalla, ja uuden kirjan lisääminen onnistuu alalaidassa olevan lomakkeen avulla.</p>
		  
		  <img src="img/mooc/ex27-list.png" class="naytto"/>
		  
		  <p>Toteuta ohjelman toimintaan tarvittava tietokantatoiminnallisuus sekä oleelliset ReadingList-luokan vaatimat pyyntömäärittelyt. Kannattanee aloittaa tietokantaa käyttävän luokan (esim. BookDao) määrittelyllä -- tietokantaskeema on annettuna tiedostossa <code>database-schema.sql</code>, jonka lisäksi <code>Book</code>-oliosta lienee hyötyä. Käyttöliittymä on projektissa annettu valmiina.</p> 
		  
                </div>
              </div>
            </div>		
	    
            <div class="tehtavat">
              <div class="tehtava" id="t-helloonetomany-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloonetomany">
                      Hello One-to-Many
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloonetomany" class="collapse">
		  
		  <p>Lue <a href="http://tietokantojen-perusteet.github.io/#chapter6-1" target="_blank">tietokantojen perusteiden</a> kurssimateriaalin luku 6.1.</p>
		  
		  <p>Tässä tehtävässä käytössä on kaksi taulua sisältävä tietokanta. Tietokantataulujen määrittely on seuraava:</p>
		  
<pre class="sh_sql">
CREATE TABLE Agency (
    id integer AUTO_INCREMENT PRIMARY KEY,
    name varchar(200)
);

CREATE TABLE Agent (
    id varchar(9) PRIMARY KEY,
    agency_id integer NOT NULL,
    name varchar(200),
    FOREIGN KEY (agency_id) REFERENCES Agency(id)
);
</pre>

		  <p>Jokaisella agentilla on organisaatio (Agency), johon agentti kuuluu.</p>
		  
		  <p>Tällä hetkellä organisaatiolle löytyy AgencyDao-luokka, jonka avulla organisaatiot saa haettua näppärästi tietokannasta. AgentDao-luokan toiminnallisuudesta puuttuu kuitenkin täysin agenttien liittyminen organisaatioihin. Täydennä AgentDao-luokkaa seuraavasti:</p>

		  <ul>
		    <li>Metodi <code>create(Agent agent)</code> tallentaa agentin tietokantaan siten, että agenttiin liittyy myös organisaatio. Voit olettaa, että metodikutsu agent.getAgency() ei palauta <code>null</code>-viitettä.</li>
		    <li>Metodi <code>findOne(String key)</code> etsii tietokannasta agentin avaimen perusteella (id) ja palauttaa sen. Agenttiin tulee olla lisättynä myös organisaatio, johon agentti kuuluu. Palautettavan agentin metodin <code>getAgency</code> tulee siis palauttaa oikea organisaatio.</li>
		    <li>Metodi <code>findAll()</code> palauttaa kaikki agentit. Kuten edellä, myös tässä jokaisella agentilla tulee olla myös oikea organisaatio.</li>
		    <li>Metodi <code>findByAgency(Agency a)</code> palauttaa kaikki agentit, joiden organisaatio on parametrina annettu organisaatio. Agenttien organisaatioiden tulee olla myös tässä oikein merkitty.</li>
		    <li>Metodi <code>delete(String key)</code> poistaa tietokannasta agentin, jonka tunnus on <code>key</code>.</li>
		  </ul>
		  
                </div>
              </div>
            </div>		
	    
	    
            <div class="tehtavat">
              <div class="tehtava" id="t-hellocategories-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellocategories">
                      Hello Categories
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellocategories" class="collapse">
		  
		  <p>Otetaan juuri harjoiteltu yhdestä-moneen -toiminnallisuus käyttöön web-sovelluksessa, missä tarkoituksena on kategorisoida esineitä. Käytössä oleva tietokantaskeema on seuraavanlainen:</p>
		  
<pre class="sh_sql">
CREATE TABLE Category (
    id integer AUTO_INCREMENT PRIMARY KEY,
    name varchar(200)
);

CREATE TABLE Item (
    id integer AUTO_INCREMENT PRIMARY KEY,
    category_id integer NOT NULL,
    name varchar(200),
    FOREIGN KEY (category_id) REFERENCES Category(id)
);
</pre>

		  <p>Tässä tehtävässä tavoitteenasi on toteuttaa esineiden kategorisointiin vaadittava toiminnallisuus -- sovelluksen ulkoasu on seuraavanlainen:</p>
		  
		  <img src="img/mooc/ex29-categories.png" class="naytto"/>
		  
		  <img src="img/mooc/ex29-items.png" class="naytto"/>
		  

		  
		  <p>Ohjelman rajapinnat, eli tässä tapauksessa osoitteet, ovat seuraavat:</p>
		  
		  <ul>
		    <li>GET-pyyntö osoitteeseen <code>/category</code> listaa kaikki tietokannassa olevat kategoriat.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category</code> luo tietokantaan uuden kategorian. Kategorian nimi tulee pyynnön parametrina nimeltä "name". Uudelleenohjaa pyynnön osoitteeseen <code>/category</code>.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category/:id/delete</code> poistaa tunnuksella <code>:id</code> tietokantaan tallennetun kategorian <em>sekä</em> kaikki siihen liittyvät esineet. Uudelleenohjaa pyynnön osoitteeseen <code>/category</code>. Kertaa miten <code>req.param(":id")</code> toimii!</li>
		    
		    <li>GET-pyyntö osoitteeseen <code>/category/:id</code> näyttää <code>:id</code>-tunnuksella merkityn kategorian sekä kaikki siihen liittyvät esineet.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category/:id/item</code> lisää <code>:id</code>-tunnuksella merkittyyn kategoriaan uuden esineen. Esineen nimi tulee pyynnön parametrina nimeltä "name". Uudelleenohjaa pyynnön osoitteeseen <code>/category/:id</code>, missä <code>:id</code> on kategorian tunnus.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category/:id/item/:itemId/delete</code> poistaa <code>:itemId</code>-tunnuksella merkityn esineen tietokannasta. Uudelleenohjaa pyynnön osoitteeseen <code>/category/:id</code>, missä <code>:id</code> on kategorian tunnus.</li>
		  </ul>
		  
		  
		  <p>Tutki tehtävässä valmiiksi annettuja komponentteja ennen aloitusta, ja mieti mitkä palat ovat niitä, jotka tarvitset ensiksi. Voi olla hyvä aloittaa vain kategorioiden käsittelystä ja edetä vasta sitten esineiden käsittelyyn kun kategorioihin liittyvä toiminnallisuus on kunnossa.</p>
		  
		  
                </div>
              </div>
            </div>		
	    
	    
	    <h2>Tyylitiedostot</h2>

	    <p>Olet ehkäpä huomannut, että tähän mennessä tekemämme web-sovellukset eivät ole kovin kaunista katsottavaa. Kurssilla pääpaino on palvelinpään toiminnallisuuden toteuttamisessa, joten emme jatkossakaan keskity sivustojen ulkoasuun. Sivujen ulkoasun muokkaaminen on kuitenkin melko suoraviivaista. Verkosta löytyy iso kasa oppaita sivun ulkoasun määrittelyyn -- <a href="http://www.w3schools.com/css/" target="_blank">tässä yksi</a>.</p>

	    <p>Käytämme kurssilla muutamassa tehtävässä valmista <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> -kirjastoa ulkoasun määrittelyyn. Ulkoasun määrittely tapahtuu lisäämällä sivun <code>head</code>-osioon oleelliset kirjastot -- tässä kirjastot haetaan <a href="https://www.bootstrapcdn.com/" target="_blank">https://www.bootstrapcdn.com/</a>-palvelusta, joka tarjoaa kirjastojen ylläpito- ja latauspalvelun.</p>
	    
	    <p>Alla on esimerkki HTML-sivusta, jossa Twitter Bootstrap on otettu käyttöön. Sivulla on lisäksi määritelty <code>body</code>-elementin luokaksi (class) "container", mikä tekee sivusta päätelaitteen leveyteen reagoivan. Elementillä <code>table</code> oleva luokka "table" lisää elementtiin tyylittelyn. Erilaisiin Twitter Bootstrapin tyyleihin voi tutustua tarkemmin <a href="http://getbootstrap.com/css/" target="_blank">täällä</a>.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Blank&lt;/title&gt;
        &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/&gt;
        &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"/&gt;
        &lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body class="container"&gt;

        &lt;table class="table"&gt;
            &lt;tr&gt;
                &lt;th&gt;An&lt;/th&gt;
                &lt;th&gt;important&lt;/th&gt;
                &lt;th&gt;header&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellocss">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellocss">
                      Hello CSS
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellocss" class="collapse">
		  
		  <p>Tässä tehtävässä tavoitteena on lähinnä kokeilla sovelluksessa olevaa sivua ilman tyylitiedostoja sekä tyylitiedostojen kanssa. Käynnistä palvelin ja katso miltä juuripolussa toimiva sovellus näyttää.</p>
		  
		  <p>Sammuta tämän jälkeen palvelin ja muokkaa sovellukseen liittyvää <code>index.html</code>-tiedostoa siten, että poistat kommenttimerkit <code>head</code>-elementissä olevien Twitter Bootstrap -kirjaston linkkien ympäriltä. Käynnistä tämän jälkeen palvelin uudestaan ja katso miltä sivu tämän jälkeen näyttää. Oleellista tässä on se, että sivun ulkoasun muuttamiseen tarvittiin käytännössä vain tyylitiedostojen lisääminen.</p>

		  <p>Tehtävässä ei ole testejä -- voit palauttaa sen kun olet kokeillut ylläolevaa muutosta.</p>

                </div>
              </div>
            </div>

	    
	    
	    <h3>Istunnot ja Spark</h3>
	    
	    <p>Spark tarjoaa toiminnallisuuden <a href="http://sparkjava.com/documentation.html#sessions" target="_blank">istuntojen luomiseen ja hallintaan</a> <a href="http://sparkjava.com/documentation.html#request" target="_blank">Request</a>-olion tarjoaman <code>session</code>-metodin avulla. Uuden istunnon luominen sekä vanhan istunnon noutaminen tapahtuu antamalla Request-olion session-metodille parametrina arvo <code>true</code>.</p>
	    
	    <p>Session-olio tarjoaa kaksi oleellista metodia. Metodi <code>attribute(String key)</code> palauttaa istuntoon <code>key</code>-tunnuksella tallennetun olion tai arvon, ja metodi <code>attribute(String key, Object value)</code> tallentaa istuntoon <code>key</code>-tunnuksella <code>value</code>-arvon. Alla oleva ohjelmakoodi lisää istuntoon tiedon ensimmäisen pyynnön ajanhetkestä, ja palauttaa sen aina pyynnön yhteydessä.</p>

<pre class="sh_java">
// Session-olio haetaan pakkauksesta spark
import spark.Session;
import java.util.Date;

// ...
get("/", (req, res) -> {
    Session sess = req.session(true);
    
    if (sess.attribute("InitialRequest") == null) {
        sess.attribute("InitialRequest", new Date().toString());
    }
    
    return "First request was made at: " + (String) sess.attribute("InitialRequest");
});
// ...</pre>
 
	    <p></p>


	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-hellosession-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellosession">
                      Hello Session!
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellosession" class="collapse">
		  
		  <p>Toteuta sovellus, joka laskee henkilökohtaisia pyyntöjen määriä. Pyyntöjen määrät tulee tallentaa istuntoon.</p>
		  
		  <p>Kun käyttäjä tekee pyynnön palvelimelle, tulee vastauksen ensimmäiseen pyyntöön olla muotoa "counter: 1". Toiseen pyyntöön vastaus on "counter: 2", kolmanteen "counter: 3" jne. Kun toinen käyttäjä tekee pyynnön, tulee vastauksen olla muotoa "counter: 1". Toiseen pyyntöön vastaus on "counter: 2" jne.</p>
                </div>
              </div>
	    </div>
	    
	    <h3>Pyyntöjen tarkastelu Sparkissa</h3>
	    
	    <p>Spark tarjoaa näppärän toiminnallisuuden pyyntöjen tarkasteluun jo ennen kuin ne ohjataan <code>get</code> tai <code>post</code>-metodikutsuilla määriteltyihin metodeihin. Metodilla <code>before</code> voidaan määritellä toiminnallisuutta, joka suoritetaan ennen pyynnön ohjaamista eteenpäin. Esimerkiksi alla oleva ohjelmakoodi tulostaa jokaisen pyynnön yhteydessä osoitteen, johon pyyntö on tehty.</p>

<pre class="sh_java">
before("*", (req, res) -> {
    System.out.println("Request to " + req.url());
});
</pre>

	    <p>Suoritus jatkuu <code>before</code>ssa määritetyn koodin suorituksen jälkeen normaalisti, eli pyyntö ohjataan metodiin, joka käsittelee pyynnössä määriteltyä polkua. Pyynnön voi myös <a href="http://sparkjava.com/documentation.html#redirects" target="_blank">uudelleenohjata</a> tai pyynnön suorituksen voi <a href="http://sparkjava.com/documentation.html#halting" target="_blank">keskeyttää</a> tarvittaessa.</p>

            <div class="tehtavat">
	      
              <div class="tehtava" id="t-helloauth-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloauth">
                      Hello Auth!
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloauth" class="collapse">
		  
		  <p>Tässä tehtävässä tehtävänäsi on toteuttaa yksinkertainen kirjautumistoiminnallisuus. Tehtäväpohjassa on tarjottuna lomake kirjautumiseen, sekä salainen sivu, joka tulee näyttää käyttäjälle jos kirjautuminen onnistuu.</p>

		  <p>Oikea käyttäjätunnus on <strong><code>user</code></strong> ja oikea salasana on <strong><code>pw</code></strong>.</p>

		  <p>Ohjelman toiminnallisuuden tulee olla seuraava:</p>

		  <ul>
		    <li>Kun käyttäjä avaa sovelluksen selaimessa (esim. http://localhost:4567), tulee käyttäjälle näyttää sivu <code>index.html</code>.</li>
		    <li>Kun käyttäjä yrittää kirjautua lomakkeen avulla, tulee käyttäjätunnus ja salasana tarkistaa. Jos käyttäjätunnus ja salasana ovat oikein, käyttäjälle luodaan istunto, missä on tieto kirjautumisen onnistumisesta ja käyttäjä ohjataan osoitteeseen <code>/secret/</code>. Jos käyttäjätunnus tai salasana on väärin, tulee käyttäjälle näyttää sivu <code>index.html</code> siten, että käyttäjä näkee virheviestin <code>"Invalid credentials, try again."</code>.</li>
		    <li>Kun käyttäjä yrittää avata osoitteen <code>/secret/</code> tulee palvelimen tarkastaa onko käyttäjällä istuntoa, jossa olisi määritelty kirjautumisen onnistuminen. Jos istuntoa ei löydy, tulee käyttäjälle palauttaa statuskoodi <code>401</code> ja viesti <code>"Not allowed"</code>. Jos istunto löytyy, käyttäjälle näytetään sivun <code>secret.html</code> sisältö.</li>
		  </ul>
		  
                </div>
              </div>
	    </div>
	    
	    
            <div class="tehtavat">
              <div class="tehtava" id="t-shoppingspree-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-shoppingspree">
                      Shopping Spree!
                    </a>
                  </h1>
                </header>
		
                <div id="t-shoppingspree" class="collapse">
		  
		  <p>Istuntoon voidaan tallentaa myös olioita. Tyypillinen esimerkki tällaisesta on ostoskorin täyttäminen.</p>
		  
		  <p>Tehtäväpohjaan on toteutettu osa ostoskoritoiminnallisuuden vaatimista komponenteista. Tehtävänäsi on:</p>

		  <ul>
		    <li>ShoppingSpree-luokan toiminnallisuutta siten, että ostoskori tallennetaan käyttäjäkohtaiseen istuntoon.</li>
		    <li>Esineen ostoskoriin lisäämisen toteuttaminen palvelinpäässä -- selainpuolen toiminnallisuus on toteutettu.</li>
		    <li>Checkout-linkin tarvitseman toiminnallisuuden toteuttaminen -- käyttäjän tulee siis pystyä menemään checkout-sivulle, jossa näytetään ostoskorin tämän hetkinen sisältö.</li>
		  </ul>
		  
                </div>
              </div>
            </div>
	    

	    
            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-rakkausmittari">
                      Rakkausmittari
                    </a>
                  </h1>
                </header>
                <div id="t-rakkausmittari" class="collapse">
		  
                  <p>Tehtävässä hyödynnetään ysärihittiä ja jatkokehitetään sovellusta, jota käytetään kahden henkilön yhteensopivuuden laskemiseen.</p>
		  
                  <p>Lisää ensiksi LoveService-luokalle <code>@Service</code>-annotaatio, ja <em>injektoi</em> se luokkaan <code>LoveController</code>. Toteuta tämän jälkeen kontrolleriluokkaan metodi, joka ottaa POST-tyyppisen pyynnön vastaan, ja luo pyynnössä olevista parametreista <code>Pair</code>-olion.</p>
		  
                  <p>Kun Pair-olio on vastaanotettu, käytä kontrolleriin injektoitua <code>LoveService</code>-oliota yhteensopivuuden laskemiseksi.</p>
		  
                  <p>Lopuksi, ohjaa käyttäjä tekemään GET-pyyntö <code>/loves</code>-osoitteeseen. Lisää <code>RedirectAttributes</code>-luokan avulla seuraavaan pyyntöön yhteensopivuutta kuvaava arvo sekä pyynnön parametreista generoitu <code>Pair</code>-luokka. Kun lisäät edellä mainittuja <code>RedirectAttributes</code>-olioon, käytä yhteensopivuusarvon nimenä merkkijonoa <code>match</code> ja pair-olion nimenä merkkijonoa <code>pair</code>. </p>
		  
                </div>
              </div>
            </div>



            <p>Käytännössä palvelin ja sovelluskehys ottaa vastuuta luokkien hallinnoinnista. Sovelluskehys syöttää riippuvuudet niitä tarvittaessa. Molemmat toiminnallisuudet ovat oleellisia kerrosarkkitehtuurin kerrosten toisistaan erottamisessa.</p>
	    

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-chat">
                      Chat
                    </a>
                  </h1>
                </header>
                <div id="t-chat" class="collapse">
		  
                  <p>Sovelluksessa on valmis Chat-palvelu, sekä valmis komponentti kolmannen osapuolen chattikaverin käyttämiseen, jota ei kuitenkaan ole vielä liitetty sovellukseen. Tässä kolmannen osapuolen palvelu integroidaan osaksi chat-palvelua.</p>
		  
                  <p>Sovelluksen rakenne on seuraava. Luokka <code>MessageController</code> ottaa vastaan pyyntöjä käyttöliittymältä, ja ohjaa niitä <code>MessageService</code>-palvelulle. MessageService tarjoaa metodit viestien listaamiseen ja uuden viestin tallentamiseen: tallentaminen tapahtuu <code>MessageRepository</code>-rajapintaa käyttämällä.</p>
		  
                  <p>Muokkaa <code>MessageService</code>-luokan tarjoamaa viestin tallennusmetodia siten, että kun käyttäjän kirjoittama viesti on tallennettu, viesti annetaan <code>ChatService</code>-oliolle, jonka palauttama viesti myös tallennetaan. Injektoi <code>ChatService</code>-palvelu <code>MessageService</code>-palveluun. Huom! Aseta injektoidun ChatService-olion nimeksi <code>chatService</code>.</p>
		  
                  <p>Kun sovellus toimii, keskustelun pitäisi näyttää esimerkiksi seuraavanlaiselta:</p>
		  
<pre>
You: hello
Mitsuku: How are you today?
You: good, all peanuts
Mitsuku: Glad to hear it.</pre>
                </div>
              </div>
            </div>






            <div class="tehtavat">
              <div class="tehtava" id="t-epicshop-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-epicshop">
                      Epic Shop
                    </a>
                  </h1>
                </header>
		
                <div id="t-epicshop" class="collapse">
		  
		  <p>Epic Shop-tehtävässä tavoitteenasi on suunnitella ja toteuttaa verkkokauppa, jossa tulee olla seuraavat toiminnallisuudet:</p>
		  <ul>
		    <li>Kauppias voi lisätä kauppaan ostettavia esineitä. Jokaisella esineellä on nimi ja hinta.</li>
		    <li>Asiakas voi listata kaupan esineet ja lisätä niitä ostoskoriin. Ostoskori tallennetaan sessioon.</li>
		    <li>Asiakas voi tilata ostoskorissa olevat esineet. Kun asiakas tilaa esineet, tulee tilaus kauppiaalle näkyviin. Tilauksessa on listaus esineistä sekä asiakkaan nimi ja osoite.</li>
		    <li>Kauppias voi merkitä tilauksen käsitellyksi.</li>
		  </ul>
		  
		  <p>Kauppiaan toiminnallisuuden tulee olla salasanan takana, mutta asiakas voi käyttää järjestelmää myös ilman salasanaa.</p>
		  
		  
                </div>
              </div>
            </div>		
	    
          </section>
          <!-- END OSAX --->
	  
	  
	  
	</article>


<!-- BEGIN FOOTER -->

        <footer>
            <p>
                <a id="license" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Hellas</a> sekä <a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;.
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>

        <script src="js/libs/chartist.min.js"></script>
        <script src="js/libs/visibility.core.js"></script>
        <script src="js/libs/visibility.timers.js"></script>
        <script src="js/libs/visibility.fallback.js"></script>
        <script src="js/js-logger.js"></script>
        <script src="js/verticalfloat.js"></script>
        <script src="js/pheromones.js"></script>
        <script src="js/wepa.js"></script>


    </body>
</html>
<!-- END FOOTER -->
